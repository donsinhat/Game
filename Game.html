<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>ÿ∞Ÿáÿ® ÿ£ÿµŸÅÿ± ÿ£Ÿà ÿØŸÖ ÿ£ÿ≠ŸÖÿ± - Gold or Blood</title>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700;900&family=Changa:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }
        
        body {
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0f0f1a 100%);
            font-family: 'Cairo', 'Changa', sans-serif;
            overflow: hidden;
            min-height: 100vh;
            color: #fff;
        }
        
        #gameCanvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        
        /* Main Menu Styles */
        #mainMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            background: linear-gradient(180deg, rgba(10,10,15,0.95) 0%, rgba(26,26,46,0.98) 100%);
        }
        
        .menu-title {
            font-size: clamp(2rem, 8vw, 4rem);
            font-weight: 900;
            text-align: center;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #ffd700 0%, #ff8c00 50%, #ffd700 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            animation: titleGlow 2s ease-in-out infinite alternate;
        }
        
        .menu-subtitle {
            font-size: clamp(1rem, 4vw, 1.5rem);
            color: #cc0000;
            margin-bottom: 40px;
            text-shadow: 0 0 20px rgba(204, 0, 0, 0.7);
        }
        
        @keyframes titleGlow {
            from { filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.5)); }
            to { filter: drop-shadow(0 0 40px rgba(255, 215, 0, 0.8)); }
        }
        
        /* Character Selection */
        .character-carousel {
            display: flex;
            gap: 20px;
            margin-bottom: 40px;
            padding: 20px;
            overflow-x: auto;
            max-width: 100%;
        }
        
        .character-card {
            min-width: 200px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 215, 0, 0.2);
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }
        
        .character-card:hover, .character-card.selected {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.1);
            transform: translateY(-10px);
            box-shadow: 0 20px 40px rgba(255, 215, 0, 0.2);
        }
        
        .character-card canvas {
            width: 100px;
            height: 100px;
            image-rendering: pixelated;
            margin-bottom: 15px;
        }
        
        .character-name {
            font-size: 1.3rem;
            font-weight: 700;
            color: #ffd700;
            margin-bottom: 5px;
        }
        
        .character-passive {
            font-size: 0.9rem;
            color: #88ff88;
            margin-bottom: 10px;
        }
        
        .character-weapon {
            font-size: 0.85rem;
            color: #ff8888;
        }
        
        /* Buttons */
        .btn {
            padding: 15px 50px;
            font-size: 1.3rem;
            font-family: 'Cairo', sans-serif;
            font-weight: 700;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%);
            color: #000;
            box-shadow: 0 10px 30px rgba(255, 215, 0, 0.4);
        }
        
        .btn-primary:hover {
            transform: scale(1.1);
            box-shadow: 0 15px 40px rgba(255, 215, 0, 0.6);
        }
        
        /* HUD Styles */
        #hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            padding: 15px 20px;
            display: none;
            justify-content: space-between;
            align-items: flex-start;
            z-index: 50;
            pointer-events: none;
        }
        
        .hud-left, .hud-right {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .hud-bar {
            width: 200px;
            height: 25px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        .hud-bar-fill {
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 15px;
        }
        
        .health-fill {
            background: linear-gradient(90deg, #ff4444 0%, #ff0000 100%);
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
        }
        
        .xp-fill {
            background: linear-gradient(90deg, #44ff44 0%, #00ff00 100%);
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }
        
        .hud-text {
            font-size: 1rem;
            font-weight: 700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }
        
        .hud-stat {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1.1rem;
            font-weight: 700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }
        
        .gold-text { color: #ffd700; }
        .kill-text { color: #ff4444; }
        .level-text { color: #44ff44; }
        
        /* Level Up Modal */
        #levelUpModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        
        .level-up-content {
            text-align: center;
            padding: 40px;
            background: rgba(20, 20, 30, 0.95);
            backdrop-filter: blur(20px);
            border: 3px solid #ffd700;
            border-radius: 30px;
            max-width: 90%;
        }
        
        .level-up-title {
            font-size: 2.5rem;
            color: #ffd700;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        }
        
        .upgrade-options {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .upgrade-btn {
            padding: 20px 30px;
            min-width: 150px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 215, 0, 0.5);
            border-radius: 15px;
            color: #fff;
            font-family: 'Cairo', sans-serif;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .upgrade-btn:hover {
            background: rgba(255, 215, 0, 0.2);
            border-color: #ffd700;
            transform: scale(1.05);
        }
        
        .upgrade-icon {
            font-size: 2rem;
            margin-bottom: 10px;
        }
        
        /* Game Over Screen */
        #gameOverScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
        }
        
        .game-over-title {
            font-size: 3rem;
            color: #ff0000;
            margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(255, 0, 0, 0.8);
        }
        
        .final-stats {
            margin-bottom: 30px;
            font-size: 1.2rem;
        }
        
        /* Pause indicator */
        #pauseIndicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            color: #ffd700;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
            display: none;
            z-index: 150;
        }
        
        /* Mobile optimization */
        @media (max-width: 768px) {
            .character-carousel {
                flex-direction: column;
                align-items: center;
            }
            
            .character-card {
                min-width: 280px;
            }
            
            .hud-bar {
                width: 150px;
                height: 20px;
            }
            
            .upgrade-options {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <!-- Main Menu -->
    <div id="mainMenu">
        <h1 class="menu-title">ÿ∞Ÿáÿ® ÿ£ÿµŸÅÿ± ÿ£Ÿà ÿØŸÖ ÿ£ÿ≠ŸÖÿ±</h1>
        <p class="menu-subtitle">Gold or Blood</p>
        
        <div class="character-carousel" id="characterCarousel">
            <!-- Characters will be generated by JS -->
        </div>
        
        <button class="btn btn-primary" id="startBtn">ÿßÿ®ÿØÿ£ ÿßŸÑŸÑÿπÿ®</button>
    </div>
    
    <!-- HUD -->
    <div id="hud">
        <div class="hud-left">
            <div class="hud-bar">
                <div class="hud-bar-fill health-fill" id="healthBar" style="width: 100%"></div>
            </div>
            <div class="hud-bar">
                <div class="hud-bar-fill xp-fill" id="xpBar" style="width: 0%"></div>
            </div>
            <span class="hud-text level-text" id="levelText">ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ: 1</span>
        </div>
        <div class="hud-right">
            <span class="hud-stat gold-text">üí∞ <span id="goldText">0</span></span>
            <span class="hud-stat kill-text">üíÄ <span id="killText">0</span></span>
            <span class="hud-stat" id="timerText">‚è±Ô∏è 00:00</span>
        </div>
    </div>
    
    <!-- Level Up Modal -->
    <div id="levelUpModal">
        <div class="level-up-content">
            <h2 class="level-up-title">üéâ ŸÖÿ≥ÿ™ŸàŸâ ÿ¨ÿØŸäÿØ! üéâ</h2>
            <div class="upgrade-options" id="upgradeOptions">
                <!-- Upgrades will be generated by JS -->
            </div>
        </div>
    </div>
    
    <!-- Game Over Screen -->
    <div id="gameOverScreen">
        <h1 class="game-over-title">ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑŸÑÿπÿ®ÿ©</h1>
        <div class="final-stats" id="finalStats"></div>
        <button class="btn btn-primary" id="restartBtn">ÿßŸÑÿπÿ® ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ</button>
    </div>
    
    <!-- Pause Indicator -->
    <div id="pauseIndicator">‚è∏Ô∏è ÿ•ŸäŸÇÿßŸÅ ŸÖÿ§ŸÇÿ™</div>

    <script>
// ==================== GAME CONFIGURATION ====================
const CONFIG = {
    // Display
    PIXEL_SCALE: 4,
    TARGET_FPS: 60,
    
    // Player
    PLAYER_SPEED: 200,
    PLAYER_MAX_HEALTH: 100,
    PLAYER_LIGHT_RADIUS: 250,
    
    // Enemies
    ENEMY_SPAWN_RATE: 1500,
    ENEMY_SPAWN_DISTANCE: 500,
    MAX_ENEMIES: 100,
    
    // XP & Leveling
    BASE_XP_REQUIRED: 10,
    XP_MULTIPLIER: 1.5,
    
    // World
    WORLD_SIZE: 5000,
    TILE_SIZE: 64,
};

// ==================== PROCEDURAL PIXEL ART ENGINE ====================
class PixelArtEngine {
    constructor() {
        this.spriteCache = new Map();
    }
    
    // Create a sprite from a pixel matrix
    createSprite(matrix, colorPalette, scale = 1) {
        const height = matrix.length;
        const width = matrix[0].length;
        const canvas = document.createElement('canvas');
        canvas.width = width * scale;
        canvas.height = height * scale;
        const ctx = canvas.getContext('2d');
        
        ctx.imageSmoothingEnabled = false;
        
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const colorIndex = matrix[y][x];
                if (colorIndex > 0 && colorPalette[colorIndex]) {
                    ctx.fillStyle = colorPalette[colorIndex];
                    ctx.fillRect(x * scale, y * scale, scale, scale);
                }
            }
        }
        
        return canvas;
    }
    
    // Generate glow effect
    addGlow(canvas, color, blur = 10) {
        const glowCanvas = document.createElement('canvas');
        glowCanvas.width = canvas.width + blur * 2;
        glowCanvas.height = canvas.height + blur * 2;
        const ctx = glowCanvas.getContext('2d');
        
        ctx.shadowColor = color;
        ctx.shadowBlur = blur;
        ctx.drawImage(canvas, blur, blur);
        ctx.drawImage(canvas, blur, blur);
        
        return glowCanvas;
    }
}

// ==================== CHARACTER SPRITES ====================
const SPRITE_DATA = {
    // Abu Sulaiman - Wealthy Merchant
    abuSulaiman: {
        idle: [
            [0,0,0,0,0,1,1,1,1,1,0,0,0,0,0],
            [0,0,0,0,1,1,1,1,1,1,1,0,0,0,0],
            [0,0,0,1,2,2,2,2,2,2,2,1,0,0,0],
            [0,0,0,1,2,2,2,2,2,2,2,1,0,0,0],
            [0,0,1,2,2,2,2,2,2,2,2,2,1,0,0],
            [0,0,1,3,3,4,4,4,4,4,3,3,1,0,0],
            [0,0,0,3,4,5,4,4,4,5,4,3,0,0,0],
            [0,0,0,3,4,4,4,4,4,4,4,3,0,0,0],
            [0,0,0,3,4,4,6,6,6,4,4,3,0,0,0],
            [0,0,0,0,3,4,4,4,4,4,3,0,0,0,0],
            [0,0,0,0,0,6,6,6,6,6,0,0,0,0,0],
            [0,0,7,7,7,7,7,7,7,7,7,7,7,0,0],
            [0,7,7,7,7,7,7,7,7,7,7,7,7,7,0],
            [0,7,8,8,7,7,7,7,7,7,7,8,8,7,0],
            [0,7,8,4,8,7,7,7,7,7,8,4,8,7,0],
            [0,7,8,8,7,7,7,7,7,7,7,8,8,7,0],
            [0,7,7,7,7,7,7,7,7,7,7,7,7,7,0],
            [0,0,7,7,7,7,7,7,7,7,7,7,7,0,0],
            [0,0,0,7,7,7,7,7,7,7,7,7,0,0,0],
            [0,0,0,0,7,7,7,7,7,7,7,0,0,0,0],
            [0,0,0,0,7,7,0,0,0,7,7,0,0,0,0],
            [0,0,0,0,9,9,0,0,0,9,9,0,0,0,0],
        ],
        palette: {
            1: '#1a1a1a', // Black Agal
            2: '#cc0000', // Red Shemagh
            3: '#d4a574', // Skin
            4: '#c4956a', // Skin shadow
            5: '#2a2a2a', // Eyes
            6: '#3a2a1a', // Beard
            7: '#f5f5f5', // White Thobe
            8: '#8b6914', // Brown Bisht
            9: '#2a2a2a', // Sandals
        }
    },
    
    // Jayzen - Tough Fighter
    jayzen: {
        idle: [
            [0,0,0,0,1,1,1,1,1,1,1,0,0,0,0],
            [0,0,0,1,1,1,1,1,1,1,1,1,0,0,0],
            [0,0,1,1,1,1,1,1,1,1,1,1,1,0,0],
            [0,0,1,2,2,2,2,2,2,2,2,2,1,0,0],
            [0,0,0,2,2,2,2,2,2,2,2,2,0,0,0],
            [0,0,3,3,4,4,4,4,4,4,4,3,3,0,0],
            [0,0,3,5,5,6,4,4,4,6,5,5,3,0,0],
            [0,0,0,3,4,4,4,4,4,4,4,3,0,0,0],
            [0,0,0,3,4,4,4,7,4,4,4,3,0,0,0],
            [0,0,0,0,3,4,4,4,4,4,3,0,0,0,0],
            [0,0,0,8,8,8,8,8,8,8,8,8,0,0,0],
            [0,0,8,8,8,8,8,8,8,8,8,8,8,0,0],
            [0,8,8,8,8,8,8,8,8,8,8,8,8,8,0],
            [0,8,3,3,8,8,8,8,8,8,8,3,3,8,0],
            [0,8,3,4,3,8,8,8,8,8,3,4,3,8,0],
            [0,0,8,8,8,8,8,8,8,8,8,8,8,0,0],
            [0,0,0,9,9,9,9,9,9,9,9,9,0,0,0],
            [0,0,0,9,9,9,9,9,9,9,9,9,0,0,0],
            [0,0,0,9,9,9,9,9,9,9,9,9,0,0,0],
            [0,0,0,0,9,9,0,0,0,9,9,0,0,0,0],
            [0,0,0,0,10,10,0,0,0,10,10,0,0,0,0],
        ],
        palette: {
            1: '#2a1a0a', // Afro hair
            2: '#cc3333', // Red Shemagh (messy)
            3: '#d4a574', // Skin
            4: '#c4956a', // Skin shadow
            5: '#1a1a1a', // Sunglasses
            6: '#333333', // Sunglasses lens
            7: '#c4956a', // Mouth
            8: '#6a1b9a', // Purple shirt
            9: '#555555', // Grey pants
            10: '#3a3a3a', // Shoes
        }
    },
    
    // Noura - Strong Woman
    noura: {
        idle: [
            [0,0,0,0,1,1,1,1,1,1,1,0,0,0,0],
            [0,0,0,1,1,1,1,1,1,1,1,1,0,0,0],
            [0,0,1,1,1,1,1,1,1,1,1,1,1,0,0],
            [0,0,1,1,1,1,1,1,1,1,1,1,1,0,0],
            [0,0,0,1,1,1,1,1,1,1,1,1,0,0,0],
            [0,0,1,1,2,2,2,2,2,2,2,1,1,0,0],
            [0,0,1,2,3,4,2,2,2,4,3,2,1,0,0],
            [0,0,0,2,2,2,2,2,2,2,2,2,0,0,0],
            [0,0,0,2,2,2,5,5,5,2,2,2,0,0,0],
            [0,0,0,0,1,2,2,2,2,2,1,0,0,0,0],
            [0,0,6,6,6,6,6,6,6,6,6,6,6,0,0],
            [0,6,6,6,6,6,6,6,6,6,6,6,6,6,0],
            [6,6,6,6,6,6,6,6,6,6,6,6,6,6,6],
            [6,6,2,2,6,6,6,6,6,6,6,2,2,6,6],
            [6,6,2,7,2,6,6,6,6,6,2,7,2,6,6],
            [6,6,6,6,6,6,6,6,6,6,6,6,6,6,6],
            [0,6,6,6,6,6,6,6,6,6,6,6,6,6,0],
            [0,0,6,6,6,6,6,6,6,6,6,6,6,0,0],
            [0,0,0,6,6,6,6,6,6,6,6,6,0,0,0],
            [0,0,0,0,6,6,0,0,0,6,6,0,0,0,0],
            [0,0,0,0,8,8,0,0,0,8,8,0,0,0,0],
        ],
        palette: {
            1: '#f5f5f5', // White Hijab
            2: '#e8d5c4', // Skin (lighter)
            3: '#1a1a1a', // Eyes
            4: '#c4956a', // Eye shadow
            5: '#d4a4a4', // Lips
            6: '#1e88e5', // Blue Dress
            7: '#e8d5c4', // Hands
            8: '#1565c0', // Shoes
        }
    },
    
    // Wolf Enemy
    wolf: {
        idle: [
            [0,0,1,1,0,0,0,0,0,1,1,0],
            [0,1,2,2,1,0,0,0,1,2,2,1],
            [0,1,2,2,2,1,1,1,2,2,2,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,2,3,2,2,2,2,2,2,2,3,2,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,1],
            [0,1,2,2,2,4,4,4,2,2,2,1,0],
            [0,0,1,2,2,2,2,2,2,2,1,0,0],
            [0,0,1,2,2,2,2,2,2,2,1,0,0],
            [0,1,2,2,1,2,2,2,1,2,2,1,0],
            [0,1,2,1,0,1,2,1,0,1,2,1,0],
        ],
        palette: {
            1: '#3a3a3a', // Dark grey outline
            2: '#6a6a6a', // Grey fur
            3: '#ffff00', // Yellow eyes
            4: '#2a2a2a', // Nose
        }
    },
    
    // Dhub (Lizard) Enemy
    dhub: {
        idle: [
            [0,0,0,1,1,0,0,0,0,0,0,0,0],
            [0,0,1,2,2,1,0,0,0,0,0,0,0],
            [0,1,2,3,2,2,1,1,1,1,1,0,0],
            [1,2,2,2,2,2,2,2,2,2,2,1,0],
            [1,2,2,2,2,2,2,2,2,2,2,2,1],
            [0,1,2,2,2,2,2,2,2,2,2,1,0],
            [0,1,1,2,1,2,2,2,1,2,1,1,0],
            [0,0,0,1,0,1,2,1,0,1,0,0,0],
            [0,0,0,0,0,0,4,0,0,0,0,0,0],
            [0,0,0,0,0,4,5,4,0,0,0,0,0],
            [0,0,0,0,0,0,4,0,0,0,0,0,0],
        ],
        palette: {
            1: '#3a5a3a', // Dark green outline
            2: '#5a8a5a', // Green body
            3: '#ff0000', // Red eye
            4: '#8a6a3a', // Brown tail spikes
            5: '#6a5a4a', // Tail
        }
    },
    
    // Scorpion Enemy
    scorpion: {
        idle: [
            [0,0,1,0,0,0,0,0,1,0,0],
            [0,1,2,1,0,0,0,1,2,1,0],
            [1,2,2,2,1,1,1,2,2,2,1],
            [0,1,2,3,2,2,2,3,2,1,0],
            [0,0,1,2,2,2,2,2,1,0,0],
            [0,0,1,2,2,2,2,2,1,0,0],
            [0,1,0,1,2,2,2,1,0,1,0],
            [1,0,0,0,1,2,1,0,0,0,1],
            [0,0,0,0,0,4,0,0,0,0,0],
            [0,0,0,0,4,5,4,0,0,0,0],
            [0,0,0,0,0,5,0,0,0,0,0],
        ],
        palette: {
            1: '#8a6a00', // Dark yellow outline
            2: '#ffa500', // Orange body
            3: '#ff0000', // Red eyes
            4: '#aa8a00', // Tail segment
            5: '#ff0000', // Stinger
        }
    },
    
    // XP Gem
    xpGem: {
        idle: [
            [0,0,1,1,0,0],
            [0,1,2,2,1,0],
            [1,2,3,3,2,1],
            [1,2,3,3,2,1],
            [0,1,2,2,1,0],
            [0,0,1,1,0,0],
        ],
        palette: {
            1: '#00aa00',
            2: '#00ff00',
            3: '#aaffaa',
        }
    },
    
    // Gold Coin
    goldCoin: {
        idle: [
            [0,0,1,1,1,0,0],
            [0,1,2,2,2,1,0],
            [1,2,3,2,3,2,1],
            [1,2,2,2,2,2,1],
            [1,2,3,2,3,2,1],
            [0,1,2,2,2,1,0],
            [0,0,1,1,1,0,0],
        ],
        palette: {
            1: '#aa8800',
            2: '#ffdd00',
            3: '#ffffff',
        }
    }
};

// ==================== AUDIO SYSTEM ====================
class AudioSystem {
    constructor() {
        this.ctx = null;
        this.initialized = false;
        this.hitSound = null;
        this.loadCustomSound();
    }
    
    init() {
        if (this.initialized) return;
        try {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.initialized = true;
        } catch (e) {
            console.log('Audio not supported');
        }
    }
    
    async loadCustomSound() {
        try {
            const response = await fetch('ÿßŸàŸäŸÑÿßŸà.mp3');
            if (response.ok) {
                const arrayBuffer = await response.arrayBuffer();
                this.hitSound = arrayBuffer;
            }
        } catch (e) {
            // Will use synth fallback
        }
    }
    
    playTone(freq, duration, type = 'square', volume = 0.3) {
        if (!this.ctx) return;
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = type;
        osc.frequency.value = freq;
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        
        gain.gain.setValueAtTime(volume, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        
        osc.start(this.ctx.currentTime);
        osc.stop(this.ctx.currentTime + duration);
    }
    
    playCoin() {
        this.playTone(880, 0.1, 'square', 0.2);
        setTimeout(() => this.playTone(1100, 0.15, 'square', 0.2), 50);
    }
    
    playHit() {
        if (this.hitSound && this.ctx) {
            this.ctx.decodeAudioData(this.hitSound.slice(0), (buffer) => {
                const source = this.ctx.createBufferSource();
                source.buffer = buffer;
                source.connect(this.ctx.destination);
                source.start(0);
            }, () => {
                // Fallback synth
                this.playTone(150, 0.2, 'sawtooth', 0.4);
            });
        } else {
            this.playTone(150, 0.2, 'sawtooth', 0.4);
        }
    }
    
    playShoot() {
        this.playTone(400, 0.05, 'square', 0.15);
        this.playTone(200, 0.1, 'square', 0.1);
    }
    
    playLevelUp() {
        const notes = [523, 659, 784, 1047];
        notes.forEach((freq, i) => {
            setTimeout(() => this.playTone(freq, 0.2, 'sine', 0.3), i * 100);
        });
    }
    
    playEnemyDeath() {
        this.playTone(200, 0.1, 'sawtooth', 0.2);
        this.playTone(100, 0.15, 'sawtooth', 0.15);
    }
    
    playXP() {
        this.playTone(600, 0.05, 'sine', 0.15);
    }
}

// ==================== PARTICLE SYSTEM ====================
class Particle {
    constructor(x, y, vx, vy, color, size, life, type = 'normal') {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.color = color;
        this.size = size;
        this.life = life;
        this.maxLife = life;
        this.type = type;
        this.gravity = type === 'blood' ? 200 : 0;
    }
    
    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.vy += this.gravity * dt;
        this.life -= dt;
    }
    
    draw(ctx, camera) {
        const alpha = Math.max(0, this.life / this.maxLife);
        ctx.globalAlpha = alpha;
        ctx.fillStyle = this.color;
        
        const screenX = this.x - camera.x;
        const screenY = this.y - camera.y;
        
        if (this.type === 'blood') {
            ctx.beginPath();
            ctx.arc(screenX, screenY, this.size, 0, Math.PI * 2);
            ctx.fill();
        } else {
            ctx.fillRect(screenX - this.size/2, screenY - this.size/2, this.size, this.size);
        }
        ctx.globalAlpha = 1;
    }
}

class ParticleSystem {
    constructor() {
        this.particles = [];
        this.bloodStains = [];
    }
    
    emit(x, y, count, options = {}) {
        const {
            color = '#ffffff',
            minSpeed = 50,
            maxSpeed = 150,
            minSize = 2,
            maxSize = 5,
            minLife = 0.3,
            maxLife = 1,
            type = 'normal'
        } = options;
        
        for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = minSpeed + Math.random() * (maxSpeed - minSpeed);
            const particle = new Particle(
                x, y,
                Math.cos(angle) * speed,
                Math.sin(angle) * speed,
                color,
                minSize + Math.random() * (maxSize - minSize),
                minLife + Math.random() * (maxLife - minLife),
                type
            );
            this.particles.push(particle);
        }
    }
    
    emitDust(x, y) {
        this.emit(x, y, 2, {
            color: '#d4a574',
            minSpeed: 10,
            maxSpeed: 30,
            minSize: 2,
            maxSize: 4,
            minLife: 0.2,
            maxLife: 0.5
        });
    }
    
    emitBlood(x, y) {
        // Blood particles
        this.emit(x, y, 15, {
            color: '#8b0000',
            minSpeed: 50,
            maxSpeed: 200,
            minSize: 2,
            maxSize: 6,
            minLife: 0.5,
            maxLife: 1.5,
            type: 'blood'
        });
        
        // Persistent blood stain
        this.bloodStains.push({
            x: x,
            y: y,
            size: 10 + Math.random() * 15,
            alpha: 0.7
        });
        
        // Limit stains for performance
        if (this.bloodStains.length > 200) {
            this.bloodStains.shift();
        }
    }
    
    update(dt) {
        this.particles = this.particles.filter(p => {
            p.update(dt);
            return p.life > 0;
        });
    }
    
    drawStains(ctx, camera) {
        ctx.fillStyle = '#4a0000';
        for (const stain of this.bloodStains) {
            const screenX = stain.x - camera.x;
            const screenY = stain.y - camera.y;
            ctx.globalAlpha = stain.alpha * 0.5;
            ctx.beginPath();
            ctx.arc(screenX, screenY, stain.size, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;
    }
    
    draw(ctx, camera) {
        for (const particle of this.particles) {
            particle.draw(ctx, camera);
        }
    }
}

// ==================== FLOATING TEXT ====================
class FloatingText {
    constructor(x, y, text, color = '#ffffff') {
        this.x = x;
        this.y = y;
        this.text = text;
        this.color = color;
        this.life = 1;
        this.vy = -80;
    }
    
    update(dt) {
        this.y += this.vy * dt;
        this.life -= dt;
    }
    
    draw(ctx, camera) {
        const alpha = Math.max(0, this.life);
        ctx.globalAlpha = alpha;
        ctx.fillStyle = this.color;
        ctx.font = 'bold 20px Cairo';
        ctx.textAlign = 'center';
        ctx.fillText(this.text, this.x - camera.x, this.y - camera.y);
        ctx.globalAlpha = 1;
    }
}

// ==================== GAME ENTITIES ====================
class Entity {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.width = 32;
        this.height = 32;
        this.sprite = null;
    }
    
    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
    }
    
    draw(ctx, camera) {
        if (this.sprite) {
            const screenX = this.x - camera.x - this.sprite.width / 2;
            const screenY = this.y - camera.y - this.sprite.height / 2;
            ctx.drawImage(this.sprite, screenX, screenY);
        }
    }
    
    collidesWith(other) {
        return Math.abs(this.x - other.x) < (this.width + other.width) / 2 &&
               Math.abs(this.y - other.y) < (this.height + other.height) / 2;
    }
}

class Player extends Entity {
    constructor(x, y, characterType) {
        super(x, y);
        this.characterType = characterType;
        this.maxHealth = CONFIG.PLAYER_MAX_HEALTH;
        this.health = this.maxHealth;
        this.speed = CONFIG.PLAYER_SPEED;
        this.damage = 10;
        this.xp = 0;
        this.level = 1;
        this.gold = 0;
        this.kills = 0;
        this.pickupRange = 50;
        this.invulnerable = 0;
        
        // Apply character passives
        this.goldMultiplier = 1;
        this.damageReduction = 0;
        
        if (characterType === 'abuSulaiman') {
            this.goldMultiplier = 1.2;
        } else if (characterType === 'jayzen') {
            this.damageReduction = 0.3;
        } else if (characterType === 'noura') {
            this.pickupRange = 120;
        }
        
        this.width = 40;
        this.height = 60;
        this.facing = 1; // 1 = right, -1 = left
        this.animTimer = 0;
        
        // Weapon
        this.weaponTimer = 0;
        this.weaponCooldown = 0.5;
        
        // Walking dust timer
        this.dustTimer = 0;
    }
    
    update(dt, input, game) {
        // Movement
        let dx = 0, dy = 0;
        
        if (input.left) dx -= 1;
        if (input.right) dx += 1;
        if (input.up) dy -= 1;
        if (input.down) dy += 1;
        
        // Add joystick input
        if (input.joystick) {
            dx += input.joystick.x;
            dy += input.joystick.y;
        }
        
        // Normalize
        const mag = Math.sqrt(dx * dx + dy * dy);
        if (mag > 0) {
            dx /= mag;
            dy /= mag;
            
            this.vx = dx * this.speed;
            this.vy = dy * this.speed;
            
            if (dx !== 0) this.facing = dx > 0 ? 1 : -1;
            
            // Emit dust
            this.dustTimer -= dt;
            if (this.dustTimer <= 0) {
                game.particles.emitDust(this.x, this.y + this.height / 2);
                this.dustTimer = 0.1;
            }
        } else {
            this.vx = 0;
            this.vy = 0;
        }
        
        super.update(dt);
        
        // Clamp to world bounds
        this.x = Math.max(-CONFIG.WORLD_SIZE/2, Math.min(CONFIG.WORLD_SIZE/2, this.x));
        this.y = Math.max(-CONFIG.WORLD_SIZE/2, Math.min(CONFIG.WORLD_SIZE/2, this.y));
        
        // Invulnerability
        if (this.invulnerable > 0) {
            this.invulnerable -= dt;
        }
        
        // Animation
        this.animTimer += dt;
        
        // Weapon
        this.weaponTimer -= dt;
        if (this.weaponTimer <= 0) {
            this.fireWeapon(game);
            this.weaponTimer = this.weaponCooldown;
        }
    }
    
    fireWeapon(game) {
        if (this.characterType === 'abuSulaiman') {
            // The Agal - spinning cord (handled in draw as aura)
        } else if (this.characterType === 'jayzen') {
            // The Rock - projectile at nearest enemy
            let nearest = null;
            let nearestDist = Infinity;
            for (const enemy of game.enemies) {
                const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                if (dist < nearestDist && dist < 400) {
                    nearestDist = dist;
                    nearest = enemy;
                }
            }
            
            if (nearest) {
                const angle = Math.atan2(nearest.y - this.y, nearest.x - this.x);
                game.projectiles.push(new Projectile(
                    this.x, this.y,
                    Math.cos(angle) * 400,
                    Math.sin(angle) * 400,
                    this.damage,
                    '#8b4513',
                    8
                ));
                game.audio.playShoot();
            }
        } else if (this.characterType === 'noura') {
            // Al-Hiba - aura damage (handled in game update)
        }
    }
    
    takeDamage(amount, game) {
        if (this.invulnerable > 0) return;
        
        const actualDamage = amount * (1 - this.damageReduction);
        this.health -= actualDamage;
        this.invulnerable = 0.5;
        
        game.audio.playHit();
        game.screenShake = 0.2;
        game.floatingTexts.push(new FloatingText(this.x, this.y - 30, `-${Math.round(actualDamage)}`, '#ff0000'));
        
        if (this.health <= 0) {
            game.gameOver();
        }
    }
    
    draw(ctx, camera, game) {
        const screenX = this.x - camera.x;
        const screenY = this.y - camera.y;
        
        // Draw invulnerability flash
        if (this.invulnerable > 0 && Math.floor(this.invulnerable * 10) % 2 === 0) {
            ctx.globalAlpha = 0.5;
        }
        
        // Draw sprite
        if (this.sprite) {
            ctx.save();
            if (this.facing < 0) {
                ctx.scale(-1, 1);
                ctx.drawImage(this.sprite, -screenX - this.sprite.width/2, screenY - this.sprite.height/2);
            } else {
                ctx.drawImage(this.sprite, screenX - this.sprite.width/2, screenY - this.sprite.height/2);
            }
            ctx.restore();
        }
        
        ctx.globalAlpha = 1;
        
        // Draw weapon effects
        if (this.characterType === 'abuSulaiman') {
            // Spinning Agal
            const agalRadius = 60;
            const agalAngle = this.animTimer * 3;
            for (let i = 0; i < 8; i++) {
                const angle = agalAngle + (i * Math.PI / 4);
                const ax = screenX + Math.cos(angle) * agalRadius;
                const ay = screenY + Math.sin(angle) * agalRadius;
                ctx.fillStyle = '#1a1a1a';
                ctx.beginPath();
                ctx.arc(ax, ay, 5, 0, Math.PI * 2);
                ctx.fill();
            }
        } else if (this.characterType === 'noura') {
            // Al-Hiba aura
            const auraRadius = 80 + Math.sin(this.animTimer * 4) * 10;
            ctx.strokeStyle = 'rgba(138, 43, 226, 0.5)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(screenX, screenY, auraRadius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Inner glow
            const gradient = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, auraRadius);
            gradient.addColorStop(0, 'rgba(138, 43, 226, 0.1)');
            gradient.addColorStop(1, 'rgba(138, 43, 226, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(screenX, screenY, auraRadius, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}

class Enemy extends Entity {
    constructor(x, y, type) {
        super(x, y);
        this.type = type;
        this.speed = 80;
        this.health = 20;
        this.maxHealth = 20;
        this.damage = 10;
        this.xpValue = 3;
        this.goldValue = 1;
        
        // Type-specific stats
        if (type === 'wolf') {
            this.speed = 100;
            this.health = this.maxHealth = 25;
            this.damage = 12;
            this.width = this.height = 35;
        } else if (type === 'dhub') {
            this.speed = 60;
            this.health = this.maxHealth = 40;
            this.damage = 15;
            this.width = 40;
            this.height = 30;
            this.zigzagTimer = 0;
            this.zigzagDir = 1;
        } else if (type === 'scorpion') {
            this.speed = 130;
            this.health = this.maxHealth = 15;
            this.damage = 8;
            this.width = this.height = 25;
        }
        
        this.hitFlash = 0;
    }
    
    update(dt, player, enemies) {
        // Direction to player
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const dist = Math.hypot(dx, dy);
        
        if (dist > 0) {
            let moveX = dx / dist;
            let moveY = dy / dist;
            
            // Dhub zigzag
            if (this.type === 'dhub') {
                this.zigzagTimer += dt;
                if (this.zigzagTimer > 0.5) {
                    this.zigzagTimer = 0;
                    this.zigzagDir *= -1;
                }
                // Perpendicular movement
                const perpX = -moveY * this.zigzagDir;
                const perpY = moveX * this.zigzagDir;
                moveX = moveX * 0.7 + perpX * 0.3;
                moveY = moveY * 0.7 + perpY * 0.3;
            }
            
            // Flocking behavior - avoid other enemies
            let separationX = 0, separationY = 0;
            for (const other of enemies) {
                if (other === this) continue;
                const ox = this.x - other.x;
                const oy = this.y - other.y;
                const od = Math.hypot(ox, oy);
                if (od < 40 && od > 0) {
                    separationX += ox / od * (40 - od) / 40;
                    separationY += oy / od * (40 - od) / 40;
                }
            }
            
            moveX += separationX * 0.5;
            moveY += separationY * 0.5;
            
            // Normalize
            const moveMag = Math.hypot(moveX, moveY);
            if (moveMag > 0) {
                this.vx = (moveX / moveMag) * this.speed;
                this.vy = (moveY / moveMag) * this.speed;
            }
        }
        
        super.update(dt);
        
        // Hit flash
        if (this.hitFlash > 0) {
            this.hitFlash -= dt;
        }
    }
    
    takeDamage(amount, game) {
        this.health -= amount;
        this.hitFlash = 0.1;
        
        game.floatingTexts.push(new FloatingText(
            this.x + (Math.random() - 0.5) * 20,
            this.y - 20,
            Math.round(amount).toString(),
            '#ffff00'
        ));
        
        if (this.health <= 0) {
            return true; // Dead
        }
        return false;
    }
    
    draw(ctx, camera) {
        const screenX = this.x - camera.x;
        const screenY = this.y - camera.y;
        
        if (this.hitFlash > 0) {
            ctx.globalAlpha = 0.7;
        }
        
        if (this.sprite) {
            ctx.drawImage(this.sprite, screenX - this.sprite.width/2, screenY - this.sprite.height/2);
        }
        
        ctx.globalAlpha = 1;
        
        // Health bar
        if (this.health < this.maxHealth) {
            const barWidth = 30;
            const barHeight = 4;
            ctx.fillStyle = '#333';
            ctx.fillRect(screenX - barWidth/2, screenY - this.height/2 - 10, barWidth, barHeight);
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(screenX - barWidth/2, screenY - this.height/2 - 10, barWidth * (this.health / this.maxHealth), barHeight);
        }
    }
}

class Projectile extends Entity {
    constructor(x, y, vx, vy, damage, color = '#ffff00', size = 5) {
        super(x, y);
        this.vx = vx;
        this.vy = vy;
        this.damage = damage;
        this.color = color;
        this.size = size;
        this.width = size * 2;
        this.height = size * 2;
        this.life = 3;
    }
    
    update(dt) {
        super.update(dt);
        this.life -= dt;
    }
    
    draw(ctx, camera) {
        const screenX = this.x - camera.x;
        const screenY = this.y - camera.y;
        
        // Glow
        const gradient = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, this.size * 2);
        gradient.addColorStop(0, this.color);
        gradient.addColorStop(1, 'transparent');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(screenX, screenY, this.size * 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Core
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(screenX, screenY, this.size / 2, 0, Math.PI * 2);
        ctx.fill();
    }
}

class Pickup extends Entity {
    constructor(x, y, type, value) {
        super(x, y);
        this.type = type;
        this.value = value;
        this.width = 20;
        this.height = 20;
        this.bobTimer = Math.random() * Math.PI * 2;
    }
    
    update(dt) {
        this.bobTimer += dt * 4;
    }
    
    draw(ctx, camera) {
        const screenX = this.x - camera.x;
        const screenY = this.y - camera.y + Math.sin(this.bobTimer) * 3;
        
        if (this.sprite) {
            ctx.drawImage(this.sprite, screenX - this.sprite.width/2, screenY - this.sprite.height/2);
        }
        
        // Glow effect
        const glowColor = this.type === 'xp' ? 'rgba(0, 255, 0, 0.3)' : 'rgba(255, 215, 0, 0.3)';
        ctx.fillStyle = glowColor;
        ctx.beginPath();
        ctx.arc(screenX, screenY, 15, 0, Math.PI * 2);
        ctx.fill();
    }
}

// ==================== MAIN GAME CLASS ====================
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        this.pixelArt = new PixelArtEngine();
        this.audio = new AudioSystem();
        this.particles = new ParticleSystem();
        
        this.state = 'menu'; // menu, playing, paused, gameover
        this.selectedCharacter = 'abuSulaiman';
        
        this.player = null;
        this.enemies = [];
        this.projectiles = [];
        this.pickups = [];
        this.floatingTexts = [];
        
        this.camera = { x: 0, y: 0 };
        this.screenShake = 0;
        
        this.input = {
            up: false, down: false, left: false, right: false,
            joystick: null
        };
        
        this.spawnTimer = 0;
        this.gameTime = 0;
        this.difficulty = 1;
        
        this.sprites = {};
        
        this.lastTime = 0;
        this.deltaTime = 0;
        
        this.init();
    }
    
    init() {
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        this.setupInput();
        this.generateSprites();
        this.setupMenu();
        
        requestAnimationFrame((t) => this.gameLoop(t));
    }
    
    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.ctx.imageSmoothingEnabled = false;
    }
    
    generateSprites() {
        const scale = 3;
        
        // Character sprites
        for (const char of ['abuSulaiman', 'jayzen', 'noura']) {
            const data = SPRITE_DATA[char];
            this.sprites[char] = this.pixelArt.createSprite(data.idle, data.palette, scale);
        }
        
        // Enemy sprites
        for (const enemy of ['wolf', 'dhub', 'scorpion']) {
            const data = SPRITE_DATA[enemy];
            this.sprites[enemy] = this.pixelArt.createSprite(data.idle, data.palette, scale);
        }
        
        // Pickup sprites
        this.sprites.xpGem = this.pixelArt.createSprite(SPRITE_DATA.xpGem.idle, SPRITE_DATA.xpGem.palette, 2);
        this.sprites.goldCoin = this.pixelArt.createSprite(SPRITE_DATA.goldCoin.idle, SPRITE_DATA.goldCoin.palette, 2);
    }
    
    setupMenu() {
        const carousel = document.getElementById('characterCarousel');
        const characters = [
            { id: 'abuSulaiman', name: 'ÿ£ÿ®Ÿà ÿ≥ŸÑŸäŸÖÿßŸÜ', passive: '+20% ÿ∞Ÿáÿ®', weapon: 'ÿßŸÑÿπŸÇÿßŸÑ - ÿ≠ÿ®ŸÑ ÿØŸàÿßÿ±' },
            { id: 'jayzen', name: 'ÿ¨Ÿäÿ≤ŸÜ', passive: '-30% ÿ∂ÿ±ÿ±', weapon: 'ÿßŸÑÿµÿÆÿ±ÿ© - ŸÇÿ∞ŸäŸÅÿ©' },
            { id: 'noura', name: 'ŸÜŸàÿ±ÿ©', passive: 'ŸÖÿ∫ŸÜÿßÿ∑Ÿäÿ≥ ŸÖÿ™ÿ≤ÿßŸäÿØ', weapon: 'ÿßŸÑŸáŸäÿ®ÿ© - ŸáÿßŸÑÿ© ÿ∂ÿ±ÿ±' }
        ];
        
        carousel.innerHTML = '';
        
        characters.forEach((char, index) => {
            const card = document.createElement('div');
            card.className = 'character-card' + (index === 0 ? ' selected' : '');
            card.dataset.character = char.id;
            
            // Create preview canvas
            const previewCanvas = document.createElement('canvas');
            previewCanvas.width = 100;
            previewCanvas.height = 100;
            const previewCtx = previewCanvas.getContext('2d');
            previewCtx.imageSmoothingEnabled = false;
            
            // Draw sprite centered
            const sprite = this.sprites[char.id];
            if (sprite) {
                const scale = Math.min(80 / sprite.width, 80 / sprite.height);
                const w = sprite.width * scale;
                const h = sprite.height * scale;
                previewCtx.drawImage(sprite, 50 - w/2, 50 - h/2, w, h);
            }
            
            card.innerHTML = `
                <div class="character-name">${char.name}</div>
                <div class="character-passive">${char.passive}</div>
                <div class="character-weapon">${char.weapon}</div>
            `;
            card.insertBefore(previewCanvas, card.firstChild);
            
            card.addEventListener('click', () => {
                document.querySelectorAll('.character-card').forEach(c => c.classList.remove('selected'));
                card.classList.add('selected');
                this.selectedCharacter = char.id;
            });
            
            carousel.appendChild(card);
        });
        
        document.getElementById('startBtn').addEventListener('click', () => this.startGame());
        document.getElementById('restartBtn').addEventListener('click', () => this.restartGame());
    }
    
    setupInput() {
        // Keyboard
        window.addEventListener('keydown', (e) => {
            if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') this.input.up = true;
            if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') this.input.down = true;
            if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') this.input.left = true;
            if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') this.input.right = true;
            if (e.key === 'Escape' && this.state === 'playing') this.togglePause();
            if (e.key === 'p' || e.key === 'P') this.togglePause();
        });
        
        window.addEventListener('keyup', (e) => {
            if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') this.input.up = false;
            if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') this.input.down = false;
            if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') this.input.left = false;
            if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') this.input.right = false;
        });
        
        // Touch / Virtual Joystick
        let touchStart = null;
        
        this.canvas.addEventListener('touchstart', (e) => {
            if (this.state !== 'playing') return;
            e.preventDefault();
            const touch = e.touches[0];
            touchStart = { x: touch.clientX, y: touch.clientY };
            this.input.joystick = { x: 0, y: 0 };
        }, { passive: false });
        
        this.canvas.addEventListener('touchmove', (e) => {
            if (this.state !== 'playing' || !touchStart) return;
            e.preventDefault();
            const touch = e.touches[0];
            const dx = touch.clientX - touchStart.x;
            const dy = touch.clientY - touchStart.y;
            const maxDist = 80;
            const dist = Math.min(Math.hypot(dx, dy), maxDist);
            const angle = Math.atan2(dy, dx);
            
            this.input.joystick = {
                x: (Math.cos(angle) * dist) / maxDist,
                y: (Math.sin(angle) * dist) / maxDist
            };
        }, { passive: false });
        
        this.canvas.addEventListener('touchend', (e) => {
            touchStart = null;
            this.input.joystick = null;
        });
    }
    
    startGame() {
        this.audio.init();
        
        this.state = 'playing';
        document.getElementById('mainMenu').style.display = 'none';
        document.getElementById('hud').style.display = 'flex';
        
        this.player = new Player(0, 0, this.selectedCharacter);
        this.player.sprite = this.sprites[this.selectedCharacter];
        
        this.enemies = [];
        this.projectiles = [];
        this.pickups = [];
        this.floatingTexts = [];
        this.particles.particles = [];
        this.particles.bloodStains = [];
        
        this.gameTime = 0;
        this.spawnTimer = 0;
        this.difficulty = 1;
    }
    
    restartGame() {
        document.getElementById('gameOverScreen').style.display = 'none';
        document.getElementById('mainMenu').style.display = 'flex';
        this.state = 'menu';
    }
    
    togglePause() {
        if (this.state === 'playing') {
            this.state = 'paused';
            document.getElementById('pauseIndicator').style.display = 'block';
        } else if (this.state === 'paused') {
            this.state = 'playing';
            document.getElementById('pauseIndicator').style.display = 'none';
        }
    }
    
    gameLoop(time) {
        this.deltaTime = Math.min((time - this.lastTime) / 1000, 0.1);
        this.lastTime = time;
        
        if (this.state === 'playing') {
            this.update(this.deltaTime);
        }
        
        this.draw();
        
        requestAnimationFrame((t) => this.gameLoop(t));
    }
    
    update(dt) {
        this.gameTime += dt;
        this.difficulty = 1 + Math.floor(this.gameTime / 30) * 0.2;
        
        // Update player
        this.player.update(dt, this.input, this);
        
        // Update camera
        this.camera.x = this.player.x - this.canvas.width / 2;
        this.camera.y = this.player.y - this.canvas.height / 2;
        
        // Screen shake
        if (this.screenShake > 0) {
            this.screenShake -= dt;
            this.camera.x += (Math.random() - 0.5) * 10;
            this.camera.y += (Math.random() - 0.5) * 10;
        }
        
        // Spawn enemies
        this.spawnTimer -= dt;
        if (this.spawnTimer <= 0 && this.enemies.length < CONFIG.MAX_ENEMIES) {
            this.spawnEnemy();
            this.spawnTimer = CONFIG.ENEMY_SPAWN_RATE / 1000 / this.difficulty;
        }
        
        // Update enemies
        for (const enemy of this.enemies) {
            enemy.update(dt, this.player, this.enemies);
            
            // Check collision with player
            if (enemy.collidesWith(this.player)) {
                this.player.takeDamage(enemy.damage, this);
            }
            
            // Check Abu Sulaiman's Agal
            if (this.player.characterType === 'abuSulaiman') {
                const agalRadius = 60;
                const dist = Math.hypot(enemy.x - this.player.x, enemy.y - this.player.y);
                if (dist < agalRadius + enemy.width/2) {
                    if (enemy.takeDamage(this.player.damage * 0.5 * dt * 10, this)) {
                        this.killEnemy(enemy);
                    }
                }
            }
            
            // Check Noura's Al-Hiba aura
            if (this.player.characterType === 'noura') {
                const auraRadius = 80;
                const dist = Math.hypot(enemy.x - this.player.x, enemy.y - this.player.y);
                if (dist < auraRadius + enemy.width/2) {
                    if (enemy.takeDamage(this.player.damage * 0.3 * dt * 10, this)) {
                        this.killEnemy(enemy);
                    }
                }
            }
        }
        
        // Update projectiles
        for (let i = this.projectiles.length - 1; i >= 0; i--) {
            const proj = this.projectiles[i];
            proj.update(dt);
            
            if (proj.life <= 0) {
                this.projectiles.splice(i, 1);
                continue;
            }
            
            // Check collision with enemies
            for (const enemy of this.enemies) {
                if (proj.collidesWith(enemy)) {
                    if (enemy.takeDamage(proj.damage, this)) {
                        this.killEnemy(enemy);
                    }
                    this.projectiles.splice(i, 1);
                    break;
                }
            }
        }
        
        // Remove dead enemies
        this.enemies = this.enemies.filter(e => e.health > 0);
        
        // Update pickups
        for (let i = this.pickups.length - 1; i >= 0; i--) {
            const pickup = this.pickups[i];
            pickup.update(dt);
            
            const dist = Math.hypot(pickup.x - this.player.x, pickup.y - this.player.y);
            
            // Magnet effect
            if (dist < this.player.pickupRange * 2) {
                const angle = Math.atan2(this.player.y - pickup.y, this.player.x - pickup.x);
                const speed = 200 * (1 - dist / (this.player.pickupRange * 2));
                pickup.x += Math.cos(angle) * speed * dt;
                pickup.y += Math.sin(angle) * speed * dt;
            }
            
            // Collect
            if (dist < this.player.pickupRange) {
                if (pickup.type === 'xp') {
                    this.player.xp += pickup.value;
                    this.audio.playXP();
                    this.checkLevelUp();
                } else if (pickup.type === 'gold') {
                    this.player.gold += Math.round(pickup.value * this.player.goldMultiplier);
                    this.audio.playCoin();
                }
                this.pickups.splice(i, 1);
            }
        }
        
        // Update floating texts
        this.floatingTexts = this.floatingTexts.filter(t => {
            t.update(dt);
            return t.life > 0;
        });
        
        // Update particles
        this.particles.update(dt);
        
        // Update HUD
        this.updateHUD();
    }
    
    spawnEnemy() {
        // Random position around player
        const angle = Math.random() * Math.PI * 2;
        const distance = CONFIG.ENEMY_SPAWN_DISTANCE + Math.random() * 100;
        const x = this.player.x + Math.cos(angle) * distance;
        const y = this.player.y + Math.sin(angle) * distance;
        
        // Random type
        const types = ['wolf', 'wolf', 'dhub', 'scorpion', 'scorpion'];
        const type = types[Math.floor(Math.random() * types.length)];
        
        const enemy = new Enemy(x, y, type);
        enemy.sprite = this.sprites[type];
        
        // Scale with difficulty
        enemy.health *= this.difficulty;
        enemy.maxHealth *= this.difficulty;
        enemy.damage *= this.difficulty;
        
        this.enemies.push(enemy);
    }
    
    killEnemy(enemy) {
        this.player.kills++;
        this.audio.playEnemyDeath();
        this.particles.emitBlood(enemy.x, enemy.y);
        
        // Drop XP
        const xpPickup = new Pickup(enemy.x, enemy.y, 'xp', enemy.xpValue);
        xpPickup.sprite = this.sprites.xpGem;
        this.pickups.push(xpPickup);
        
        // Chance to drop gold
        if (Math.random() < 0.3) {
            const goldPickup = new Pickup(
                enemy.x + (Math.random() - 0.5) * 20,
                enemy.y + (Math.random() - 0.5) * 20,
                'gold',
                enemy.goldValue
            );
            goldPickup.sprite = this.sprites.goldCoin;
            this.pickups.push(goldPickup);
        }
    }
    
    checkLevelUp() {
        const xpRequired = Math.floor(CONFIG.BASE_XP_REQUIRED * Math.pow(CONFIG.XP_MULTIPLIER, this.player.level - 1));
        
        if (this.player.xp >= xpRequired) {
            this.player.xp -= xpRequired;
            this.player.level++;
            this.player.health = Math.min(this.player.maxHealth, this.player.health + this.player.maxHealth * 0.3);
            
            this.audio.playLevelUp();
            this.showLevelUpModal();
        }
    }
    
    showLevelUpModal() {
        this.state = 'levelup';
        const modal = document.getElementById('levelUpModal');
        const options = document.getElementById('upgradeOptions');
        
        const upgrades = [
            { name: 'ÿµÿ≠ÿ©', icon: '‚ù§Ô∏è', effect: () => { this.player.maxHealth += 20; this.player.health += 20; } },
            { name: 'ŸÇŸàÿ©', icon: '‚öîÔ∏è', effect: () => { this.player.damage += 5; } },
            { name: 'ÿ≥ÿ±ÿπÿ©', icon: 'üëü', effect: () => { this.player.speed += 20; } },
            { name: 'ŸÖÿπÿØŸÑ ÿßŸÑŸáÿ¨ŸàŸÖ', icon: 'üî•', effect: () => { this.player.weaponCooldown *= 0.85; } },
            { name: 'ŸÖÿ∫ŸÜÿßÿ∑Ÿäÿ≥', icon: 'üß≤', effect: () => { this.player.pickupRange += 20; } }
        ];
        
        // Pick 3 random upgrades
        const selected = [];
        while (selected.length < 3) {
            const idx = Math.floor(Math.random() * upgrades.length);
            if (!selected.includes(upgrades[idx])) {
                selected.push(upgrades[idx]);
            }
        }
        
        options.innerHTML = '';
        selected.forEach(upgrade => {
            const btn = document.createElement('button');
            btn.className = 'upgrade-btn';
            btn.innerHTML = `<div class="upgrade-icon">${upgrade.icon}</div><div>${upgrade.name}</div>`;
            btn.addEventListener('click', () => {
                upgrade.effect();
                modal.style.display = 'none';
                this.state = 'playing';
            });
            options.appendChild(btn);
        });
        
        modal.style.display = 'flex';
    }
    
    gameOver() {
        this.state = 'gameover';
        document.getElementById('hud').style.display = 'none';
        
        const minutes = Math.floor(this.gameTime / 60);
        const seconds = Math.floor(this.gameTime % 60);
        
        document.getElementById('finalStats').innerHTML = `
            <p>ÿßŸÑŸàŸÇÿ™: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}</p>
            <p>ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ: ${this.player.level}</p>
            <p>ÿßŸÑŸÇÿ™ŸÑŸâ: ${this.player.kills}</p>
            <p>ÿßŸÑÿ∞Ÿáÿ®: ${this.player.gold}</p>
        `;
        
        document.getElementById('gameOverScreen').style.display = 'flex';
    }
    
    updateHUD() {
        document.getElementById('healthBar').style.width = `${(this.player.health / this.player.maxHealth) * 100}%`;
        
        const xpRequired = Math.floor(CONFIG.BASE_XP_REQUIRED * Math.pow(CONFIG.XP_MULTIPLIER, this.player.level - 1));
        document.getElementById('xpBar').style.width = `${(this.player.xp / xpRequired) * 100}%`;
        
        document.getElementById('levelText').textContent = `ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ: ${this.player.level}`;
        document.getElementById('goldText').textContent = this.player.gold;
        document.getElementById('killText').textContent = this.player.kills;
        
        const minutes = Math.floor(this.gameTime / 60);
        const seconds = Math.floor(this.gameTime % 60);
        document.getElementById('timerText').textContent = `‚è±Ô∏è ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }
    
    draw() {
        const ctx = this.ctx;
        
        // Clear
        ctx.fillStyle = '#1a1510';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        if (this.state === 'menu') {
            // Menu background animation
            this.drawMenuBackground();
            return;
        }
        
        if (this.state === 'playing' || this.state === 'paused' || this.state === 'levelup' || this.state === 'gameover') {
            this.drawGame();
        }
    }
    
    drawMenuBackground() {
        const ctx = this.ctx;
        const time = Date.now() / 1000;
        
        // Animated sand dunes
        for (let i = 0; i < 5; i++) {
            const y = this.canvas.height * 0.4 + i * 80;
            ctx.fillStyle = `rgba(${60 + i * 10}, ${50 + i * 5}, ${30 + i * 3}, 0.5)`;
            ctx.beginPath();
            ctx.moveTo(0, y);
            for (let x = 0; x <= this.canvas.width; x += 50) {
                ctx.lineTo(x, y + Math.sin(x * 0.01 + time + i) * 20);
            }
            ctx.lineTo(this.canvas.width, this.canvas.height);
            ctx.lineTo(0, this.canvas.height);
            ctx.fill();
        }
        
        // Floating particles
        ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
        for (let i = 0; i < 50; i++) {
            const x = (Math.sin(time * 0.5 + i) * 0.5 + 0.5) * this.canvas.width;
            const y = (Math.cos(time * 0.3 + i * 2) * 0.5 + 0.5) * this.canvas.height;
            ctx.beginPath();
            ctx.arc(x, y, 2, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    drawGame() {
        const ctx = this.ctx;
        
        // Draw tiled background
        this.drawBackground();
        
        // Draw blood stains (persistent)
        this.particles.drawStains(ctx, this.camera);
        
        // Draw pickups
        for (const pickup of this.pickups) {
            pickup.draw(ctx, this.camera);
        }
        
        // Draw enemies
        for (const enemy of this.enemies) {
            enemy.draw(ctx, this.camera);
        }
        
        // Draw player
        this.player.draw(ctx, this.camera, this);
        
        // Draw projectiles
        for (const proj of this.projectiles) {
            proj.draw(ctx, this.camera);
        }
        
        // Draw particles
        this.particles.draw(ctx, this.camera);
        
        // Draw floating texts
        for (const text of this.floatingTexts) {
            text.draw(ctx, this.camera);
        }
        
        // Draw lighting
        this.drawLighting();
        
        // Draw virtual joystick indicator
        if (this.input.joystick) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.beginPath();
            ctx.arc(100, this.canvas.height - 100, 60, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'rgba(255, 215, 0, 0.5)';
            ctx.beginPath();
            ctx.arc(
                100 + this.input.joystick.x * 40,
                this.canvas.height - 100 + this.input.joystick.y * 40,
                25, 0, Math.PI * 2
            );
            ctx.fill();
        }
    }
    
    drawBackground() {
        const ctx = this.ctx;
        const tileSize = CONFIG.TILE_SIZE;
        
        // Calculate visible tile range
        const startX = Math.floor(this.camera.x / tileSize) - 1;
        const startY = Math.floor(this.camera.y / tileSize) - 1;
        const endX = Math.ceil((this.camera.x + this.canvas.width) / tileSize) + 1;
        const endY = Math.ceil((this.camera.y + this.canvas.height) / tileSize) + 1;
        
        // Draw sand tiles
        for (let y = startY; y <= endY; y++) {
            for (let x = startX; x <= endX; x++) {
                const screenX = x * tileSize - this.camera.x;
                const screenY = y * tileSize - this.camera.y;
                
                // Base sand color with variation
                const noise = Math.sin(x * 0.5) * Math.cos(y * 0.5) * 0.1;
                const r = Math.floor(210 + noise * 30);
                const g = Math.floor(180 + noise * 20);
                const b = Math.floor(140 + noise * 10);
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                ctx.fillRect(screenX, screenY, tileSize + 1, tileSize + 1);
                
                // Random props (rocks, bones)
                const seed = Math.abs(Math.sin(x * 12.9898 + y * 78.233) * 43758.5453) % 1;
                if (seed < 0.03) {
                    // Rock
                    ctx.fillStyle = '#5a5a5a';
                    ctx.beginPath();
                    ctx.arc(screenX + tileSize/2, screenY + tileSize/2, 8 + seed * 10, 0, Math.PI * 2);
                    ctx.fill();
                } else if (seed < 0.05) {
                    // Bone
                    ctx.fillStyle = '#d4c4a4';
                    ctx.fillRect(screenX + tileSize/3, screenY + tileSize/2, 20, 4);
                    ctx.beginPath();
                    ctx.arc(screenX + tileSize/3, screenY + tileSize/2 + 2, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
    }
    
    drawLighting() {
        const ctx = this.ctx;
        
        // Create darkness layer
        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Player light
        const playerScreenX = this.player.x - this.camera.x;
        const playerScreenY = this.player.y - this.camera.y;
        
        ctx.globalCompositeOperation = 'destination-out';
        
        const lightGradient = ctx.createRadialGradient(
            playerScreenX, playerScreenY, 0,
            playerScreenX, playerScreenY, CONFIG.PLAYER_LIGHT_RADIUS
        );
        lightGradient.addColorStop(0, 'rgba(0, 0, 0, 1)');
        lightGradient.addColorStop(0.5, 'rgba(0, 0, 0, 0.5)');
        lightGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        
        ctx.fillStyle = lightGradient;
        ctx.beginPath();
        ctx.arc(playerScreenX, playerScreenY, CONFIG.PLAYER_LIGHT_RADIUS, 0, Math.PI * 2);
        ctx.fill();
        
        // Projectile lights
        for (const proj of this.projectiles) {
            const px = proj.x - this.camera.x;
            const py = proj.y - this.camera.y;
            
            const projGradient = ctx.createRadialGradient(px, py, 0, px, py, 40);
            projGradient.addColorStop(0, 'rgba(0, 0, 0, 0.8)');
            projGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.fillStyle = projGradient;
            ctx.beginPath();
            ctx.arc(px, py, 40, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.globalCompositeOperation = 'source-over';
        
        // Add warm tint
        ctx.fillStyle = 'rgba(255, 200, 100, 0.05)';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }
}

// ==================== START GAME ====================
window.addEventListener('load', () => {
    new Game();
});
    </script>
</body>
</html>
