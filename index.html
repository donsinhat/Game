<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Ø°Ù‡Ø¨ Ø£ØµÙØ± Ø£Ùˆ Ø¯Ù… Ø£Ø­Ù…Ø± - Gold or Blood</title>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700;900&family=Changa:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
        body { background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0f0f1a 100%); font-family: 'Cairo', 'Changa', sans-serif; overflow: hidden; min-height: 100vh; color: #fff; }
        #gameCanvas { display: block; position: absolute; top: 0; left: 0; }
        
        .rarity-common { color: #9d9d9d; }
        .rarity-uncommon { color: #1eff00; }
        .rarity-rare { color: #0070dd; }
        .rarity-epic { color: #a335ee; }
        .rarity-legendary { color: #ff8000; }
        
        #mainMenu { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; background: linear-gradient(180deg, rgba(10,10,15,0.97) 0%, rgba(26,26,46,0.98) 100%); padding: 20px; }
        .menu-title { font-size: clamp(1.5rem, 5vw, 2.5rem); font-weight: 900; text-align: center; margin-bottom: 5px; background: linear-gradient(135deg, #ffd700 0%, #ff8c00 50%, #ffd700 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
        .menu-subtitle { font-size: clamp(0.8rem, 2.5vw, 1rem); color: #888; margin-bottom: 20px; }
        
        .character-select { display: flex; align-items: center; gap: 15px; margin-bottom: 25px; }
        .char-arrow { width: 50px; height: 50px; background: rgba(255, 215, 0, 0.1); border: 2px solid rgba(255, 215, 0, 0.3); border-radius: 50%; color: #ffd700; font-size: 1.5rem; cursor: pointer; transition: all 0.3s; display: flex; align-items: center; justify-content: center; }
        .char-arrow:hover { background: rgba(255, 215, 0, 0.2); border-color: #ffd700; transform: scale(1.1); }
        
        .character-display { width: 280px; padding: 20px; background: rgba(30, 30, 40, 0.9); border: 2px solid rgba(255, 215, 0, 0.3); border-radius: 20px; text-align: center; }
        .char-preview { width: 120px; height: 120px; margin: 0 auto 15px; image-rendering: pixelated; border-radius: 10px; background: rgba(0,0,0,0.3); }
        .char-name { font-size: 1.4rem; font-weight: 900; color: #ffd700; margin-bottom: 5px; }
        .char-title { font-size: 0.85rem; color: #888; margin-bottom: 10px; }
        .char-desc { font-size: 0.8rem; color: #aaa; margin-bottom: 12px; line-height: 1.4; min-height: 40px; }
        .char-stats { background: rgba(0,0,0,0.3); padding: 10px; border-radius: 10px; margin-bottom: 10px; }
        .char-stat { display: flex; justify-content: space-between; font-size: 0.8rem; margin: 4px 0; }
        .char-stat-label { color: #888; }
        .char-stat-value { color: #4f4; font-weight: bold; }
        .char-stat-negative { color: #f44; }
        .char-weapon { font-size: 0.85rem; color: #ff8888; padding: 8px; background: rgba(255,0,0,0.1); border-radius: 8px; }
        
        .city-select { display: flex; gap: 15px; margin-bottom: 25px; }
        .city-card { width: 160px; padding: 15px; background: rgba(30, 30, 40, 0.9); border: 2px solid rgba(100, 100, 100, 0.3); border-radius: 15px; cursor: pointer; transition: all 0.3s; text-align: center; }
        .city-card:hover:not(.locked), .city-card.selected { border-color: #ffd700; background: rgba(255, 215, 0, 0.1); transform: translateY(-5px); }
        .city-card.locked { opacity: 0.5; cursor: not-allowed; }
        .city-icon { font-size: 2.5rem; margin-bottom: 8px; }
        .city-name { font-size: 1rem; font-weight: bold; color: #ffd700; margin-bottom: 5px; }
        .city-desc { font-size: 0.7rem; color: #888; }
        .city-locked { font-size: 0.7rem; color: #f44; margin-top: 8px; }
        
        .btn { padding: 12px 40px; font-size: 1.1rem; font-family: 'Cairo', sans-serif; font-weight: 700; border: none; border-radius: 50px; cursor: pointer; transition: all 0.3s ease; }
        .btn-primary { background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%); color: #000; box-shadow: 0 8px 25px rgba(255, 215, 0, 0.4); }
        .btn-primary:hover { transform: scale(1.05); box-shadow: 0 12px 35px rgba(255, 215, 0, 0.5); }
        .high-score { margin-top: 15px; font-size: 0.8rem; color: #666; }
        
        #hud { position: fixed; top: 0; left: 0; width: 100%; padding: 10px 15px; display: none; justify-content: space-between; align-items: flex-start; z-index: 50; pointer-events: none; }
        .hud-left, .hud-right { display: flex; flex-direction: column; gap: 6px; }
        .hud-bar { width: 160px; height: 20px; background: rgba(0, 0, 0, 0.7); border-radius: 10px; overflow: hidden; border: 2px solid rgba(255, 255, 255, 0.2); position: relative; }
        .hud-bar-fill { height: 100%; transition: width 0.3s ease; border-radius: 10px; }
        .hud-bar-text { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 0.65rem; font-weight: bold; text-shadow: 1px 1px 2px #000; }
        .health-fill { background: linear-gradient(90deg, #ff4444 0%, #ff0000 100%); }
        .xp-fill { background: linear-gradient(90deg, #44ff44 0%, #00ff00 100%); }
        .hud-stat { font-size: 0.85rem; font-weight: 700; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8); }
        .gold-text { color: #ffd700; }
        .kill-text { color: #ff4444; }
        .level-text { color: #44ff44; }
        
        .equipment-slots { position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); display: none; gap: 8px; z-index: 50; pointer-events: none; }
        .slot-group { display: flex; gap: 4px; padding: 6px; background: rgba(0, 0, 0, 0.7); border-radius: 8px; }
        .equipment-slot { width: 38px; height: 38px; background: rgba(50, 50, 50, 0.8); border: 2px solid #444; border-radius: 6px; display: flex; align-items: center; justify-content: center; position: relative; font-size: 1.2rem; }
        .slot-level { position: absolute; bottom: -2px; right: -2px; background: #000; color: #fff; font-size: 0.55rem; padding: 1px 3px; border-radius: 3px; font-weight: bold; }
        
        #levelUpModal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); display: none; justify-content: center; align-items: center; z-index: 200; }
        .level-up-content { text-align: center; padding: 25px; background: rgba(20, 20, 30, 0.95); border: 3px solid #ffd700; border-radius: 20px; max-width: 95%; max-height: 85vh; overflow-y: auto; }
        .level-up-title { font-size: 1.6rem; color: #ffd700; margin-bottom: 20px; }
        .upgrade-options { display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; }
        .upgrade-card { width: 150px; padding: 12px; background: rgba(30, 30, 40, 0.9); border: 3px solid #444; border-radius: 12px; cursor: pointer; transition: all 0.3s ease; text-align: center; }
        .upgrade-card:hover { transform: scale(1.05); }
        .upgrade-icon { font-size: 2rem; margin-bottom: 8px; }
        .upgrade-name { font-size: 0.9rem; font-weight: bold; margin-bottom: 4px; }
        .upgrade-type { font-size: 0.7rem; color: #888; margin-bottom: 4px; }
        .upgrade-level { font-size: 0.75rem; margin-bottom: 4px; }
        .upgrade-desc { font-size: 0.65rem; color: #aaa; }
        .upgrade-rarity { font-size: 0.65rem; font-weight: bold; margin-top: 6px; padding: 2px 6px; border-radius: 8px; display: inline-block; }
        
        /* Item Pickup Modal */
        #itemPickupModal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); display: none; justify-content: center; align-items: center; z-index: 250; }
        .item-pickup-content { text-align: center; padding: 30px; background: rgba(20, 20, 30, 0.95); border: 3px solid #ffd700; border-radius: 20px; max-width: 320px; }
        .item-pickup-icon { font-size: 4rem; margin-bottom: 15px; }
        .item-pickup-name { font-size: 1.4rem; font-weight: bold; margin-bottom: 8px; }
        .item-pickup-rarity { font-size: 0.85rem; margin-bottom: 12px; padding: 4px 12px; border-radius: 10px; display: inline-block; }
        .item-pickup-desc { font-size: 0.95rem; color: #ccc; margin-bottom: 20px; line-height: 1.5; }
        .item-pickup-btn { padding: 10px 30px; font-size: 1rem; font-family: 'Cairo', sans-serif; font-weight: 700; border: none; border-radius: 25px; cursor: pointer; background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%); color: #000; }
        
        #gameOverScreen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.9); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 300; }
        .game-over-title { font-size: 2rem; color: #ff0000; margin-bottom: 15px; text-shadow: 0 0 20px rgba(255, 0, 0, 0.8); }
        .victory-title { color: #ffd700 !important; text-shadow: 0 0 20px rgba(255, 215, 0, 0.8) !important; }
        .final-stats { margin-bottom: 20px; font-size: 1rem; line-height: 1.6; }
        .unlock-message { color: #ffd700; font-size: 1.1rem; margin-bottom: 15px; padding: 10px 20px; background: rgba(255, 215, 0, 0.1); border-radius: 10px; }
        
        #bossWarning { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 2rem; color: #ff0000; text-shadow: 0 0 30px rgba(255, 0, 0, 0.8); display: none; z-index: 150; text-align: center; animation: bossWarn 0.5s ease-in-out infinite alternate; }
        @keyframes bossWarn { from { transform: translate(-50%, -50%) scale(1); } to { transform: translate(-50%, -50%) scale(1.1); } }
        
        #pauseIndicator { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 2rem; color: #ffd700; display: none; z-index: 150; }
        
        /* Pause Button */
        #pauseBtn { position: fixed; top: 10px; left: 50%; transform: translateX(-50%); width: 44px; height: 44px; background: rgba(0,0,0,0.6); border: 2px solid rgba(255,215,0,0.5); border-radius: 50%; color: #ffd700; font-size: 1.3rem; cursor: pointer; z-index: 60; display: none; transition: all 0.2s; }
        #pauseBtn:hover { background: rgba(255,215,0,0.2); border-color: #ffd700; }
        
        /* Pause Menu */
        #pauseMenu { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 200; }
        .pause-title { font-size: 2rem; color: #ffd700; margin-bottom: 30px; }
        .pause-controls { background: rgba(30,30,40,0.95); padding: 25px 35px; border-radius: 15px; border: 2px solid rgba(255,215,0,0.3); min-width: 280px; }
        .volume-control { margin: 15px 0; }
        .volume-label { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; font-size: 0.9rem; color: #ccc; }
        .volume-label span:last-child { color: #ffd700; font-weight: bold; }
        .volume-slider { width: 100%; height: 8px; -webkit-appearance: none; background: #333; border-radius: 4px; outline: none; }
        .volume-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; background: #ffd700; border-radius: 50%; cursor: pointer; }
        .volume-slider::-moz-range-thumb { width: 20px; height: 20px; background: #ffd700; border-radius: 50%; cursor: pointer; border: none; }
        .pause-buttons { display: flex; flex-direction: column; gap: 12px; margin-top: 25px; }
        .pause-btn { padding: 12px 25px; font-size: 1rem; font-family: 'Cairo', sans-serif; font-weight: 700; border: none; border-radius: 25px; cursor: pointer; transition: all 0.2s; }
        .pause-btn-resume { background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%); color: #000; }
        .pause-btn-resume:hover { transform: scale(1.05); }
        .pause-btn-quit { background: rgba(255,0,0,0.2); border: 2px solid #f44; color: #f44; }
        .pause-btn-quit:hover { background: rgba(255,0,0,0.3); }
        
        @media (max-width: 600px) {
            .character-display { width: 240px; padding: 15px; }
            .char-preview { width: 90px; height: 90px; }
            .city-card { width: 130px; padding: 12px; }
            .upgrade-card { width: 130px; padding: 10px; }
            .hud-bar { width: 130px; height: 18px; }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="mainMenu">
        <h1 class="menu-title">Ø°Ù‡Ø¨ Ø£ØµÙØ± Ø£Ùˆ Ø¯Ù… Ø£Ø­Ù…Ø±</h1>
        <p class="menu-subtitle">Ø§Ù‚ØªÙ„ Ø§Ø¨Ùˆ Ø­Ù„Ø²Ù‡ ÙÙŠ 10 Ø¯Ù‚Ø§Ø¦Ù‚!</p>
        <div class="character-select">
            <button class="char-arrow" id="charPrev">â†’</button>
            <div class="character-display">
                <canvas class="char-preview" id="charPreview" width="120" height="120"></canvas>
                <div class="char-name" id="charName">Ø£Ø¨Ùˆ Ø³Ù„ÙŠÙ…Ø§Ù†</div>
                <div class="char-title" id="charTitle">Ø§Ù„ØªØ§Ø¬Ø± Ø§Ù„Ø«Ø±ÙŠ</div>
                <div class="char-desc" id="charDesc">ØªØ§Ø¬Ø± Ø«Ø±ÙŠ ÙŠØ­Ø¨ Ø§Ù„Ø°Ù‡Ø¨</div>
                <div class="char-stats" id="charStats"></div>
                <div class="char-weapon" id="charWeapon">ğŸ—¡ï¸ Ø§Ù„Ø¹Ù‚Ø§Ù„</div>
            </div>
            <button class="char-arrow" id="charNext">â†</button>
        </div>
        <div class="city-select">
            <div class="city-card selected" id="cityBadaya" data-city="badaya">
                <div class="city-icon">ğŸœï¸</div>
                <div class="city-name">Ø§Ù„Ø¨Ø¯Ø§Ø¦Ø¹</div>
                <div class="city-desc">ØµØ­Ø±Ø§Ø¡ ÙˆÙ†Ø®ÙŠÙ„</div>
            </div>
            <div class="city-card locked" id="cityBaghdad" data-city="baghdad">
                <div class="city-icon">ğŸ›ï¸</div>
                <div class="city-name">Ø¨ØºØ¯Ø§Ø¯</div>
                <div class="city-desc">Ù…Ø¯ÙŠÙ†Ø© Ø­Ø¶Ø§Ø±ÙŠØ©</div>
                <div class="city-locked">ğŸ”’ Ø§Ù‚ØªÙ„ Ø§Ø¨Ùˆ Ø­Ù„Ø²Ù‡ Ø£ÙˆÙ„Ø§Ù‹</div>
            </div>
        </div>
        <button class="btn btn-primary" id="startBtn">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù„Ø¹Ø¨</button>
        <p class="high-score">Ø£Ø¹Ù„Ù‰ Ù†ØªÙŠØ¬Ø©: <span id="highScore">0</span> Ù‚ØªÙŠÙ„</p>
    </div>
    
    <div id="hud">
        <div class="hud-left">
            <div class="hud-bar"><div class="hud-bar-fill health-fill" id="healthBar" style="width: 100%"></div><span class="hud-bar-text" id="healthText">100/100</span></div>
            <div class="hud-bar"><div class="hud-bar-fill xp-fill" id="xpBar" style="width: 0%"></div><span class="hud-bar-text" id="xpText">0/10</span></div>
            <span class="hud-stat level-text" id="levelText">Ø§Ù„Ù…Ø³ØªÙˆÙ‰: 1</span>
        </div>
        <div class="hud-right">
            <span class="hud-stat gold-text">ğŸ’° <span id="goldText">0</span></span>
            <span class="hud-stat kill-text">ğŸ’€ <span id="killText">0</span></span>
            <span class="hud-stat" id="timerText">â±ï¸ 00:00</span>
        </div>
    </div>
    
    <div class="equipment-slots" id="equipmentSlots">
        <div class="slot-group" id="weaponSlots"></div>
        <div class="slot-group" id="bookSlots"></div>
    </div>
    
    <div id="levelUpModal">
        <div class="level-up-content">
            <h2 class="level-up-title">ğŸ‰ Ù…Ø³ØªÙˆÙ‰ Ø¬Ø¯ÙŠØ¯! ğŸ‰</h2>
            <div class="upgrade-options" id="upgradeOptions"></div>
        </div>
    </div>
    
    <div id="itemPickupModal">
        <div class="item-pickup-content">
            <div class="item-pickup-icon" id="itemIcon">â­</div>
            <div class="item-pickup-name" id="itemName">Ø§Ø³Ù… Ø§Ù„Ø£ÙŠØªÙ…</div>
            <div class="item-pickup-rarity" id="itemRarity">Ø£Ø³Ø·ÙˆØ±ÙŠ</div>
            <div class="item-pickup-desc" id="itemDesc">ÙˆØµÙ Ø§Ù„Ø£ÙŠØªÙ…</div>
            <button class="item-pickup-btn" id="itemContinueBtn">Ø§Ø³ØªÙ…Ø±Ø§Ø±</button>
        </div>
    </div>
    
    <div id="gameOverScreen">
        <h1 class="game-over-title" id="gameOverTitle">Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©</h1>
        <div class="unlock-message" id="unlockMessage" style="display: none;"></div>
        <div class="final-stats" id="finalStats"></div>
        <button class="btn btn-primary" id="restartBtn">Ø§Ù„Ø¹Ø¨ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰</button>
    </div>
    
    <div id="bossWarning">âš ï¸ ØªØ­Ø°ÙŠØ±! âš ï¸<br><span style="font-size: 1.2rem;">Ø§Ø¨Ùˆ Ø­Ù„Ø²Ù‡ Ù‚Ø§Ø¯Ù…!</span></div>
    <div id="pauseIndicator">â¸ï¸ Ø¥ÙŠÙ‚Ø§Ù Ù…Ø¤Ù‚Øª</div>
    
    <button id="pauseBtn">â¸ï¸</button>
    
    <div id="pauseMenu">
        <h1 class="pause-title">â¸ï¸ Ø¥ÙŠÙ‚Ø§Ù Ù…Ø¤Ù‚Øª</h1>
        <div class="pause-controls">
            <div class="volume-control">
                <div class="volume-label">
                    <span>ğŸµ ØµÙˆØª Ø§Ù„Ù…ÙˆØ³ÙŠÙ‚Ù‰</span>
                    <span id="musicVolText">50%</span>
                </div>
                <input type="range" class="volume-slider" id="musicVolume" min="0" max="100" value="50">
            </div>
            <div class="volume-control">
                <div class="volume-label">
                    <span>ğŸ”Š ØµÙˆØª Ø§Ù„Ù…Ø¤Ø«Ø±Ø§Øª</span>
                    <span id="sfxVolText">70%</span>
                </div>
                <input type="range" class="volume-slider" id="sfxVolume" min="0" max="100" value="70">
            </div>
            <div class="pause-buttons">
                <button class="pause-btn pause-btn-resume" id="resumeBtn">â–¶ï¸ Ø§Ø³ØªÙ…Ø±Ø§Ø±</button>
                <button class="pause-btn pause-btn-quit" id="quitBtn">ğŸšª Ø®Ø±ÙˆØ¬ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø©</button>
            </div>
        </div>
    </div>

    <script>
// ==================== GAME CONFIG ====================
const CONFIG = {
    WORLD_SIZE: 4000,
    TILE_SIZE: 64,
    PLAYER_LIGHT_RADIUS: 300,
    MAX_WEAPONS: 4,
    MAX_BOOKS: 4,
    MAX_UPGRADE_LEVEL: 20,
    BOSS_TIME: 600, // 10 minutes
    
    // Enemy base stats
    ENEMY_BASE_HP: 8,
    ENEMY_BASE_ATK: 5,
    ENEMY_BASE_SPEED: 55,
    
    // Scaling +20% per minute
    SCALING_PER_MIN: 0.20,
    
    // Weapon base damage
    WEAPON_BASE_DMG: 5
};

// ==================== RARITY ====================
const RARITY = {
    COMMON: { name: 'Ø´Ø§Ø¦Ø¹', color: '#9d9d9d', bonus: 1, weight: 50 },
    UNCOMMON: { name: 'ØºÙŠØ± Ø´Ø§Ø¦Ø¹', color: '#1eff00', bonus: 2, weight: 25 },
    RARE: { name: 'Ù†Ø§Ø¯Ø±', color: '#0070dd', bonus: 3, weight: 13 },
    EPIC: { name: 'Ù…Ù„Ø­Ù…ÙŠ', color: '#a335ee', bonus: 4, weight: 7 },
    LEGENDARY: { name: 'Ø£Ø³Ø·ÙˆØ±ÙŠ', color: '#ff8000', bonus: 5, weight: 5 }
};

function getRandomRarity() {
    const total = Object.values(RARITY).reduce((s, r) => s + r.weight, 0);
    let r = Math.random() * total;
    for (const rar of Object.values(RARITY)) { r -= rar.weight; if (r <= 0) return rar; }
    return RARITY.COMMON;
}

// ==================== CHARACTERS ====================
const CHARACTERS = {
    abuSulaiman: {
        name: 'Ø£Ø¨Ùˆ Ø³Ù„ÙŠÙ…Ø§Ù†', title: 'Ø§Ù„ØªØ§Ø¬Ø± Ø§Ù„Ø«Ø±ÙŠ',
        desc: 'Ø§ÙˆÙ„Ø§Ùˆ ÙŠØ­Ø¨ Ø§Ù„Ø¯Ø±Ø§Ù‡Ù…',
        weapon: 'agal',
        stats: { gold: 1.25, luck: 1.1, hp: 100, speed: 200, crit: 0, enemyBuff: 0 },
        passiveText: ['+25% Ø°Ù‡Ø¨', '+10% Ø­Ø¸'],
        colors: { body: '#f5f5f5', head: '#cc0000', skin: '#d4a574', legs: '#2a2a2a' }
    },
    jayzen: {
        name: 'Ø¬ÙŠØ²Ù†', title: 'Ø§Ù„Ù…Ù‚Ø§ØªÙ„ Ø§Ù„Ø´Ø±Ø³',
        desc: 'Ù„Ø­Ø¬ÙŠ Ø¨Ø³ Ù…ØªØ¹Ø§ÙÙŠ',
        weapon: 'rock',
        stats: { gold: 1, luck: 1, hp: 115, speed: 200, dmgReduce: 0.3, crit: 0, enemyBuff: 0 },
        passiveText: ['-30% Ø¶Ø±Ø± Ù…Ø³ØªÙ„Ù…', '+15% ØµØ­Ø©'],
        colors: { body: '#6a1b9a', head: '#cc3333', skin: '#d4a574', legs: '#333' }
    },
    noura: {
        name: 'Ù†ÙˆØ±Ø©', title: 'Ø§Ù„Ù…Ø±Ø£Ø© Ø§Ù„Ù‚ÙˆÙŠØ©',
        desc: 'Ø³ØªØ±ÙˆÙ†Ù‚ Ø§Ù†Ø¯Ø¨Ù†Ø¯Øª ÙˆÙ…Ù†',
        weapon: 'aura',
        stats: { gold: 1, luck: 1, hp: 100, speed: 200, pickup: 2.5, xpMult: 1.2, crit: 0, enemyBuff: 0 },
        passiveText: ['+150% Ù…ØºÙ†Ø§Ø·ÙŠØ³', '+20% Ø®Ø¨Ø±Ø©'],
        colors: { body: '#1e88e5', head: '#f5f5f5', skin: '#e8d5c4', legs: '#1565c0' }
    },
    bedouin: {
        name: 'Ø§Ù„Ø§Ø¹Ø±Ø§Ø¨ÙŠ', title: 'Ø¨Ø¯ÙˆÙŠ ØºØ¯Ø§Ø±',
        desc: 'Ø¨Ø¯ÙˆÙŠ ÙˆØºØ¯Ø§Ø±ØŒ Ø§Ù„Ù„Ù‡ ÙŠØ±Ø­Ù… Ù…Ù† Ø·Ù„Ø¹Ù‡Ù… Ù…Ù† Ø®ÙŠØ§Ù…Ù‡Ù…',
        weapon: 'spear',
        stats: { gold: 1, luck: 1, hp: 90, speed: 220, crit: 0.20, enemyBuff: 0 },
        passiveText: ['+20% Ø¶Ø±Ø¨Ø© Ø­Ø±Ø¬Ø©', '+10% Ø³Ø±Ø¹Ø©'],
        colors: { body: '#8b4513', head: '#d2691e', skin: '#c4956a', legs: '#2f1810' }
    },
    hawshabi: {
        name: 'Ø§Ù„Ø­ÙˆØ´Ø¨ÙŠ', title: 'ØµØ¹ÙˆØ¨Ø© Ù…ØªÙ‚Ø¯Ù…Ø©',
        desc: 'Ø§Ø°Ø§ ØªØ¨ÙŠ ØªØµØ¹Ø¨ Ø§Ù„ÙˆØ¶Ø¹ Ø¹Ù„ÙŠÙƒ Ø§Ù„Ø¹Ø¨ ÙÙŠÙ‡ ÙˆØ§Ø­ØªØ³Ø¨ Ø§Ù„Ø§Ø¬Ø±',
        weapon: 'sword',
        stats: { gold: 1.5, luck: 1.2, hp: 80, speed: 180, crit: 0, enemyBuff: 0.20 },
        passiveText: ['+20% Ù‚ÙˆØ© Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡', '+50% Ø°Ù‡Ø¨', '+20% Ø­Ø¸'],
        colors: { body: '#4a0000', head: '#1a1a1a', skin: '#d4a574', legs: '#222' }
    },
    layla: {
        name: 'Ù„ÙŠÙ„Ù‰', title: 'Ø§Ù„Ø³Ø§Ø­Ø±Ø©',
        desc: 'Ø³Ø§Ø­Ø±Ø© ØºØ§Ù…Ø¶Ø© ØªØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù†Ø§Ø± Ø§Ù„Ø²Ø±Ù‚Ø§Ø¡',
        weapon: 'flame',
        stats: { gold: 1, luck: 1, hp: 85, speed: 210, cooldown: 0.8, range: 1.3, crit: 0, enemyBuff: 0 },
        passiveText: ['-20% ÙƒÙˆÙ„Ø¯Ø§ÙˆÙ†', '+30% Ù…Ø¯Ù‰'],
        colors: { body: '#1a1a2e', head: '#4a0080', skin: '#e8d5c4', legs: '#0a0a15' }
    }
};

// ==================== WEAPONS ====================
const WEAPONS = {
    agal: { name: 'Ø§Ù„Ø¹Ù‚Ø§Ù„', desc: 'Ø­Ø¨Ù„ ÙŠØ¯ÙˆØ± Ø­ÙˆÙ„Ùƒ ÙˆÙŠØ¶Ø±Ø¨ Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡', type: 'orbit', dmg: 5, cd: 0.1, range: 65, icon: 'â­•' },
    rock: { name: 'Ø§Ù„ØµØ®Ø±Ø©', desc: 'Ù‚Ø°ÙŠÙØ© ØªØ³ØªÙ‡Ø¯Ù Ø£Ù‚Ø±Ø¨ Ø¹Ø¯Ùˆ', type: 'projectile', dmg: 5, cd: 0.9, range: 380, icon: 'ğŸª¨' },
    aura: { name: 'Ø§Ù„Ù‡ÙŠØ¨Ø©', desc: 'Ù‡Ø§Ù„Ø© Ø¶Ø±Ø± Ø®ÙÙŠÙØ© Ø­ÙˆÙ„Ùƒ', type: 'aura', dmg: 4, cd: 0.5, range: 55, icon: 'ğŸ’«' },
    spear: { name: 'Ø§Ù„Ø±Ù…Ø­', desc: 'ÙŠØ±Ù…ÙŠ Ø±Ù…Ø­ Ù„Ø£Ù‚Ø±Ø¨ Ø¹Ø¯Ùˆ', type: 'projectile', dmg: 5, cd: 0.45, range: 340, icon: 'ğŸ”±' },
    sword: { name: 'Ø§Ù„Ø³ÙŠÙ', desc: 'Ø¶Ø±Ø¨Ø© Ù‚ÙˆØ³ÙŠØ© Ø£Ù…Ø§Ù…Ùƒ', type: 'melee', dmg: 5, cd: 0.65, range: 75, icon: 'âš”ï¸' },
    flame: { name: 'Ø§Ù„Ø´Ø¹Ù„Ø©', desc: 'ÙƒØ±Ø§Øª Ù†Ø§Ø±ÙŠØ© Ù„Ø£Ù‚Ø±Ø¨ Ø¹Ø¯Ùˆ', type: 'projectile', dmg: 5, cd: 0.3, range: 280, icon: 'ğŸ”¥' },
    arrows: { name: 'Ø§Ù„Ø³Ù‡Ø§Ù…', desc: 'Ø³Ù‡Ø§Ù… ØªØ·Ù„Ù‚ Ø¨ÙƒÙ„ Ø§Ù„Ø§ØªØ¬Ø§Ù‡Ø§Øª', type: 'radial', dmg: 4, cd: 0.85, range: 320, icon: 'ğŸ¹' },
    lightning: { name: 'Ø§Ù„Ø¨Ø±Ù‚', desc: 'ØµØ§Ø¹Ù‚Ø© Ø¹Ù„Ù‰ Ø¹Ø¯Ùˆ Ø¹Ø´ÙˆØ§Ø¦ÙŠ', type: 'lightning', dmg: 5, cd: 1.8, range: 420, icon: 'âš¡' },
    tornado: { name: 'Ø§Ù„Ø¯ÙˆØ§Ù…Ø©', desc: 'Ø¥Ø¹ØµØ§Ø± ÙŠØ¨Ø·Ø¦ Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡', type: 'tornado', dmg: 4, cd: 2.2, range: 160, icon: 'ğŸŒªï¸' },
    meteor: { name: 'Ø§Ù„Ù†ÙŠØ²Ùƒ', desc: 'ØµØ®ÙˆØ± ØªØ³Ù‚Ø· Ù…Ù† Ø§Ù„Ø³Ù…Ø§Ø¡', type: 'meteor', dmg: 5, cd: 1.6, range: 90, icon: 'â˜„ï¸' }
};

// ==================== BOOKS ====================
const BOOKS = {
    power: { name: 'ÙƒØªØ§Ø¨ Ø§Ù„Ù‚ÙˆØ©', desc: 'ÙŠØ²ÙŠØ¯ Ù‚ÙˆØ© Ø§Ù„Ù‡Ø¬ÙˆÙ…', stat: 'damage', val: 0.08, icon: 'ğŸ“•' },
    speed: { name: 'ÙƒØªØ§Ø¨ Ø§Ù„Ø³Ø±Ø¹Ø©', desc: 'ÙŠØ²ÙŠØ¯ Ø³Ø±Ø¹Ø© Ø§Ù„Ù‡Ø¬ÙˆÙ…', stat: 'atkSpd', val: 0.06, icon: 'ğŸ“—' },
    wind: { name: 'ÙƒØªØ§Ø¨ Ø§Ù„Ø±ÙŠØ­', desc: 'ÙŠØ²ÙŠØ¯ Ø³Ø±Ø¹Ø© Ø§Ù„Ø­Ø±ÙƒØ©', stat: 'moveSpd', val: 0.05, icon: 'ğŸ“˜' },
    wisdom: { name: 'ÙƒØªØ§Ø¨ Ø§Ù„Ø­ÙƒÙ…Ø©', desc: 'ÙŠØ²ÙŠØ¯ Ø§Ù„Ø®Ø¨Ø±Ø© Ø§Ù„Ù…ÙƒØªØ³Ø¨Ø©', stat: 'xp', val: 0.10, icon: 'ğŸ“™' },
    life: { name: 'ÙƒØªØ§Ø¨ Ø§Ù„Ø­ÙŠØ§Ø©', desc: 'ÙŠØ²ÙŠØ¯ Ø§Ù„ØµØ­Ø© Ø§Ù„Ù‚ØµÙˆÙ‰', stat: 'maxHp', val: 0.08, icon: 'ğŸ““' },
    armor: { name: 'ÙƒØªØ§Ø¨ Ø§Ù„Ø¯Ø±Ø¹', desc: 'ÙŠÙ‚Ù„Ù„ Ø§Ù„Ø¶Ø±Ø± Ø§Ù„Ù…Ø³ØªÙ„Ù…', stat: 'armor', val: 0.04, icon: 'ğŸ“”' },
    magnet: { name: 'ÙƒØªØ§Ø¨ Ø§Ù„Ù…ØºÙ†Ø§Ø·ÙŠØ³', desc: 'ÙŠØ²ÙŠØ¯ Ù…Ø¯Ù‰ Ø¬Ù…Ø¹ Ø§Ù„Ø£ÙŠØªÙ…Ø§Øª', stat: 'pickup', val: 0.12, icon: 'ğŸ“’' },
    luck: { name: 'ÙƒØªØ§Ø¨ Ø§Ù„Ø­Ø¸', desc: 'ÙŠØ²ÙŠØ¯ Ø­Ø¸ Ø¯Ø±ÙˆØ¨ Ø§Ù„Ø£ÙŠØªÙ…Ø§Øª', stat: 'luck', val: 0.06, icon: 'ğŸ“š' },
    curse: { name: 'ÙƒØªØ§Ø¨ Ø§Ù„Ù„Ø¹Ù†Ø©', desc: 'Ø£Ø¹Ø¯Ø§Ø¡ Ø£ÙƒØ«Ø±ØŒ Ø®Ø¨Ø±Ø© Ø£ÙƒØ«Ø±', stat: 'curse', val: 0.15, icon: 'ğŸ“–' },
    regen: { name: 'ÙƒØªØ§Ø¨ Ø§Ù„ØªØ¬Ø¯ÙŠØ¯', desc: 'Ø´ÙØ§Ø¡ Ù…Ø³ØªÙ…Ø± ÙƒÙ„ Ø«Ø§Ù†ÙŠØ©', stat: 'regen', val: 0.8, icon: 'ğŸ“œ' }
};

// ==================== ITEMS ====================
const ITEMS = {
    // Common (Ø´Ø§Ø¦Ø¹)
    mirinda: { name: 'Ø­Ù…Ø¶ÙŠØ§Øª', desc: 'Ø­Ø§Ø± ÙŠÙ„Ø¯ .. ÙŠÙ†Ø¹Ù†Ø´ ÙˆÙŠØ±Ø¬Ø¹ Ù„Ùƒ 10 Ù‡ÙŠÙ„', rarity: 'COMMON', effect: 'heal', val: 10, icon: 'ğŸŠ', sprite: 'item_mirinda' },
    dalla: { name: 'Ø¯Ù„Ù‡ Ù‚Ù‡ÙˆÙ‡', desc: 'Ø§Ù„Ù…Ù‡ÙŠÙ„Ù‡ ØªØ®Ù„ÙŠÙƒ Ù†Ø´ÙŠØ· ÙˆØ§Ø³Ø±Ø¹ 10 Ø«ÙˆØ§Ù†ÙŠ', rarity: 'COMMON', effect: 'tempSpeed', val: 0.15, dur: 10, icon: 'â˜•', sprite: 'item_dalla' },
    pebble: { name: 'Ø­Ø¨ Ø´Ù…Ø³ÙŠ', desc: '+10% Ø¶Ø±Ø± Ù„Ù…Ø¯Ø© 12 Ø«Ø§Ù†ÙŠØ©', rarity: 'COMMON', effect: 'tempDmg', val: 0.1, dur: 12, icon: 'ğŸŒ»', sprite: 'item_pebble' },
    klega: { name: 'ÙƒÙ„ÙŠØ¬Ù‡', desc: 'Ø§ÙˆÙ„Ø§Ùˆ Ù…Ù† Ø­Ù„Ø§ØªÙ‡ ØªÙ‡ÙŠÙ„Ùƒ 5', rarity: 'COMMON', effect: 'heal', val: 5, icon: 'ğŸª', sprite: 'item_klega' },
    copper: { name: 'Ù†Ø­Ø§Ø³', desc: '+5 Ø°Ù‡Ø¨', rarity: 'COMMON', effect: 'gold', val: 5, icon: 'ğŸª™' },
    
    // Rare (Ù†Ø§Ø¯Ø±)
    redPotion: { name: 'Ø¬Ø±Ø¹Ø© Ø­Ù…Ø±Ø§Ø¡', desc: 'ÙŠØ³ØªØ¹ÙŠØ¯ 30 ØµØ­Ø©', rarity: 'RARE', effect: 'heal', val: 30, icon: 'ğŸ§ª' },
    bluePotion: { name: 'Ø¬Ø±Ø¹Ø© Ø²Ø±Ù‚Ø§Ø¡', desc: '+30% Ø³Ø±Ø¹Ø© Ù‡Ø¬ÙˆÙ… Ù„Ù…Ø¯Ø© 15 Ø«Ø§Ù†ÙŠØ©', rarity: 'RARE', effect: 'tempAtkSpd', val: 0.3, dur: 15, icon: 'ğŸ§´' },
    amulet: { name: 'ØªÙ…ÙŠÙ…Ø©', desc: 'Ø¯Ø±Ø¹ ÙŠÙ…ØªØµ 20 Ø¶Ø±Ø±', rarity: 'RARE', effect: 'shield', val: 20, icon: 'ğŸ“¿' },
    hourglass: { name: 'Ø³Ø§Ø¹Ø© Ø±Ù…Ù„ÙŠØ©', desc: 'ÙŠØ¨Ø·Ø¦ Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡ 50% Ù„Ù…Ø¯Ø© 5 Ø«ÙˆØ§Ù†ÙŠ', rarity: 'RARE', effect: 'slow', val: 0.5, dur: 5, icon: 'â³' },
    silver: { name: 'ÙØ¶Ø©', desc: '+25 Ø°Ù‡Ø¨', rarity: 'RARE', effect: 'gold', val: 25, icon: 'ğŸ¥ˆ' },
    
    // Legendary (Ø£Ø³Ø·ÙˆØ±ÙŠ)
    elixir: { name: 'Ø¥ÙƒØ³ÙŠØ±', desc: 'ÙŠØ³ØªØ¹ÙŠØ¯ ÙƒÙ„ Ø§Ù„ØµØ­Ø© ÙˆÙŠØ²ÙŠØ¯ Ø§Ù„ØµØ­Ø© Ø§Ù„Ù‚ØµÙˆÙ‰ 20', rarity: 'LEGENDARY', effect: 'fullHeal', val: 20, icon: 'âš—ï¸' },
    dragonHeart: { name: 'Ù‚Ù„Ø¨ Ø§Ù„ØªÙ†ÙŠÙ†', desc: '+50% Ø¶Ø±Ø± Ù„Ù…Ø¯Ø© 25 Ø«Ø§Ù†ÙŠØ©', rarity: 'LEGENDARY', effect: 'tempDmg', val: 0.5, dur: 25, icon: 'â¤ï¸â€ğŸ”¥' },
    arika: { name: 'Ø¹Ø±ÙŠÙƒÙ‡', desc: 'Ø¥Ø°Ø§ Ù…ØªØŒ ØªØ¹ÙˆØ¯ Ù„Ù„Ø­ÙŠØ§Ø© Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø©', rarity: 'LEGENDARY', effect: 'revive', val: 1, icon: 'ğŸš', sprite: 'item_arika' },
    crown: { name: 'ØªØ§Ø¬ Ø°Ù‡Ø¨ÙŠ', desc: '+50% Ø°Ù‡Ø¨ Ø¨Ø´ÙƒÙ„ Ø¯Ø§Ø¦Ù…', rarity: 'LEGENDARY', effect: 'permGold', val: 0.5, icon: 'ğŸ‘‘' },
    star: { name: 'Ù†Ø¬Ù…Ø© Ø§Ù„ØµØ­Ø±Ø§Ø¡', desc: 'ØªØ­ØµÙ„ Ø¹Ù„Ù‰ Ø³Ù„Ø§Ø­ Ø£Ùˆ ÙƒØªØ§Ø¨ Ø¹Ø´ÙˆØ§Ø¦ÙŠ', rarity: 'LEGENDARY', effect: 'randomEquip', val: 1, icon: 'â­' },
    khazouq: { name: 'Ø®Ø§Ø²ÙˆÙ‚', desc: 'ÙŠØ²ÙŠØ¯ Ù†Ø³Ø¨Ø© Ø¸Ù‡ÙˆØ± Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡ 10%ØŒ Ø£Ù†Øª ØºØ¨ÙŠ Ù„ÙŠØ´ Ø£Ø®Ø°ØªÙ‡ØŸ', rarity: 'LEGENDARY', effect: 'moreEnemies', val: 0.10, icon: 'ğŸ†' }
};

// ==================== ENEMIES ====================
const ENEMIES = {
    wolf: { name: 'Ø°Ø¦Ø¨', hpM: 1, atkM: 1, spdM: 1.2, xp: 2, time: 0, color: '#6a6a6a' },
    scorpion: { name: 'Ø¹Ù‚Ø±Ø¨', hpM: 0.7, atkM: 0.8, spdM: 1.5, xp: 2, time: 0, color: '#ffa500' },
    dhub: { name: 'Ø¶Ø¨', hpM: 2, atkM: 1.2, spdM: 0.6, xp: 4, time: 60, color: '#5a8a5a', zig: true },
    snake: { name: 'Ø«Ø¹Ø¨Ø§Ù†', hpM: 1.2, atkM: 1, spdM: 1, xp: 3, time: 120, color: '#2d5a27', ranged: true },
    hyena: { name: 'Ø¶Ø¨Ø¹', hpM: 0.8, atkM: 0.9, spdM: 1.3, xp: 2, time: 180, color: '#8b7355', pack: true },
    eagle: { name: 'Ù†Ø³Ø±', hpM: 1, atkM: 1.3, spdM: 1.6, xp: 4, time: 240, color: '#4a3728' },
    lion: { name: 'Ø£Ø³Ø¯', hpM: 3, atkM: 2, spdM: 0.8, xp: 8, time: 300, color: '#c4a35a' },
    djinn: { name: 'Ø¬Ù†ÙŠ', hpM: 1.5, atkM: 1.5, spdM: 1.4, xp: 6, time: 360, color: '#4a0080', tp: true },
    ghoul: { name: 'ØºÙˆÙ„', hpM: 5, atkM: 2.5, spdM: 0.5, xp: 12, time: 420, color: '#2a2a2a' },
    knight: { name: 'ÙØ§Ø±Ø³', hpM: 2.5, atkM: 1.8, spdM: 1, xp: 10, time: 480, color: '#1a1a1a' }
};

const BOSS = { name: 'Ø§Ø¨Ùˆ Ø­Ù„Ø²Ù‡', hp: 8000, atk: 35, spd: 55, color: '#8b0000' };

// ==================== ASSET LOADER ====================
class AssetLoader {
    constructor() {
        this.images = {};
        this.loaded = false;
    }
    
    loadImage(name, src) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => { this.images[name] = img; resolve(img); };
            img.onerror = reject;
            img.src = src;
        });
    }
    
    async loadAll() {
        const assets = [
            // Characters
            ['char_001', 'assets/characters/Char_001.png'],
            ['char_001_idle', 'assets/characters/Char_001_Idle.png'],
            ['char_002', 'assets/characters/Char_002.png'],
            ['char_002_idle', 'assets/characters/Char_002_Idle.png'],
            ['char_003', 'assets/characters/Char_003.png'],
            ['char_003_idle', 'assets/characters/Char_003_Idle.png'],
            ['char_004', 'assets/characters/Char_004.png'],
            ['char_004_idle', 'assets/characters/Char_004_Idle.png'],
            ['char_005', 'assets/characters/Char_005.png'],
            ['char_005_idle', 'assets/characters/Char_005_Idle.png'],
            ['char_006', 'assets/characters/Char_006.png'],
            ['char_006_idle', 'assets/characters/Char_006_Idle.png'],
            
            // Enemies - New monster sprites
            ['enemy_wolf', 'assets/enemies/NB_01.png'],
            ['enemy_scorpion', 'assets/enemies/NB_09.png'],
            ['enemy_dhub', 'assets/enemies/NB_03.png'],
            ['enemy_snake', 'assets/enemies/NB_06.png'],
            ['enemy_hyena', 'assets/enemies/NB_02.png'],
            ['enemy_eagle', 'assets/enemies/NB_29.png'],
            ['enemy_lion', 'assets/enemies/NB_26.png'],
            ['enemy_djinn', 'assets/enemies/NB_05.png'],
            ['enemy_ghoul', 'assets/enemies/NB_08.png'],
            ['enemy_knight', 'assets/enemies/NB_16.png'],
            
            // Pickups
            ['gold_coin', 'assets/pickups/gold_coin.png'],
            ['xp_gem', 'assets/pickups/xp_gem.png'],
            
            // Item Icons
            ['item_mirinda', 'assets/New Items Icon/mirinda.png'],
            ['item_dalla', 'assets/New Items Icon/dalla.png'],
            ['item_klega', 'assets/New Items Icon/klega.png'],
            ['item_arika', 'assets/New Items Icon/arika.png'],
            ['item_pebble', 'assets/New Items Icon/pebble.png'],
            
            // Desert Map
            ['desert_tiles', 'assets/New Maps/DesertTileset16x16/Tileset16x16/DesertTilemap16x16.png'],
            
            // Forest Map (Baghdad)
            ['forest_tiles', 'assets/New Maps/gentle sheets/gentle forest v01.png'],
            
            // Buildings
            ['building_house', 'assets/Yellow Buildings/House1.png'],
            
            // Backgrounds
            ['sand_tile', 'assets/backgrounds/sand_tile.png'],
            ['tiles', 'assets/tiles-all-32x32.png'],
            
            // Effects
            ['fx_spark', 'assets/01.png'],
            ['fx_fire_small', 'assets/02.png'],
            ['fx_explosion', 'assets/03.png'],
            ['fx_fireball', 'assets/04.png'],
            ['fx_flames', 'assets/05.png'],
            ['fx_ice', 'assets/10.png'],
            ['fx_magic', 'assets/15.png'],
            ['fx_heal', 'assets/20.png'],
            ['fx_dust', 'assets/25.png'],
            ['fx_circle', 'assets/30.png'],
            ['fx_water', 'assets/35.png']
        ];
        
        try {
            await Promise.all(assets.map(([name, src]) => this.loadImage(name, src)));
            this.loaded = true;
            console.log('All assets loaded!');
        } catch (e) {
            console.warn('Some assets failed to load, using fallback rendering');
            this.loaded = false;
        }
    }
    
    get(name) {
        return this.images[name];
    }
}

// Character sprite mappings
const CHAR_SPRITES = {
    abuSulaiman: { sprite: 'char_003', idle: 'char_003_idle', frameWidth: 48, frameHeight: 48, frames: 4 },
    jayzen: { sprite: 'char_006', idle: 'char_006_idle', frameWidth: 48, frameHeight: 48, frames: 4 },
    noura: { sprite: 'char_005', idle: 'char_005_idle', frameWidth: 48, frameHeight: 48, frames: 4 },
    bedouin: { sprite: 'char_002', idle: 'char_002_idle', frameWidth: 48, frameHeight: 48, frames: 4 },
    hawshabi: { sprite: 'char_004', idle: 'char_004_idle', frameWidth: 48, frameHeight: 48, frames: 4 },
    layla: { sprite: 'char_001', idle: 'char_001_idle', frameWidth: 48, frameHeight: 48, frames: 4 }
};

// Enemy sprite mappings - using new monster sprites
const ENEMY_SPRITES = {
    wolf: { sprite: 'enemy_wolf', width: 80, height: 80 },
    scorpion: { sprite: 'enemy_scorpion', width: 80, height: 80 },
    dhub: { sprite: 'enemy_dhub', width: 80, height: 80 },
    snake: { sprite: 'enemy_snake', width: 80, height: 80 },
    hyena: { sprite: 'enemy_hyena', width: 80, height: 80 },
    eagle: { sprite: 'enemy_eagle', width: 80, height: 80 },
    lion: { sprite: 'enemy_lion', width: 80, height: 80 },
    djinn: { sprite: 'enemy_djinn', width: 80, height: 80 },
    ghoul: { sprite: 'enemy_ghoul', width: 80, height: 80 },
    knight: { sprite: 'enemy_knight', width: 80, height: 80 }
};

// ==================== AUDIO ====================
class Audio {
    constructor() { 
        this.ctx = null; 
        this.bgm = null;
        this.bgmPlaying = false;
        this.musicVolume = 0.5;
        this.sfxVolume = 0.7;
    }
    
    init() { 
        if (!this.ctx) {
            try { 
                this.ctx = new (window.AudioContext || window.webkitAudioContext)(); 
            } catch(e) {} 
        }
        
        // Load background music
        if (!this.bgm) {
            this.bgm = new window.Audio('assets/8-bit Desert Tune [7CaoOAgagxM].mp3');
            this.bgm.loop = true;
            this.bgm.volume = this.musicVolume;
        }
    }
    
    setMusicVolume(vol) {
        this.musicVolume = vol;
        if (this.bgm) this.bgm.volume = vol;
    }
    
    setSfxVolume(vol) {
        this.sfxVolume = vol;
    }
    
    tone(f, d, t='square', v=0.12) {
        if (!this.ctx) return;
        const actualVol = v * this.sfxVolume;
        if (actualVol < 0.01) return;
        
        const o = this.ctx.createOscillator(), g = this.ctx.createGain();
        o.type = t; o.frequency.value = f; o.connect(g); g.connect(this.ctx.destination);
        g.gain.setValueAtTime(actualVol, this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + d);
        o.start(); o.stop(this.ctx.currentTime + d);
    }
    
    startBGM() {
        if (this.bgmPlaying || !this.bgm) return;
        this.bgm.currentTime = 0;
        this.bgm.play().catch(e => console.log('BGM autoplay blocked'));
        this.bgmPlaying = true;
    }
    
    stopBGM() {
        if (this.bgm) {
            this.bgm.pause();
            this.bgm.currentTime = 0;
        }
        this.bgmPlaying = false;
    }
    
    pauseBGM() {
        if (this.bgm && this.bgmPlaying) {
            this.bgm.pause();
        }
    }
    
    resumeBGM() {
        if (this.bgm && this.bgmPlaying) {
            this.bgm.play().catch(e => {});
        }
    }
    
    hit() { this.tone(150, 0.1, 'sawtooth', 0.15); }
    shoot() { this.tone(320, 0.03); }
    pickup() { this.tone(520, 0.04, 'sine'); }
    levelUp() { [523,659,784,1047].forEach((f,i) => setTimeout(() => this.tone(f,0.1,'sine',0.15), i*60)); }
    victory() { [523,659,784,880,1047].forEach((f,i) => setTimeout(() => this.tone(f,0.18,'sine',0.2), i*100)); }
    death() { this.tone(160, 0.2, 'sawtooth'); this.tone(80, 0.25, 'sawtooth'); }
    bossWarn() { this.tone(80, 0.35, 'sawtooth', 0.25); setTimeout(() => this.tone(60, 0.35, 'sawtooth', 0.25), 400); }
    itemDrop() { this.tone(700, 0.08, 'sine', 0.2); this.tone(900, 0.12, 'sine', 0.15); }
}

// ==================== PARTICLES ====================
class Particles {
    constructor() { this.list = []; this.stains = []; }
    emit(x, y, n, opt = {}) {
        for (let i = 0; i < n; i++) {
            const a = Math.random() * Math.PI * 2, s = (opt.minS || 35) + Math.random() * ((opt.maxS || 100) - (opt.minS || 35));
            this.list.push({ x, y, vx: Math.cos(a) * s, vy: Math.sin(a) * s, color: opt.color || '#fff', size: 2 + Math.random() * 2.5, life: 0.6, maxLife: 0.6, gravity: opt.gravity || 0 });
        }
    }
    blood(x, y) { this.emit(x, y, 8, { color: '#8b0000', minS: 35, maxS: 130, gravity: 160 }); this.stains.push({ x, y, size: 5 + Math.random() * 8 }); if (this.stains.length > 100) this.stains.shift(); }
    update(dt) { this.list = this.list.filter(p => { p.x += p.vx * dt; p.y += p.vy * dt; p.vy += p.gravity * dt; p.life -= dt; return p.life > 0; }); }
    draw(ctx, cam) {
        ctx.fillStyle = '#4a0000';
        for (const s of this.stains) { ctx.globalAlpha = 0.3; ctx.beginPath(); ctx.arc(s.x - cam.x, s.y - cam.y, s.size, 0, Math.PI * 2); ctx.fill(); }
        for (const p of this.list) { ctx.globalAlpha = p.life / p.maxLife; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x - cam.x, p.y - cam.y, p.size, 0, Math.PI * 2); ctx.fill(); }
        ctx.globalAlpha = 1;
    }
}

// ==================== FLOAT TEXT ====================
class FloatText {
    constructor(x, y, text, color = '#fff', size = 14) { this.x = x; this.y = y; this.text = text; this.color = color; this.size = size; this.life = 0.7; this.vy = -45; }
    update(dt) { this.y += this.vy * dt; this.life -= dt; }
    draw(ctx, cam) { ctx.globalAlpha = this.life / 0.7; ctx.fillStyle = this.color; ctx.font = `bold ${this.size}px Cairo`; ctx.textAlign = 'center'; ctx.fillText(this.text, this.x - cam.x, this.y - cam.y); ctx.globalAlpha = 1; }
}

// ==================== SPRITE EFFECTS ====================
class SpriteEffect {
    constructor(x, y, spriteKey, frameWidth, frameHeight, totalFrames, duration, scale = 1) {
        this.x = x; 
        this.y = y;
        this.spriteKey = spriteKey;
        this.frameWidth = frameWidth;
        this.frameHeight = frameHeight;
        this.totalFrames = totalFrames;
        this.duration = duration;
        this.scale = scale;
        this.time = 0;
        this.done = false;
    }
    
    update(dt) {
        this.time += dt;
        if (this.time >= this.duration) this.done = true;
    }
    
    draw(ctx, cam, assets) {
        if (this.done) return;
        const sprite = assets && assets.get(this.spriteKey);
        if (!sprite) return;
        
        const progress = this.time / this.duration;
        const frame = Math.min(Math.floor(progress * this.totalFrames), this.totalFrames - 1);
        const sx = this.x - cam.x, sy = this.y - cam.y;
        
        ctx.imageSmoothingEnabled = false;
        ctx.globalAlpha = 1 - progress * 0.3;
        
        const drawW = this.frameWidth * this.scale;
        const drawH = this.frameHeight * this.scale;
        
        // Calculate frame position (assuming horizontal strip)
        const frameX = frame * this.frameWidth;
        
        ctx.drawImage(
            sprite,
            frameX, 0, this.frameWidth, this.frameHeight,
            sx - drawW / 2, sy - drawH / 2, drawW, drawH
        );
        
        ctx.globalAlpha = 1;
    }
}

// ==================== PLAYER ====================
class Player {
    constructor(x, y, charId) {
        this.x = x; this.y = y; this.charId = charId;
        const c = CHARACTERS[charId];
        this.maxHp = c.stats.hp || 100; this.hp = this.maxHp;
        this.speed = c.stats.speed || 200;
        this.dmgMult = 1; this.atkSpd = 1;
        this.pickupRange = 40 * (c.stats.pickup || 1);
        this.xpMult = c.stats.xpMult || 1;
        this.goldMult = c.stats.gold || 1;
        this.dmgReduce = c.stats.dmgReduce || 0;
        this.luck = c.stats.luck || 1;
        this.crit = c.stats.crit || 0;
        this.enemyBuff = c.stats.enemyBuff || 0;
        this.extraEnemySpawn = 0;
        this.armor = 0; this.regen = 0; this.curse = 0;
        this.range = c.stats.range || 1;
        this.cdMult = c.stats.cooldown || 1;
        
        this.weapons = [{ id: c.weapon, level: 1, upgrades: [] }];
        this.books = [];
        this.xp = 0; this.level = 1; this.gold = 0; this.kills = 0;
        this.invuln = 0; this.facing = 1; this.vx = 0; this.vy = 0; this.anim = 0;
        this.shield = 0; this.hasRevive = false; this.tempBuffs = [];
        this.wTimers = {};
        this.width = 32; this.height = 45;
    }
    
    getDmg(w) {
        let d = CONFIG.WEAPON_BASE_DMG + (w.level - 1) * 0.4;
        w.upgrades.forEach(u => d += u.rarity.bonus);
        d *= this.dmgMult;
        this.tempBuffs.filter(b => b.type === 'dmg').forEach(b => d *= (1 + b.val));
        if (this.crit > 0 && Math.random() < this.crit) d *= 2;
        return d;
    }
    getCD(w) { let m = this.cdMult / this.atkSpd; this.tempBuffs.filter(b => b.type === 'atkSpd').forEach(b => m /= (1 + b.val)); return Math.max(0.08, WEAPONS[w.id].cd * m * (1 - (w.level - 1) * 0.015)); }
    getRange(w) { return WEAPONS[w.id].range * this.range * (1 + (w.level - 1) * 0.025); }
    
    findNearest(game, maxD = 450) {
        let near = null, minD = maxD;
        for (const e of game.enemies) { const d = Math.hypot(e.x - this.x, e.y - this.y); if (d < minD) { minD = d; near = e; } }
        if (game.boss) { const d = Math.hypot(game.boss.x - this.x, game.boss.y - this.y); if (d < minD) near = game.boss; }
        return near;
    }
    
    update(dt, input, game) {
        let dx = 0, dy = 0;
        if (input.left) dx -= 1; if (input.right) dx += 1; if (input.up) dy -= 1; if (input.down) dy += 1;
        if (input.joy) { dx += input.joy.x; dy += input.joy.y; }
        const mag = Math.hypot(dx, dy);
        if (mag > 0) {
            dx /= mag; dy /= mag;
            let spd = this.speed; this.tempBuffs.filter(b => b.type === 'speed').forEach(b => spd *= (1 + b.val));
            this.vx = dx * spd; this.vy = dy * spd;
            if (dx !== 0) this.facing = dx > 0 ? 1 : -1;
        } else { this.vx = 0; this.vy = 0; }
        
        this.x += this.vx * dt; this.y += this.vy * dt;
        this.x = Math.max(-CONFIG.WORLD_SIZE/2, Math.min(CONFIG.WORLD_SIZE/2, this.x));
        this.y = Math.max(-CONFIG.WORLD_SIZE/2, Math.min(CONFIG.WORLD_SIZE/2, this.y));
        if (this.invuln > 0) this.invuln -= dt;
        this.anim += dt;
        if (this.regen > 0) this.hp = Math.min(this.maxHp, this.hp + this.regen * dt);
        this.tempBuffs = this.tempBuffs.filter(b => { b.dur -= dt; return b.dur > 0; });
        
        const target = this.findNearest(game);
        this.weapons.forEach(w => {
            if (!this.wTimers[w.id]) this.wTimers[w.id] = 0;
            this.wTimers[w.id] -= dt;
            if (this.wTimers[w.id] <= 0) { this.fire(w, game, target); this.wTimers[w.id] = this.getCD(w); }
        });
    }
    
    fire(w, game, target) {
        const data = WEAPONS[w.id], dmg = this.getDmg(w), range = this.getRange(w);
        switch(data.type) {
            case 'projectile':
                if (target && Math.hypot(target.x - this.x, target.y - this.y) < range) {
                    const a = Math.atan2(target.y - this.y, target.x - this.x);
                    const isFlame = data.icon === 'ğŸ”¥';
                    game.proj.push({ 
                        x: this.x, y: this.y, 
                        vx: Math.cos(a) * 360, vy: Math.sin(a) * 360, 
                        dmg, life: 2.2, size: isFlame ? 8 : 6, 
                        color: isFlame ? '#ff4500' : '#8b4513', 
                        pierce: w.level > 10 ? 2 : 1,
                        type: isFlame ? 'fire' : 'normal'
                    });
                    game.audio.shoot();
                    // Muzzle flash effect
                    if (isFlame) {
                        game.spriteEffects.push(new SpriteEffect(this.x, this.y, 'fx_fire_small', 24, 24, 6, 0.2, 1.2));
                    }
                }
                break;
            case 'radial': {
                const n = 4 + Math.floor(w.level / 4);
                for (let i = 0; i < n; i++) { 
                    const a = (i / n) * Math.PI * 2; 
                    game.proj.push({ x: this.x, y: this.y, vx: Math.cos(a) * 300, vy: Math.sin(a) * 300, dmg: dmg * 0.65, life: 1.8, size: 5, color: '#6a4a20' }); 
                }
                game.audio.shoot();
                break;
            }
            case 'lightning': {
                const ts = game.enemies.filter(e => Math.hypot(e.x - this.x, e.y - this.y) < range);
                if (ts.length > 0) { 
                    const t = ts[Math.floor(Math.random() * ts.length)]; 
                    game.fx.push({ type: 'lightning', x: t.x, y: t.y, life: 0.25 }); 
                    // Add spark effect
                    game.spriteEffects.push(new SpriteEffect(t.x, t.y, 'fx_spark', 24, 24, 5, 0.3, 1.5));
                    if (t.takeDmg(dmg, game)) game.killEnemy(t); 
                    game.audio.tone(650, 0.06, 'sawtooth'); 
                }
                break;
            }
            case 'meteor': {
                const n = 1 + Math.floor(w.level / 4);
                for (let i = 0; i < n; i++) {
                    const mx = this.x + (Math.random() - 0.5) * range * 2;
                    const my = this.y + (Math.random() - 0.5) * range * 2;
                    game.fx.push({ type: 'meteor', x: mx, y: my, dmg, radius: 55, life: 0.75, delay: i * 0.12, hit: false });
                }
                break;
            }
            case 'tornado':
                game.fx.push({ type: 'tornado', x: this.x + this.facing * 35, y: this.y, vx: this.facing * 85, vy: 0, dmg: dmg * 0.35, slow: 0.5, life: 3.2 + w.level * 0.12, radius: 35 });
                // Dust effect
                game.spriteEffects.push(new SpriteEffect(this.x + this.facing * 35, this.y, 'fx_dust', 24, 24, 5, 0.4, 1.2));
                break;
        }
    }
    
    takeDmg(amt, game) {
        if (this.invuln > 0) return;
        if (this.shield > 0) { const ab = Math.min(this.shield, amt); this.shield -= ab; amt -= ab; if (amt <= 0) return; }
        const actual = amt * (1 - this.dmgReduce) * (1 - Math.min(0.65, this.armor * 0.025));
        this.hp -= actual; this.invuln = 0.35;
        game.audio.hit(); game.shake = 0.12;
        game.texts.push(new FloatText(this.x, this.y - 20, `-${Math.round(actual)}`, '#f00'));
        if (this.hp <= 0) {
            if (this.hasRevive) { this.hasRevive = false; this.hp = this.maxHp * 0.5; this.invuln = 1.2; game.texts.push(new FloatText(this.x, this.y - 35, 'Ø¥Ø­ÙŠØ§Ø¡!', '#ffd700', 18)); }
            else game.over(false);
        }
    }
    
    draw(ctx, cam, assets) {
        const sx = this.x - cam.x, sy = this.y - cam.y;
        if (this.invuln > 0 && Math.floor(this.invuln * 12) % 2 === 0) ctx.globalAlpha = 0.35;
        
        // Draw character sprite
        const c = CHARACTERS[this.charId].colors;
        ctx.save();
        
        // Try to draw sprite if available
        const spriteInfo = CHAR_SPRITES[this.charId];
        const isMoving = Math.abs(this.vx) > 10 || Math.abs(this.vy) > 10;
        const spriteKey = isMoving ? spriteInfo.sprite : spriteInfo.idle;
        const sprite = assets && assets.get(spriteKey);
        
        if (sprite && spriteInfo) {
            // Calculate animation frame
            const frameTime = 0.15;
            const totalFrames = spriteInfo.frames;
            const currentFrame = Math.floor(this.anim / frameTime) % totalFrames;
            
            // Determine direction row (0=down, 1=left, 2=right, 3=up based on typical RPG sprite sheets)
            let row = 0;
            if (isMoving) {
                if (Math.abs(this.vx) > Math.abs(this.vy)) {
                    row = this.vx > 0 ? 2 : 1; // right or left
                } else {
                    row = this.vy > 0 ? 0 : 3; // down or up
                }
            } else {
                row = this.facing > 0 ? 2 : 1;
            }
            
            const frameX = currentFrame * spriteInfo.frameWidth;
            const frameY = row * spriteInfo.frameHeight;
            
            // Draw sprite
            const scale = 1.5;
            const drawW = spriteInfo.frameWidth * scale;
            const drawH = spriteInfo.frameHeight * scale;
            
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(
                sprite,
                frameX, frameY, spriteInfo.frameWidth, spriteInfo.frameHeight,
                sx - drawW / 2, sy - drawH / 2, drawW, drawH
            );
        } else {
            // Fallback to simple rendering
            const c = CHARACTERS[this.charId].colors;
            if (this.facing < 0) { ctx.translate(sx, sy); ctx.scale(-1, 1); ctx.translate(-sx, sy); }
            
            ctx.fillStyle = c.body;
            ctx.fillRect(sx - 10, sy - 8, 20, 26);
            ctx.fillStyle = c.head;
            ctx.fillRect(sx - 8, sy - 24, 16, 8);
            ctx.fillStyle = c.skin;
            ctx.fillRect(sx - 7, sy - 16, 14, 10);
            ctx.fillStyle = '#000';
            ctx.fillRect(sx - 4, sy - 13, 2, 2);
            ctx.fillRect(sx + 2, sy - 13, 2, 2);
            ctx.fillStyle = c.legs;
            ctx.fillRect(sx - 6, sy + 18, 5, 8);
            ctx.fillRect(sx + 1, sy + 18, 5, 8);
        }
        
        ctx.restore();
        ctx.globalAlpha = 1;
        
        // Weapon visuals
        this.weapons.forEach(w => {
            const data = WEAPONS[w.id], range = this.getRange(w);
            if (data.type === 'orbit') {
                const n = 4 + Math.floor(w.level / 5);
                ctx.fillStyle = '#333';
                for (let i = 0; i < n; i++) {
                    const a = this.anim * 2 + (i / n) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.arc(sx + Math.cos(a) * range, sy + Math.sin(a) * range, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (data.type === 'melee') {
                const timer = this.wTimers[w.id] || 0, cd = this.getCD(w);
                if (timer > cd * 0.8) {
                    ctx.strokeStyle = 'rgba(150, 150, 150, 0.4)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(sx, sy, range, -0.5 * this.facing, 0.5 * this.facing);
                    ctx.stroke();
                }
            }
            if (data.type === 'aura') {
                ctx.strokeStyle = 'rgba(100, 50, 150, 0.2)';
                ctx.lineWidth = 2;
                ctx.setLineDash([4, 6]);
                ctx.beginPath();
                ctx.arc(sx, sy, range, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        });
        
        // Shield indicator
        if (this.shield > 0) {
            ctx.strokeStyle = 'rgba(80, 160, 255, 0.5)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(sx, sy, 30, 0, Math.PI * 2);
            ctx.stroke();
        }
    }
}

// ==================== ENEMY ====================
class Enemy {
    constructor(x, y, type, gameTime, buff = 0) {
        this.x = x; this.y = y; this.type = type;
        const e = ENEMIES[type];
        const scale = 1 + (gameTime / 60) * CONFIG.SCALING_PER_MIN;
        const buffScale = 1 + buff;
        this.maxHp = Math.round(CONFIG.ENEMY_BASE_HP * e.hpM * scale * buffScale);
        this.hp = this.maxHp;
        this.atk = CONFIG.ENEMY_BASE_ATK * e.atkM * scale * buffScale;
        this.spd = CONFIG.ENEMY_BASE_SPEED * e.spdM;
        this.xp = e.xp; this.color = e.color;
        this.vx = 0; this.vy = 0; this.hitFlash = 0; this.slow = 1; this.slowT = 0;
        this.zigT = 0; this.zigD = 1; this.tpT = 0; this.atkT = 0;
        this.width = 28; this.height = 28;
        this.zig = e.zig; this.ranged = e.ranged; this.tp = e.tp;
        this.animTime = Math.random() * 2; // Random start for animation variety
    }
    
    update(dt, player, enemies, game) {
        const dx = player.x - this.x, dy = player.y - this.y, dist = Math.hypot(dx, dy);
        if (this.slowT > 0) { this.slowT -= dt; if (this.slowT <= 0) this.slow = 1; }
        if (dist > 0) {
            let mx = dx / dist, my = dy / dist;
            if (this.zig) { this.zigT += dt; if (this.zigT > 0.35) { this.zigT = 0; this.zigD *= -1; } mx = mx * 0.7 + (-my * this.zigD) * 0.3; my = my * 0.7 + (mx * this.zigD) * 0.3; }
            if (this.tp) { this.tpT += dt; if (this.tpT > 1.5 && dist > 70) { this.tpT = 0; const a = Math.random() * Math.PI * 2; this.x = player.x + Math.cos(a) * 100; this.y = player.y + Math.sin(a) * 100; game.particles.emit(this.x, this.y, 6, { color: '#4a0080' }); } }
            if (this.ranged && dist < 220 && dist > 50) { this.atkT -= dt; if (this.atkT <= 0) { this.atkT = 1.2; const a = Math.atan2(dy, dx); game.eProj.push({ x: this.x, y: this.y, vx: Math.cos(a) * 160, vy: Math.sin(a) * 160, dmg: this.atk * 0.4, life: 2.2, size: 3, color: this.color }); } }
            let sepX = 0, sepY = 0;
            for (const o of enemies) { if (o === this) continue; const ox = this.x - o.x, oy = this.y - o.y, od = Math.hypot(ox, oy); if (od < 25 && od > 0) { sepX += ox / od * (25 - od) / 25; sepY += oy / od * (25 - od) / 25; } }
            mx += sepX * 0.35; my += sepY * 0.35;
            const m = Math.hypot(mx, my); if (m > 0) { this.vx = (mx / m) * this.spd * this.slow; this.vy = (my / m) * this.spd * this.slow; }
        }
        this.x += this.vx * dt; this.y += this.vy * dt;
        if (this.hitFlash > 0) this.hitFlash -= dt;
        this.animTime += dt; // Update animation
    }
    
    takeDmg(amt, game) { this.hp -= amt; this.hitFlash = 0.06; game.texts.push(new FloatText(this.x + (Math.random() - 0.5) * 12, this.y - 12, Math.round(amt).toString(), '#ff0')); return this.hp <= 0; }
    
    draw(ctx, cam, assets) {
        const sx = this.x - cam.x, sy = this.y - cam.y;
        if (this.hitFlash > 0) ctx.globalAlpha = 0.55;
        
        // Try to draw sprite if available
        const spriteInfo = ENEMY_SPRITES[this.type];
        const sprite = assets && spriteInfo && assets.get(spriteInfo.sprite);
        
        if (sprite) {
            ctx.save();
            ctx.imageSmoothingEnabled = false;
            
            const scale = 0.6; // Scale down the large sprites
            const drawW = spriteInfo.width * scale;
            const drawH = spriteInfo.height * scale;
            
            // Flip based on movement direction
            if (this.vx < 0) {
                ctx.translate(sx, sy);
                ctx.scale(-1, 1);
                ctx.drawImage(sprite, -drawW / 2, -drawH / 2, drawW, drawH);
            } else {
                ctx.drawImage(sprite, sx - drawW / 2, sy - drawH / 2, drawW, drawH);
            }
            
            ctx.restore();
        } else {
            // Fallback to colored circle
            ctx.fillStyle = this.color;
            ctx.beginPath(); 
            ctx.arc(sx, sy, 14, 0, Math.PI * 2); 
            ctx.fill();
            // Eyes
            ctx.fillStyle = '#ff0';
            ctx.fillRect(sx - 4, sy - 3, 3, 3); 
            ctx.fillRect(sx + 1, sy - 3, 3, 3);
        }
        
        ctx.globalAlpha = 1;
        
        // Health bar
        if (this.hp < this.maxHp) { 
            ctx.fillStyle = '#333'; 
            ctx.fillRect(sx - 18, sy - 28, 36, 5); 
            ctx.fillStyle = '#f00'; 
            ctx.fillRect(sx - 18, sy - 28, 36 * (this.hp / this.maxHp), 5); 
        }
    }
}

// ==================== BOSS ====================
class Boss {
    constructor(x, y, buff = 0) {
        this.x = x; this.y = y;
        this.maxHp = BOSS.hp * (1 + buff); this.hp = this.maxHp;
        this.atk = BOSS.atk * (1 + buff); this.spd = BOSS.spd;
        this.phase = 1; this.atkT = 0; this.specT = 0; this.hitFlash = 0;
        this.width = 70; this.height = 70;
    }
    update(dt, player, game) {
        const pct = this.hp / this.maxHp; this.phase = pct < 0.33 ? 3 : pct < 0.66 ? 2 : 1;
        const dx = player.x - this.x, dy = player.y - this.y, dist = Math.hypot(dx, dy);
        if (dist > 0) { const s = this.spd * (1 + (3 - this.phase) * 0.12); this.x += (dx / dist) * s * dt; this.y += (dy / dist) * s * dt; }
        this.atkT -= dt;
        if (this.atkT <= 0) { this.atkT = 1.6 / this.phase; const a = Math.atan2(dy, dx); for (let i = -2; i <= 2; i++) game.eProj.push({ x: this.x, y: this.y, vx: Math.cos(a + i * 0.12) * 200, vy: Math.sin(a + i * 0.12) * 200, dmg: this.atk, life: 2.2, size: 7, color: '#ff4500' }); }
        if (this.phase >= 2) { this.specT -= dt; if (this.specT <= 0) { this.specT = 3.5; const types = ['wolf', 'scorpion']; for (let i = 0; i < this.phase * 2; i++) { const a = Math.random() * Math.PI * 2; game.enemies.push(new Enemy(this.x + Math.cos(a) * 70, this.y + Math.sin(a) * 70, types[Math.floor(Math.random() * types.length)], game.time, player.enemyBuff)); } } }
        if (this.hitFlash > 0) this.hitFlash -= dt;
    }
    takeDmg(amt, game) { this.hp -= amt; this.hitFlash = 0.06; game.texts.push(new FloatText(this.x + (Math.random() - 0.5) * 25, this.y - 25, Math.round(amt).toString(), '#ff0', 16)); return this.hp <= 0; }
    draw(ctx, cam) {
        const sx = this.x - cam.x, sy = this.y - cam.y;
        if (this.hitFlash > 0) ctx.globalAlpha = 0.55;
        ctx.fillStyle = BOSS.color;
        ctx.beginPath(); ctx.ellipse(sx, sy, 35, 30, 0, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(sx, sy - 30, 22, 16, 0, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#ff0';
        ctx.fillRect(sx - 12, sy - 34, 5, 5); ctx.fillRect(sx + 7, sy - 34, 5, 5);
        ctx.fillStyle = '#5a0000';
        ctx.beginPath(); ctx.moveTo(sx - 30, sy - 8); ctx.lineTo(sx - 48, sy - 35); ctx.lineTo(sx - 18, sy - 4); ctx.fill();
        ctx.beginPath(); ctx.moveTo(sx + 30, sy - 8); ctx.lineTo(sx + 48, sy - 35); ctx.lineTo(sx + 18, sy - 4); ctx.fill();
        ctx.globalAlpha = 1;
    }
}

// ==================== PICKUPS ====================
class Pickup {
    constructor(x, y, type, val) { this.x = x; this.y = y; this.type = type; this.val = val; this.bob = Math.random() * Math.PI * 2; }
    update(dt) { this.bob += dt * 3.5; }
    draw(ctx, cam, assets) {
        const sx = this.x - cam.x, sy = this.y - cam.y + Math.sin(this.bob) * 3;
        
        const sprite = this.type === 'xp' ? assets && assets.get('xp_gem') : assets && assets.get('gold_coin');
        
        if (sprite) {
            ctx.imageSmoothingEnabled = false;
            const size = this.type === 'xp' ? 18 : 16;
            ctx.drawImage(sprite, sx - size / 2, sy - size / 2, size, size);
        } else {
            // Fallback
            if (this.type === 'xp') { 
                ctx.fillStyle = '#0f0'; 
                ctx.beginPath(); 
                ctx.moveTo(sx, sy - 6); 
                ctx.lineTo(sx + 6, sy); 
                ctx.lineTo(sx, sy + 6); 
                ctx.lineTo(sx - 6, sy); 
                ctx.fill(); 
            } else { 
                ctx.fillStyle = '#ffd700'; 
                ctx.beginPath(); 
                ctx.arc(sx, sy, 5, 0, Math.PI * 2); 
                ctx.fill(); 
            }
        }
    }
}

class ItemDrop {
    constructor(x, y, id) { this.x = x; this.y = y; this.id = id; this.bob = Math.random() * Math.PI * 2; this.glow = 0; }
    update(dt) { this.bob += dt * 3.5; this.glow += dt * 4; }
    draw(ctx, cam, assets) {
        const sx = this.x - cam.x, sy = this.y - cam.y + Math.sin(this.bob) * 4;
        const item = ITEMS[this.id];
        const rarityColor = RARITY[item.rarity].color;
        
        // Glowing background circle
        const glowSize = 22 + Math.sin(this.glow) * 4;
        ctx.fillStyle = rarityColor + '50';
        ctx.beginPath(); 
        ctx.arc(sx, sy, glowSize, 0, Math.PI * 2); 
        ctx.fill();
        
        // Inner circle
        ctx.fillStyle = '#000000cc';
        ctx.beginPath(); 
        ctx.arc(sx, sy, 18, 0, Math.PI * 2); 
        ctx.fill();
        
        // Border
        ctx.strokeStyle = rarityColor;
        ctx.lineWidth = 3;
        ctx.beginPath(); 
        ctx.arc(sx, sy, 18, 0, Math.PI * 2); 
        ctx.stroke();
        
        // Try to draw sprite if available
        const sprite = item.sprite && assets && assets.get(item.sprite);
        if (sprite) {
            ctx.imageSmoothingEnabled = false;
            const size = 28;
            ctx.drawImage(sprite, sx - size/2, sy - size/2, size, size);
        } else {
            // Fallback to icon
            ctx.font = 'bold 20px Arial'; 
            ctx.textAlign = 'center'; 
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#fff';
            ctx.fillText(item.icon, sx, sy);
        }
    }
}

// ==================== GAME ====================
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.audio = new Audio();
        this.particles = new Particles();
        this.assets = new AssetLoader();
        
        this.state = 'loading';
        this.charIdx = 0;
        this.charIds = Object.keys(CHARACTERS);
        this.city = 'badaya';
        
        this.player = null;
        this.enemies = [];
        this.boss = null;
        this.proj = [];
        this.eProj = [];
        this.pickups = [];
        this.items = [];
        this.texts = [];
        this.fx = [];
        this.spriteEffects = [];
        
        this.cam = { x: 0, y: 0 };
        this.shake = 0;
        this.input = { up: false, down: false, left: false, right: false, joy: null };
        
        this.spawnT = 0; this.time = 0;
        this.bossSpawned = false; this.bossWarnShown = false;
        this.globalSlow = 0;
        
        this.pendingItem = null;
        
        this.highScore = parseInt(localStorage.getItem('goldBloodHighScore') || '0');
        this.baghdadUnlocked = localStorage.getItem('baghdadUnlocked') === 'true';
        
        // Cached tile image
        this.sandTilePattern = null;
        
        this.lastTime = 0;
        this.init();
    }
    
    async init() {
        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.setupInput();
        
        // Show loading screen
        this.drawLoading();
        
        // Load assets
        await this.assets.loadAll();
        
        // Create sand tile pattern if loaded
        if (this.assets.get('sand_tile')) {
            this.sandTilePattern = this.ctx.createPattern(this.assets.get('sand_tile'), 'repeat');
        }
        
        this.state = 'menu';
        this.setupMenu();
        requestAnimationFrame(t => this.loop(t));
    }
    
    drawLoading() {
        const ctx = this.ctx;
        ctx.fillStyle = '#0a0a0f';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 24px Cairo';
        ctx.textAlign = 'center';
        ctx.fillText('Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù„Ø¹Ø¨Ø©...', this.canvas.width / 2, this.canvas.height / 2);
        ctx.fillStyle = '#888';
        ctx.font = '16px Cairo';
        ctx.fillText('Loading game assets...', this.canvas.width / 2, this.canvas.height / 2 + 35);
    }
    
    resize() { this.canvas.width = window.innerWidth; this.canvas.height = window.innerHeight; }
    
    setupMenu() {
        document.getElementById('highScore').textContent = this.highScore;
        if (this.baghdadUnlocked) { document.getElementById('cityBaghdad').classList.remove('locked'); document.getElementById('cityBaghdad').querySelector('.city-locked').style.display = 'none'; }
        this.updateCharDisplay();
        document.getElementById('charPrev').onclick = () => { this.charIdx = (this.charIdx - 1 + this.charIds.length) % this.charIds.length; this.updateCharDisplay(); };
        document.getElementById('charNext').onclick = () => { this.charIdx = (this.charIdx + 1) % this.charIds.length; this.updateCharDisplay(); };
        document.querySelectorAll('.city-card').forEach(card => { card.onclick = () => { if (card.classList.contains('locked')) return; document.querySelectorAll('.city-card').forEach(c => c.classList.remove('selected')); card.classList.add('selected'); this.city = card.dataset.city; }; });
        document.getElementById('startBtn').onclick = () => this.start();
        document.getElementById('restartBtn').onclick = () => this.restart();
        document.getElementById('itemContinueBtn').onclick = () => this.continueFromItem();
        
        // Pause button
        document.getElementById('pauseBtn').onclick = () => this.pause();
        document.getElementById('resumeBtn').onclick = () => this.pause();
        document.getElementById('quitBtn').onclick = () => this.quitToMenu();
        
        // Volume controls
        document.getElementById('musicVolume').oninput = (e) => {
            const vol = e.target.value / 100;
            this.audio.setMusicVolume(vol);
            document.getElementById('musicVolText').textContent = e.target.value + '%';
        };
        document.getElementById('sfxVolume').oninput = (e) => {
            const vol = e.target.value / 100;
            this.audio.setSfxVolume(vol);
            document.getElementById('sfxVolText').textContent = e.target.value + '%';
        };
    }
    
    updateCharDisplay() {
        const id = this.charIds[this.charIdx], c = CHARACTERS[id];
        document.getElementById('charName').textContent = c.name;
        document.getElementById('charTitle').textContent = c.title;
        document.getElementById('charDesc').textContent = c.desc;
        document.getElementById('charWeapon').innerHTML = `ğŸ—¡ï¸ ${WEAPONS[c.weapon].name}`;
        let html = '';
        c.passiveText.forEach(p => { const neg = p.includes('Ù‚ÙˆØ© Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡'); html += `<div class="char-stat"><span class="char-stat-label">â€¢</span><span class="${neg ? 'char-stat-negative' : 'char-stat-value'}">${p}</span></div>`; });
        document.getElementById('charStats').innerHTML = html;
        
        const canvas = document.getElementById('charPreview'), ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, 120, 120);
        
        // Try to draw sprite
        const spriteInfo = CHAR_SPRITES[id];
        const sprite = this.assets && this.assets.get(spriteInfo.idle);
        
        if (sprite) {
            ctx.imageSmoothingEnabled = false;
            const scale = 2;
            const drawW = spriteInfo.frameWidth * scale;
            const drawH = spriteInfo.frameHeight * scale;
            // Draw idle frame (row 0, frame 0)
            ctx.drawImage(
                sprite,
                0, 0, spriteInfo.frameWidth, spriteInfo.frameHeight,
                (120 - drawW) / 2, (120 - drawH) / 2, drawW, drawH
            );
        } else {
            // Fallback to simple drawing
            const col = c.colors;
            ctx.fillStyle = col.body; ctx.fillRect(42, 42, 36, 45);
            ctx.fillStyle = col.head; ctx.fillRect(45, 18, 30, 14);
            ctx.fillStyle = col.skin; ctx.fillRect(48, 32, 24, 16);
            ctx.fillStyle = '#000'; ctx.fillRect(52, 38, 4, 4); ctx.fillRect(64, 38, 4, 4);
            ctx.fillStyle = col.legs; ctx.fillRect(45, 87, 10, 15); ctx.fillRect(65, 87, 10, 15);
        }
    }
    
    setupInput() {
        window.addEventListener('keydown', e => {
            if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') this.input.up = true;
            if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') this.input.down = true;
            if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') this.input.left = true;
            if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') this.input.right = true;
            if ((e.key === 'Escape' || e.key === 'p') && this.state === 'playing') this.pause();
        });
        window.addEventListener('keyup', e => {
            if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') this.input.up = false;
            if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') this.input.down = false;
            if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') this.input.left = false;
            if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') this.input.right = false;
        });
        let touchStart = null;
        this.canvas.addEventListener('touchstart', e => { if (this.state !== 'playing') return; e.preventDefault(); touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY }; this.input.joy = { x: 0, y: 0 }; }, { passive: false });
        this.canvas.addEventListener('touchmove', e => { if (this.state !== 'playing' || !touchStart) return; e.preventDefault(); const dx = e.touches[0].clientX - touchStart.x, dy = e.touches[0].clientY - touchStart.y; const d = Math.min(Math.hypot(dx, dy), 60), a = Math.atan2(dy, dx); this.input.joy = { x: Math.cos(a) * d / 60, y: Math.sin(a) * d / 60 }; }, { passive: false });
        this.canvas.addEventListener('touchend', () => { touchStart = null; this.input.joy = null; });
    }
    
    setupSlots() {
        const ws = document.getElementById('weaponSlots'), bs = document.getElementById('bookSlots');
        ws.innerHTML = ''; bs.innerHTML = '';
        for (let i = 0; i < CONFIG.MAX_WEAPONS; i++) ws.innerHTML += `<div class="equipment-slot" id="ws${i}"></div>`;
        for (let i = 0; i < CONFIG.MAX_BOOKS; i++) bs.innerHTML += `<div class="equipment-slot" id="bs${i}"></div>`;
    }
    
    updateSlots() {
        for (let i = 0; i < CONFIG.MAX_WEAPONS; i++) {
            const slot = document.getElementById(`ws${i}`);
            if (this.player.weapons[i]) { const w = this.player.weapons[i]; slot.innerHTML = `<span style="font-size:1.1rem">${WEAPONS[w.id].icon}</span><span class="slot-level">${w.level}</span>`; slot.style.borderColor = w.upgrades.length > 0 ? w.upgrades[w.upgrades.length - 1].rarity.color : '#444'; }
            else slot.innerHTML = '';
        }
        for (let i = 0; i < CONFIG.MAX_BOOKS; i++) {
            const slot = document.getElementById(`bs${i}`);
            if (this.player.books[i]) { const b = this.player.books[i]; slot.innerHTML = `<span style="font-size:1.1rem">${BOOKS[b.id].icon}</span><span class="slot-level">${b.level}</span>`; slot.style.borderColor = b.upgrades.length > 0 ? b.upgrades[b.upgrades.length - 1].rarity.color : '#444'; }
            else slot.innerHTML = '';
        }
    }
    
    start() {
        this.audio.init();
        this.audio.startBGM(); // Start background music
        this.state = 'playing';
        document.getElementById('mainMenu').style.display = 'none';
        document.getElementById('hud').style.display = 'flex';
        document.getElementById('equipmentSlots').style.display = 'flex';
        document.getElementById('pauseBtn').style.display = 'block';
        document.getElementById('pauseBtn').textContent = 'â¸ï¸';
        
        this.player = new Player(0, 0, this.charIds[this.charIdx]);
        this.enemies = []; this.boss = null; this.proj = []; this.eProj = []; this.pickups = []; this.items = []; this.texts = []; this.fx = []; this.spriteEffects = [];
        this.particles.list = []; this.particles.stains = [];
        this.time = 0; this.spawnT = 0; this.bossSpawned = false; this.bossWarnShown = false;
        this.setupSlots(); this.updateSlots();
    }
    
    restart() {
        document.getElementById('gameOverScreen').style.display = 'none';
        document.getElementById('mainMenu').style.display = 'flex';
        document.getElementById('hud').style.display = 'none';
        document.getElementById('equipmentSlots').style.display = 'none';
        document.getElementById('pauseBtn').style.display = 'none';
        this.state = 'menu';
        if (this.baghdadUnlocked) { document.getElementById('cityBaghdad').classList.remove('locked'); document.getElementById('cityBaghdad').querySelector('.city-locked').style.display = 'none'; }
    }
    
    pause() {
        if (this.state === 'playing') { 
            this.state = 'paused'; 
            document.getElementById('pauseMenu').style.display = 'flex';
            document.getElementById('pauseBtn').textContent = 'â–¶ï¸';
            this.audio.pauseBGM();
        }
        else if (this.state === 'paused') { 
            this.state = 'playing'; 
            document.getElementById('pauseMenu').style.display = 'none';
            document.getElementById('pauseBtn').textContent = 'â¸ï¸';
            this.audio.resumeBGM();
        }
    }
    
    quitToMenu() {
        this.state = 'menu';
        this.audio.stopBGM();
        document.getElementById('pauseMenu').style.display = 'none';
        document.getElementById('pauseBtn').style.display = 'none';
        document.getElementById('hud').style.display = 'none';
        document.getElementById('equipmentSlots').style.display = 'none';
        document.getElementById('mainMenu').style.display = 'flex';
        if (this.baghdadUnlocked) { 
            document.getElementById('cityBaghdad').classList.remove('locked'); 
            document.getElementById('cityBaghdad').querySelector('.city-locked').style.display = 'none'; 
        }
    }
    
    loop(t) {
        const dt = Math.min((t - this.lastTime) / 1000, 0.07);
        this.lastTime = t;
        if (this.state === 'loading') {
            this.drawLoading();
        } else {
            if (this.state === 'playing') this.update(dt);
            this.draw();
        }
        requestAnimationFrame(t => this.loop(t));
    }
    
    update(dt) {
        this.time += dt;
        
        if (this.time >= CONFIG.BOSS_TIME - 30 && !this.bossWarnShown) {
            this.bossWarnShown = true;
            document.getElementById('bossWarning').style.display = 'block';
            this.audio.bossWarn();
            setTimeout(() => document.getElementById('bossWarning').style.display = 'none', 2500);
        }
        
        if (this.time >= CONFIG.BOSS_TIME && !this.bossSpawned) {
            this.bossSpawned = true;
            const a = Math.random() * Math.PI * 2;
            this.boss = new Boss(this.player.x + Math.cos(a) * 320, this.player.y + Math.sin(a) * 320, this.player.enemyBuff);
        }
        
        if (this.globalSlow > 0) this.globalSlow -= dt;
        this.player.update(dt, this.input, this);
        
        this.cam.x = this.player.x - this.canvas.width / 2;
        this.cam.y = this.player.y - this.canvas.height / 2;
        if (this.shake > 0) { this.shake -= dt; this.cam.x += (Math.random() - 0.5) * 6; this.cam.y += (Math.random() - 0.5) * 6; }
        
        // Spawn enemies
        if (!this.bossSpawned) {
            this.spawnT -= dt;
            const spawnMult = 1 + this.player.curse * 0.35 + this.player.extraEnemySpawn;
            const rate = 1.2 / spawnMult;
            const maxE = Math.floor((55 + this.player.curse * 12) * spawnMult);
            if (this.spawnT <= 0 && this.enemies.length < maxE) { this.spawnEnemy(); this.spawnT = rate / (1 + this.time / 100); }
        }
        
        const eDt = this.globalSlow > 0 ? dt * 0.5 : dt;
        for (const e of this.enemies) {
            e.update(eDt, this.player, this.enemies, this);
            if (Math.hypot(e.x - this.player.x, e.y - this.player.y) < (e.width + this.player.width) / 2) this.player.takeDmg(e.atk, this);
            
            // Aura/orbit/melee dmg
            for (const w of this.player.weapons) {
                const data = WEAPONS[w.id], range = this.player.getRange(w);
                if (data.type === 'orbit' || data.type === 'aura') {
                    if (Math.hypot(e.x - this.player.x, e.y - this.player.y) < range + e.width / 2) {
                        const dps = this.player.getDmg(w) * (data.type === 'aura' ? 0.7 : 1.3);
                        if (e.takeDmg(dps * dt, this)) this.killEnemy(e);
                    }
                } else if (data.type === 'melee') {
                    const dist = Math.hypot(e.x - this.player.x, e.y - this.player.y);
                    const ang = Math.atan2(e.y - this.player.y, e.x - this.player.x);
                    const pAng = this.player.facing > 0 ? 0 : Math.PI;
                    if (dist < range + e.width / 2 && Math.abs(ang - pAng) < Math.PI / 2) {
                        const timer = this.player.wTimers[w.id] || 0, cd = this.player.getCD(w);
                        if (timer > cd * 0.82 && timer < cd * 0.95) { if (e.takeDmg(this.player.getDmg(w), this)) this.killEnemy(e); }
                    }
                }
            }
        }
        this.enemies = this.enemies.filter(e => e.hp > 0);
        
        // Boss
        if (this.boss) {
            this.boss.update(dt, this.player, this);
            if (Math.hypot(this.boss.x - this.player.x, this.boss.y - this.player.y) < (this.boss.width + this.player.width) / 2) this.player.takeDmg(this.boss.atk, this);
            for (const w of this.player.weapons) {
                const data = WEAPONS[w.id];
                if (data.type === 'orbit' || data.type === 'aura') {
                    if (Math.hypot(this.boss.x - this.player.x, this.boss.y - this.player.y) < this.player.getRange(w) + this.boss.width / 2)
                        this.boss.takeDmg(this.player.getDmg(w) * dt, this);
                }
            }
            if (this.boss.hp <= 0) this.over(true);
        }
        
        // Projectiles
        for (let i = this.proj.length - 1; i >= 0; i--) {
            const p = this.proj[i];
            p.x += p.vx * dt; p.y += p.vy * dt; p.life -= dt;
            if (p.life <= 0) { this.proj.splice(i, 1); continue; }
            for (const e of this.enemies) {
                if (Math.hypot(p.x - e.x, p.y - e.y) < p.size + e.width / 2) {
                    if (e.takeDmg(p.dmg, this)) this.killEnemy(e);
                    p.pierce = (p.pierce || 1) - 1;
                    if (p.pierce <= 0) this.proj.splice(i, 1);
                    break;
                }
            }
            if (this.boss && Math.hypot(p.x - this.boss.x, p.y - this.boss.y) < p.size + this.boss.width / 2) { this.boss.takeDmg(p.dmg, this); this.proj.splice(i, 1); }
        }
        
        // Enemy projectiles
        for (let i = this.eProj.length - 1; i >= 0; i--) {
            const p = this.eProj[i];
            p.x += p.vx * dt; p.y += p.vy * dt; p.life -= dt;
            if (p.life <= 0) { this.eProj.splice(i, 1); continue; }
            if (Math.hypot(p.x - this.player.x, p.y - this.player.y) < p.size + this.player.width / 2) { this.player.takeDmg(p.dmg, this); this.eProj.splice(i, 1); }
        }
        
        // Effects
        for (let i = this.fx.length - 1; i >= 0; i--) {
            const f = this.fx[i];
            if (f.type === 'lightning') { f.life -= dt; if (f.life <= 0) this.fx.splice(i, 1); }
            else if (f.type === 'meteor') {
                if (f.delay > 0) { f.delay -= dt; continue; }
                f.life -= dt;
                if (f.life <= 0.35 && !f.hit) { f.hit = true; this.particles.emit(f.x, f.y, 10, { color: '#ff4500', minS: 50, maxS: 140 }); for (const e of this.enemies) { if (Math.hypot(f.x - e.x, f.y - e.y) < f.radius) { if (e.takeDmg(f.dmg, this)) this.killEnemy(e); } } }
                if (f.life <= 0) this.fx.splice(i, 1);
            }
            else if (f.type === 'tornado') {
                f.x += f.vx * dt; f.y += f.vy * dt; f.life -= dt;
                for (const e of this.enemies) { if (Math.hypot(f.x - e.x, f.y - e.y) < f.radius + e.width / 2) { e.takeDmg(f.dmg * dt, this); e.slow = f.slow; e.slowT = 0.35; } }
                if (f.life <= 0) this.fx.splice(i, 1);
            }
        }
        
        // Pickups
        for (let i = this.pickups.length - 1; i >= 0; i--) {
            const p = this.pickups[i];
            p.update(dt);
            const d = Math.hypot(p.x - this.player.x, p.y - this.player.y);
            if (d < this.player.pickupRange * 1.8) { const a = Math.atan2(this.player.y - p.y, this.player.x - p.x); const s = 200 * (1 - d / (this.player.pickupRange * 1.8)); p.x += Math.cos(a) * s * dt; p.y += Math.sin(a) * s * dt; }
            if (d < this.player.pickupRange) {
                if (p.type === 'xp') { this.player.xp += p.val * this.player.xpMult * (1 + this.player.curse * 0.4); this.audio.pickup(); this.checkLevelUp(); }
                else { this.player.gold += Math.round(p.val * this.player.goldMult); this.audio.pickup(); }
                this.pickups.splice(i, 1);
            }
        }
        
        // Item drops
        for (let i = this.items.length - 1; i >= 0; i--) {
            const item = this.items[i];
            item.update(dt);
            if (Math.hypot(item.x - this.player.x, item.y - this.player.y) < 22) {
                this.showItemPickup(item);
                this.items.splice(i, 1);
            }
        }
        
        this.texts = this.texts.filter(t => { t.update(dt); return t.life > 0; });
        this.particles.update(dt);
        
        // Update sprite effects
        this.spriteEffects = this.spriteEffects.filter(e => { e.update(dt); return !e.done; });
        
        this.updateHUD();
        this.updateSlots();
    }
    
    spawnEnemy() {
        const a = Math.random() * Math.PI * 2, d = 420 + Math.random() * 70;
        const x = this.player.x + Math.cos(a) * d, y = this.player.y + Math.sin(a) * d;
        const avail = Object.entries(ENEMIES).filter(([, e]) => this.time >= e.time);
        const weights = avail.map((_, i) => Math.pow(1.7, i)), total = weights.reduce((s, w) => s + w, 0);
        let r = Math.random() * total, type = avail[0][0];
        for (let i = 0; i < weights.length; i++) { r -= weights[i]; if (r <= 0) { type = avail[i][0]; break; } }
        this.enemies.push(new Enemy(x, y, type, this.time, this.player.enemyBuff));
        if (ENEMIES[type].pack) for (let i = 0; i < 2; i++) this.enemies.push(new Enemy(x + (Math.random() - 0.5) * 35, y + (Math.random() - 0.5) * 35, type, this.time, this.player.enemyBuff));
    }
    
    killEnemy(enemy) {
        this.player.kills++;
        this.audio.pickup();
        this.particles.blood(enemy.x, enemy.y);
        
        // Add death effect
        this.spriteEffects.push(new SpriteEffect(enemy.x, enemy.y, 'fx_explosion', 32, 32, 7, 0.4, 1.5));
        
        this.pickups.push(new Pickup(enemy.x, enemy.y, 'xp', enemy.xp));
        if (Math.random() < 0.18) this.pickups.push(new Pickup(enemy.x + (Math.random() - 0.5) * 12, enemy.y + (Math.random() - 0.5) * 12, 'gold', 1 + Math.floor(this.time / 55)));
        if (Math.random() < 0.012 * this.player.luck) this.dropItem(enemy.x, enemy.y);
    }
    
    dropItem(x, y) {
        const r = Math.random() * 100 / this.player.luck;
        let rarity = r < 5 ? 'LEGENDARY' : r < 16 ? 'RARE' : 'COMMON';
        const pool = Object.entries(ITEMS).filter(([, i]) => i.rarity === rarity);
        if (pool.length > 0) { const [id] = pool[Math.floor(Math.random() * pool.length)]; this.items.push(new ItemDrop(x, y, id)); }
    }
    
    showItemPickup(drop) {
        this.state = 'itemPickup';
        this.pendingItem = drop;
        const item = ITEMS[drop.id];
        const rar = RARITY[item.rarity];
        
        document.getElementById('itemIcon').textContent = item.icon;
        document.getElementById('itemName').textContent = item.name;
        document.getElementById('itemName').style.color = rar.color;
        document.getElementById('itemRarity').textContent = rar.name;
        document.getElementById('itemRarity').style.background = rar.color + '30';
        document.getElementById('itemRarity').style.color = rar.color;
        document.getElementById('itemDesc').textContent = item.desc;
        
        document.getElementById('itemPickupModal').style.display = 'flex';
        this.audio.itemDrop();
    }
    
    continueFromItem() {
        document.getElementById('itemPickupModal').style.display = 'none';
        if (this.pendingItem) {
            this.collectItem(this.pendingItem);
            this.pendingItem = null;
        }
        this.state = 'playing';
    }
    
    collectItem(drop) {
        const item = ITEMS[drop.id];
        switch (item.effect) {
            case 'heal': 
                this.player.hp = Math.min(this.player.maxHp, this.player.hp + item.val); 
                this.texts.push(new FloatText(this.player.x, this.player.y - 18, `+${item.val} HP`, '#0f0')); 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_heal', 24, 24, 6, 0.5, 2));
                break;
            case 'fullHeal': 
                this.player.maxHp += item.val; 
                this.player.hp = this.player.maxHp; 
                this.texts.push(new FloatText(this.player.x, this.player.y - 18, 'Ø´ÙØ§Ø¡ ÙƒØ§Ù…Ù„!', '#0f0', 16)); 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_heal', 24, 24, 6, 0.6, 2.5));
                break;
            case 'gold': 
                this.player.gold += Math.round(item.val * this.player.goldMult); 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_spark', 24, 24, 5, 0.3, 1.5));
                break;
            case 'tempSpeed': 
                this.player.tempBuffs.push({ type: 'speed', val: item.val, dur: item.dur }); 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_magic', 24, 24, 5, 0.4, 1.8));
                break;
            case 'tempDmg': 
                this.player.tempBuffs.push({ type: 'dmg', val: item.val, dur: item.dur }); 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_fire_small', 24, 24, 6, 0.4, 1.8));
                break;
            case 'tempAtkSpd': 
                this.player.tempBuffs.push({ type: 'atkSpd', val: item.val, dur: item.dur }); 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_spark', 24, 24, 5, 0.4, 1.8));
                break;
            case 'shield': 
                this.player.shield += item.val; 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_circle', 24, 24, 5, 0.5, 2));
                break;
            case 'slow': 
                this.globalSlow = item.dur; 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_ice', 24, 24, 5, 0.5, 2));
                break;
            case 'revive': 
                this.player.hasRevive = true; 
                this.texts.push(new FloatText(this.player.x, this.player.y - 18, 'Ø¥Ø­ÙŠØ§Ø¡ Ù…Ø­ÙÙˆØ¸!', '#ffd700')); 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_magic', 24, 24, 5, 0.6, 2.5));
                break;
            case 'permGold': 
                this.player.goldMult += item.val; 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_spark', 24, 24, 5, 0.4, 2));
                break;
            case 'randomEquip': 
                this.giveRandomEquip(); 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_magic', 24, 24, 5, 0.5, 2.5));
                break;
            case 'moreEnemies': 
                this.player.extraEnemySpawn += item.val; 
                this.texts.push(new FloatText(this.player.x, this.player.y - 18, 'Ø£Ø¹Ø¯Ø§Ø¡ Ø£ÙƒØ«Ø±!', '#f44')); 
                break;
        }
    }
    
    giveRandomEquip() {
        if (Math.random() < 0.5 && this.player.weapons.length < CONFIG.MAX_WEAPONS) {
            const avail = Object.keys(WEAPONS).filter(w => !this.player.weapons.find(pw => pw.id === w));
            if (avail.length > 0) { const id = avail[Math.floor(Math.random() * avail.length)]; this.player.weapons.push({ id, level: 1, upgrades: [] }); this.texts.push(new FloatText(this.player.x, this.player.y - 30, `${WEAPONS[id].name}!`, '#ffd700', 16)); }
        } else if (this.player.books.length < CONFIG.MAX_BOOKS) {
            const avail = Object.keys(BOOKS).filter(b => !this.player.books.find(pb => pb.id === b));
            if (avail.length > 0) { const id = avail[Math.floor(Math.random() * avail.length)]; this.player.books.push({ id, level: 1, upgrades: [] }); this.applyBook(id, 1, RARITY.COMMON); this.texts.push(new FloatText(this.player.x, this.player.y - 30, `${BOOKS[id].name}!`, '#ffd700', 16)); }
        }
    }
    
    checkLevelUp() {
        const req = Math.floor(10 * Math.pow(1.35, this.player.level - 1));
        if (this.player.xp >= req) { this.player.xp -= req; this.player.level++; this.player.hp = Math.min(this.player.maxHp, this.player.hp + this.player.maxHp * 0.12); this.audio.levelUp(); this.showLevelUp(); }
    }
    
    showLevelUp() {
        this.state = 'levelup';
        const modal = document.getElementById('levelUpModal'), opts = document.getElementById('upgradeOptions');
        const choices = [];
        const aw = []; for (const w of this.player.weapons) { if (w.level < CONFIG.MAX_UPGRADE_LEVEL) aw.push({ type: 'weapon', id: w.id, isNew: false }); }
        if (this.player.weapons.length < CONFIG.MAX_WEAPONS) Object.keys(WEAPONS).filter(w => !this.player.weapons.find(pw => pw.id === w)).forEach(w => aw.push({ type: 'weapon', id: w, isNew: true }));
        const ab = []; for (const b of this.player.books) { if (b.level < CONFIG.MAX_UPGRADE_LEVEL) ab.push({ type: 'book', id: b.id, isNew: false }); }
        if (this.player.books.length < CONFIG.MAX_BOOKS) Object.keys(BOOKS).filter(b => !this.player.books.find(pb => pb.id === b)).forEach(b => ab.push({ type: 'book', id: b, isNew: true }));
        const all = [...aw, ...ab];
        while (choices.length < 3 && all.length > 0) choices.push(all.splice(Math.floor(Math.random() * all.length), 1)[0]);
        opts.innerHTML = '';
        choices.forEach(c => {
            const rar = getRandomRarity();
            const card = document.createElement('div');
            card.className = 'upgrade-card';
            card.style.borderColor = rar.color;
            card.style.boxShadow = `0 0 12px ${rar.color}35`;
            const data = c.type === 'weapon' ? WEAPONS[c.id] : BOOKS[c.id];
            const lvl = c.isNew ? 0 : (c.type === 'weapon' ? this.player.weapons : this.player.books).find(x => x.id === c.id).level;
            card.innerHTML = `<div class="upgrade-icon">${data.icon}</div><div class="upgrade-name" style="color:${rar.color}">${data.name}</div><div class="upgrade-type">${c.type === 'weapon' ? 'Ø³Ù„Ø§Ø­' : 'ÙƒØªØ§Ø¨'}</div><div class="upgrade-level">${c.isNew ? 'Ø¬Ø¯ÙŠØ¯!' : `${lvl} â†’ ${lvl + 1}`}</div><div class="upgrade-desc">${data.desc}</div><div class="upgrade-rarity" style="background:${rar.color}20;color:${rar.color}">${rar.name} (+${rar.bonus})</div>`;
            card.onclick = () => { this.selectUpgrade(c, rar); modal.style.display = 'none'; this.state = 'playing'; };
            opts.appendChild(card);
        });
        modal.style.display = 'flex';
    }
    
    selectUpgrade(c, rar) {
        if (c.type === 'weapon') {
            if (c.isNew) this.player.weapons.push({ id: c.id, level: 1, upgrades: [{ rarity: rar }] });
            else { const w = this.player.weapons.find(x => x.id === c.id); w.level++; w.upgrades.push({ rarity: rar }); }
        } else {
            if (c.isNew) { this.player.books.push({ id: c.id, level: 1, upgrades: [{ rarity: rar }] }); this.applyBook(c.id, 1, rar); }
            else { const b = this.player.books.find(x => x.id === c.id); b.level++; b.upgrades.push({ rarity: rar }); this.applyBook(c.id, b.level, rar); }
        }
        this.updateSlots();
    }
    
    applyBook(id, level, rar) {
        const book = BOOKS[id], v = book.val * (1 + rar.bonus * 0.12);
        switch (book.stat) {
            case 'damage': this.player.dmgMult += v; break;
            case 'atkSpd': this.player.atkSpd += v; break;
            case 'moveSpd': this.player.speed += this.player.speed * v; break;
            case 'xp': this.player.xpMult += v; break;
            case 'maxHp': const inc = this.player.maxHp * v; this.player.maxHp += inc; this.player.hp += inc; break;
            case 'armor': this.player.armor += v * 6; break;
            case 'pickup': this.player.pickupRange += this.player.pickupRange * v; break;
            case 'luck': this.player.luck += v; break;
            case 'curse': this.player.curse += v; break;
            case 'regen': this.player.regen += v; break;
        }
    }
    
    over(victory) {
        this.state = 'gameover';
        this.audio.stopBGM(); // Stop background music
        document.getElementById('hud').style.display = 'none';
        document.getElementById('equipmentSlots').style.display = 'none';
        document.getElementById('pauseBtn').style.display = 'none';
        const title = document.getElementById('gameOverTitle'), unlock = document.getElementById('unlockMessage');
        if (victory) { this.audio.victory(); title.textContent = 'ğŸ‰ Ø§Ù†ØªØµØ§Ø±! ğŸ‰'; title.className = 'game-over-title victory-title'; if (!this.baghdadUnlocked) { this.baghdadUnlocked = true; localStorage.setItem('baghdadUnlocked', 'true'); unlock.textContent = 'ğŸ”“ ØªÙ… ÙØªØ­ Ø®Ø±ÙŠØ·Ø© Ø¨ØºØ¯Ø§Ø¯!'; unlock.style.display = 'block'; } else unlock.style.display = 'none'; }
        else { this.audio.death(); title.textContent = 'Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©'; title.className = 'game-over-title'; unlock.style.display = 'none'; }
        if (this.player.kills > this.highScore) { this.highScore = this.player.kills; localStorage.setItem('goldBloodHighScore', this.highScore.toString()); document.getElementById('highScore').textContent = this.highScore; }
        const m = Math.floor(this.time / 60), s = Math.floor(this.time % 60);
        document.getElementById('finalStats').innerHTML = `<p>â±ï¸ ${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}</p><p>â­ Ø§Ù„Ù…Ø³ØªÙˆÙ‰: ${this.player.level}</p><p>ğŸ’€ Ø§Ù„Ù‚ØªÙ„Ù‰: ${this.player.kills}</p><p>ğŸ’° Ø§Ù„Ø°Ù‡Ø¨: ${this.player.gold}</p>`;
        document.getElementById('gameOverScreen').style.display = 'flex';
    }
    
    updateHUD() {
        document.getElementById('healthBar').style.width = `${(this.player.hp / this.player.maxHp) * 100}%`;
        document.getElementById('healthText').textContent = `${Math.ceil(this.player.hp)}/${Math.ceil(this.player.maxHp)}`;
        const req = Math.floor(10 * Math.pow(1.35, this.player.level - 1));
        document.getElementById('xpBar').style.width = `${(this.player.xp / req) * 100}%`;
        document.getElementById('xpText').textContent = `${Math.floor(this.player.xp)}/${req}`;
        document.getElementById('levelText').textContent = `Ø§Ù„Ù…Ø³ØªÙˆÙ‰: ${this.player.level}`;
        document.getElementById('goldText').textContent = this.player.gold;
        document.getElementById('killText').textContent = this.player.kills;
        const m = Math.floor(this.time / 60), s = Math.floor(this.time % 60);
        document.getElementById('timerText').textContent = `â±ï¸ ${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    }
    
    draw() {
        const ctx = this.ctx;
        ctx.fillStyle = this.city === 'baghdad' ? '#7a9a7a' : '#d4b896';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        if (this.state === 'menu') { this.drawMenuBg(); return; }
        if (['playing', 'paused', 'levelup', 'itemPickup', 'gameover'].includes(this.state)) this.drawGame();
    }
    
    drawMenuBg() {
        const ctx = this.ctx, t = Date.now() / 1000;
        for (let i = 0; i < 4; i++) { const y = this.canvas.height * 0.45 + i * 60; ctx.fillStyle = `rgba(${45 + i * 7}, ${35 + i * 4}, ${22 + i * 3}, 0.35)`; ctx.beginPath(); ctx.moveTo(0, y); for (let x = 0; x <= this.canvas.width; x += 35) ctx.lineTo(x, y + Math.sin(x * 0.007 + t + i) * 12); ctx.lineTo(this.canvas.width, this.canvas.height); ctx.lineTo(0, this.canvas.height); ctx.fill(); }
    }
    
    drawGame() {
        const ctx = this.ctx;
        this.drawBg();
        this.particles.draw(ctx, this.cam);
        for (const p of this.pickups) p.draw(ctx, this.cam, this.assets);
        for (const i of this.items) i.draw(ctx, this.cam, this.assets);
        
        // Draw effects
        for (const f of this.fx) {
            const sx = f.x - this.cam.x, sy = f.y - this.cam.y;
            if (f.type === 'lightning') { 
                ctx.strokeStyle = `rgba(255, 255, 100, ${f.life / 0.2})`; 
                ctx.lineWidth = 3; 
                ctx.beginPath(); 
                ctx.moveTo(sx, sy - 350); 
                // Zigzag lightning
                for (let i = 0; i < 10; i++) {
                    ctx.lineTo(sx + (Math.random() - 0.5) * 30, sy - 350 + i * 35);
                }
                ctx.lineTo(sx, sy); 
                ctx.stroke(); 
                ctx.fillStyle = `rgba(255, 255, 160, ${f.life / 0.2 * 0.4})`; 
                ctx.beginPath(); 
                ctx.arc(sx, sy, 25, 0, Math.PI * 2); 
                ctx.fill(); 
            }
            else if (f.type === 'meteor' && f.delay <= 0) { 
                if (f.life > 0.35) { 
                    ctx.strokeStyle = 'rgba(255, 70, 0, 0.4)'; 
                    ctx.lineWidth = 2; 
                    ctx.beginPath(); 
                    ctx.arc(sx, sy, f.radius, 0, Math.PI * 2); 
                    ctx.stroke(); 
                    // Incoming meteor visual
                    ctx.fillStyle = 'rgba(255, 100, 0, 0.6)';
                    ctx.beginPath();
                    ctx.arc(sx, sy - (f.life - 0.35) * 200, 12, 0, Math.PI * 2);
                    ctx.fill();
                } else { 
                    ctx.fillStyle = 'rgba(255, 70, 0, 0.3)'; 
                    ctx.beginPath(); 
                    ctx.arc(sx, sy, f.radius * (1 - f.life / 0.35), 0, Math.PI * 2); 
                    ctx.fill(); 
                } 
            }
            else if (f.type === 'tornado') { 
                ctx.strokeStyle = 'rgba(160, 140, 110, 0.5)'; 
                ctx.lineWidth = 2; 
                for (let i = 0; i < 3; i++) { 
                    ctx.beginPath(); 
                    ctx.arc(sx, sy, f.radius - i * 8, 0, Math.PI * 2); 
                    ctx.stroke(); 
                } 
            }
        }
        
        // Draw enemies with sprites
        for (const e of this.enemies) e.draw(ctx, this.cam, this.assets);
        if (this.boss) this.boss.draw(ctx, this.cam, this.assets);
        
        // Draw player with sprite
        this.player.draw(ctx, this.cam, this.assets);
        
        // Draw projectiles with better visuals
        for (const p of this.proj) { 
            const px = p.x - this.cam.x, py = p.y - this.cam.y;
            
            if (p.type === 'fire') {
                // Fire projectile with glow (no shadow for performance)
                ctx.fillStyle = '#ff4500';
                ctx.beginPath();
                ctx.arc(px, py, p.size + 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ff6600';
                ctx.beginPath();
                ctx.arc(px, py, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ffcc00';
                ctx.beginPath();
                ctx.arc(px, py, p.size * 0.5, 0, Math.PI * 2);
                ctx.fill();
            } else {
                ctx.fillStyle = p.color; 
                ctx.beginPath(); 
                ctx.arc(px, py, p.size, 0, Math.PI * 2); 
                ctx.fill();
            } else if (e.type === 'meteor' && e.delay <= 0) {
                if (e.life > 0.4) {
                    ctx.strokeStyle = 'rgba(255, 80, 0, 0.4)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(sx, sy, e.radius, 0, Math.PI * 2);
                    ctx.stroke();
                } else {
                    ctx.fillStyle = 'rgba(255, 80, 0, 0.25)';
                    ctx.beginPath();
                    ctx.arc(sx, sy, e.radius * (1 - e.life / 0.4), 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (e.type === 'tornado') {
                ctx.strokeStyle = 'rgba(180, 160, 130, 0.5)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.arc(sx, sy, e.radius - i * 8, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            
            // Trail effect
            ctx.globalAlpha = 0.35;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(px - p.vx * 0.015, py - p.vy * 0.015, p.size * 0.65, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 0.2;
            ctx.beginPath();
            ctx.arc(px - p.vx * 0.03, py - p.vy * 0.03, p.size * 0.4, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
        for (const p of this.eProj) { 
            ctx.fillStyle = p.color; 
            ctx.beginPath(); 
            ctx.arc(p.x - this.cam.x, p.y - this.cam.y, p.size, 0, Math.PI * 2); 
            ctx.fill(); 
        }
        for (const t of this.texts) t.draw(ctx, this.cam);
        
        // Draw sprite effects
        for (const e of this.spriteEffects) e.draw(ctx, this.cam, this.assets);
        
        this.drawLighting();
        
        // Virtual joystick for mobile
        if (this.input.joy) { 
            ctx.fillStyle = 'rgba(255, 255, 255, 0.12)'; 
            ctx.beginPath(); 
            ctx.arc(80, this.canvas.height - 80, 55, 0, Math.PI * 2); 
            ctx.fill(); 
            ctx.fillStyle = 'rgba(255, 215, 0, 0.35)'; 
            ctx.beginPath(); 
            ctx.arc(80 + this.input.joy.x * 35, this.canvas.height - 80 + this.input.joy.y * 35, 20, 0, Math.PI * 2); 
            ctx.fill(); 
        }
        
        // Boss health bar
        if (this.boss) {
            const bw = Math.min(350, this.canvas.width * 0.8), bx = (this.canvas.width - bw) / 2;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; 
            ctx.fillRect(bx - 3, 44, bw + 6, 26);
            ctx.fillStyle = '#222'; 
            ctx.fillRect(bx, 47, bw, 20);
            const hpColor = this.boss.phase === 3 ? '#ff0000' : this.boss.phase === 2 ? '#ff6600' : '#ffcc00';
            ctx.fillStyle = hpColor;
            ctx.fillRect(bx, 47, bw * (this.boss.hp / this.boss.maxHp), 20);
            ctx.fillStyle = '#fff'; 
            ctx.font = 'bold 12px Cairo'; 
            ctx.textAlign = 'center';
            ctx.fillText(`ğŸ‘¹ ${BOSS.name} - Ø§Ù„Ù…Ø±Ø­Ù„Ø© ${this.boss.phase}`, this.canvas.width / 2, 42);
        }
    }
    
    drawBg() {
        const ctx = this.ctx, ts = CONFIG.TILE_SIZE;
        const sandTile = this.assets.get('sand_tile');
        
        // If we have the sand tile, use it as a repeating pattern
        if (sandTile && this.city === 'badaya') {
            ctx.save();
            ctx.translate(-this.cam.x % ts, -this.cam.y % ts);
            
            if (!this.sandTilePattern) {
                this.sandTilePattern = ctx.createPattern(sandTile, 'repeat');
            }
            
            if (this.sandTilePattern) {
                ctx.fillStyle = this.sandTilePattern;
                ctx.fillRect(0, 0, this.canvas.width + ts * 2, this.canvas.height + ts * 2);
            }
            ctx.restore();
            
            // Add some decorations on top
            const sx = Math.floor(this.cam.x / ts) - 1, sy = Math.floor(this.cam.y / ts) - 1;
            const ex = Math.ceil((this.cam.x + this.canvas.width) / ts) + 1, ey = Math.ceil((this.cam.y + this.canvas.height) / ts) + 1;
            
            for (let y = sy; y <= ey; y++) {
                for (let x = sx; x <= ex; x++) {
                    const px = x * ts - this.cam.x, py = y * ts - this.cam.y;
                    const seed = Math.abs(Math.sin(x * 12.9898 + y * 78.233) * 43758.5453) % 1;
                    
                    // Rocks
                    if (seed < 0.008) { 
                        ctx.fillStyle = '#6a6050'; 
                        ctx.beginPath(); 
                        ctx.arc(px + ts / 2, py + ts / 2, 5 + seed * 8, 0, Math.PI * 2); 
                        ctx.fill(); 
                    }
                    // Palm trees
                    else if (seed < 0.018) { 
                        // Trunk
                        ctx.fillStyle = '#5a3520'; 
                        ctx.fillRect(px + ts / 2 - 3, py + ts / 2 - 16, 6, 20); 
                        // Leaves
                        ctx.fillStyle = '#3a6a28'; 
                        for (let i = 0; i < 5; i++) { 
                            ctx.beginPath(); 
                            ctx.ellipse(px + ts / 2 + Math.cos(i * 1.3) * 12, py + ts / 2 - 18 + Math.sin(i * 1.3) * 6, 10, 4, i * 0.8, 0, Math.PI * 2); 
                            ctx.fill(); 
                        } 
                    }
                    // Small bushes
                    else if (seed < 0.028) {
                        ctx.fillStyle = '#5a7a48';
                        ctx.beginPath();
                        ctx.arc(px + ts / 2, py + ts / 2, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        } else {
            // Fallback for no tile or Baghdad
            const sx = Math.floor(this.cam.x / ts) - 1, sy = Math.floor(this.cam.y / ts) - 1;
            const ex = Math.ceil((this.cam.x + this.canvas.width) / ts) + 1, ey = Math.ceil((this.cam.y + this.canvas.height) / ts) + 1;
            
            for (let y = sy; y <= ey; y++) {
                for (let x = sx; x <= ex; x++) {
                    const px = x * ts - this.cam.x, py = y * ts - this.cam.y;
                    const n = Math.sin(x * 0.35) * Math.cos(y * 0.35) * 0.07;
                    let r = 210, g = 180, b = 140;
                    if (this.city === 'baghdad') { r = 130; g = 170; b = 130; }
                    ctx.fillStyle = `rgb(${Math.floor(r + n * 22)}, ${Math.floor(g + n * 18)}, ${Math.floor(b + n * 12)})`;
                    ctx.fillRect(px, py, ts + 1, ts + 1);
                    
                    const seed = Math.abs(Math.sin(x * 12.9898 + y * 78.233) * 43758.5453) % 1;
                    if (seed < 0.012) { 
                        ctx.fillStyle = '#555'; 
                        ctx.beginPath(); 
                        ctx.arc(px + ts / 2, py + ts / 2, 4 + seed * 5, 0, Math.PI * 2); 
                        ctx.fill(); 
                    }
                    else if (this.city === 'badaya' && seed < 0.022) { 
                        ctx.fillStyle = '#3a2518'; 
                        ctx.fillRect(px + ts / 2 - 2, py + ts / 2 - 12, 4, 16); 
                        ctx.fillStyle = '#2a4a18'; 
                        for (let i = 0; i < 4; i++) { 
                            ctx.beginPath(); 
                            ctx.ellipse(px + ts / 2 + Math.cos(i * 1.4) * 9, py + ts / 2 - 14 + Math.sin(i * 1.4) * 4, 7, 3, i * 0.7, 0, Math.PI * 2); 
                            ctx.fill(); 
                        } 
                    }
                    else if (this.city === 'baghdad' && seed < 0.035) { 
                        ctx.fillStyle = '#3a5a30'; 
                        for (let i = 0; i < 3; i++) ctx.fillRect(px + ts / 3 + i * 7, py + ts / 2, 1.5, 6); 
                    }
                }
            }
        }
    }
    
    drawLighting() {
        // Subtle vignette effect only - no heavy darkness
        const ctx = this.ctx;
        const cx = this.canvas.width / 2, cy = this.canvas.height / 2;
        const maxDist = Math.max(this.canvas.width, this.canvas.height) * 0.7;
        
        // Very subtle edge darkening (vignette)
        const vignette = ctx.createRadialGradient(cx, cy, maxDist * 0.5, cx, cy, maxDist);
        vignette.addColorStop(0, 'rgba(0, 0, 0, 0)');
        vignette.addColorStop(1, 'rgba(0, 0, 0, 0.15)');
        ctx.fillStyle = vignette;
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Warm tint overlay
        ctx.fillStyle = 'rgba(255, 200, 100, 0.02)';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }
}

window.addEventListener('load', () => new Game());
    </script>
</body>
</html>
