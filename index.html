<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>ÿ∞Ÿáÿ® ÿ£ÿµŸÅÿ± ÿ£Ÿà ÿØŸÖ ÿ£ÿ≠ŸÖÿ± - Gold or Blood</title>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700;900&family=Changa:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }
        
        body {
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0f0f1a 100%);
            font-family: 'Cairo', 'Changa', sans-serif;
            overflow: hidden;
            min-height: 100vh;
            color: #fff;
        }
        
        #gameCanvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        
        /* Rarity Colors */
        .rarity-common { color: #9d9d9d; border-color: #9d9d9d !important; }
        .rarity-uncommon { color: #1eff00; border-color: #1eff00 !important; }
        .rarity-rare { color: #0070dd; border-color: #0070dd !important; }
        .rarity-epic { color: #a335ee; border-color: #a335ee !important; }
        .rarity-legendary { color: #ff8000; border-color: #ff8000 !important; }
        
        .rarity-glow-common { box-shadow: 0 0 10px rgba(157, 157, 157, 0.5); }
        .rarity-glow-uncommon { box-shadow: 0 0 15px rgba(30, 255, 0, 0.5); }
        .rarity-glow-rare { box-shadow: 0 0 20px rgba(0, 112, 221, 0.5); }
        .rarity-glow-epic { box-shadow: 0 0 25px rgba(163, 53, 238, 0.5); }
        .rarity-glow-legendary { box-shadow: 0 0 30px rgba(255, 128, 0, 0.7); animation: legendaryGlow 1.5s ease-in-out infinite alternate; }
        
        @keyframes legendaryGlow {
            from { box-shadow: 0 0 20px rgba(255, 128, 0, 0.5); }
            to { box-shadow: 0 0 40px rgba(255, 128, 0, 0.9); }
        }
        
        /* Main Menu Styles */
        #mainMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            background: linear-gradient(180deg, rgba(10,10,15,0.95) 0%, rgba(26,26,46,0.98) 100%);
            overflow-y: auto;
            padding: 20px;
        }
        
        .menu-title {
            font-size: clamp(1.8rem, 6vw, 3.5rem);
            font-weight: 900;
            text-align: center;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #ffd700 0%, #ff8c00 50%, #ffd700 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: titleGlow 2s ease-in-out infinite alternate;
        }
        
        .menu-subtitle {
            font-size: clamp(0.9rem, 3vw, 1.3rem);
            color: #cc0000;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(204, 0, 0, 0.7);
        }
        
        @keyframes titleGlow {
            from { filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.5)); }
            to { filter: drop-shadow(0 0 40px rgba(255, 215, 0, 0.8)); }
        }
        
        /* Character Selection */
        .character-carousel {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            padding: 15px;
            overflow-x: auto;
            max-width: 100%;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .character-card {
            min-width: 160px;
            max-width: 180px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 215, 0, 0.2);
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }
        
        .character-card:hover, .character-card.selected {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.1);
            transform: translateY(-5px);
            box-shadow: 0 15px 30px rgba(255, 215, 0, 0.2);
        }
        
        .character-card canvas {
            width: 80px;
            height: 80px;
            image-rendering: pixelated;
            margin-bottom: 10px;
        }
        
        .character-name {
            font-size: 1.1rem;
            font-weight: 700;
            color: #ffd700;
            margin-bottom: 5px;
        }
        
        .character-passive {
            font-size: 0.8rem;
            color: #88ff88;
            margin-bottom: 5px;
        }
        
        .character-weapon {
            font-size: 0.75rem;
            color: #ff8888;
        }
        
        /* Buttons */
        .btn {
            padding: 12px 40px;
            font-size: 1.2rem;
            font-family: 'Cairo', sans-serif;
            font-weight: 700;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%);
            color: #000;
            box-shadow: 0 10px 30px rgba(255, 215, 0, 0.4);
        }
        
        .btn-primary:hover {
            transform: scale(1.05);
            box-shadow: 0 15px 40px rgba(255, 215, 0, 0.6);
        }
        
        /* HUD Styles */
        #hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px 15px;
            display: none;
            justify-content: space-between;
            align-items: flex-start;
            z-index: 50;
            pointer-events: none;
        }
        
        .hud-left, .hud-right {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .hud-bar {
            width: 180px;
            height: 22px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.2);
            position: relative;
        }
        
        .hud-bar-fill {
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 12px;
        }
        
        .hud-bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.7rem;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
        }
        
        .health-fill {
            background: linear-gradient(90deg, #ff4444 0%, #ff0000 100%);
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
        }
        
        .xp-fill {
            background: linear-gradient(90deg, #44ff44 0%, #00ff00 100%);
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }
        
        .hud-stat {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.95rem;
            font-weight: 700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }
        
        .gold-text { color: #ffd700; }
        .kill-text { color: #ff4444; }
        .level-text { color: #44ff44; }
        
        /* Equipment Slots */
        .equipment-slots {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            gap: 10px;
            z-index: 50;
            pointer-events: none;
        }
        
        .slot-group {
            display: flex;
            gap: 5px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
        }
        
        .slot-group-label {
            position: absolute;
            top: -18px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.7rem;
            color: #aaa;
        }
        
        .equipment-slot {
            width: 45px;
            height: 45px;
            background: rgba(50, 50, 50, 0.8);
            border: 2px solid #444;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .equipment-slot canvas {
            width: 35px;
            height: 35px;
            image-rendering: pixelated;
        }
        
        .slot-level {
            position: absolute;
            bottom: -2px;
            right: -2px;
            background: #000;
            color: #fff;
            font-size: 0.6rem;
            padding: 1px 4px;
            border-radius: 4px;
            font-weight: bold;
        }
        
        /* Level Up Modal */
        #levelUpModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        
        .level-up-content {
            text-align: center;
            padding: 30px;
            background: rgba(20, 20, 30, 0.95);
            backdrop-filter: blur(20px);
            border: 3px solid #ffd700;
            border-radius: 25px;
            max-width: 95%;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .level-up-title {
            font-size: 2rem;
            color: #ffd700;
            margin-bottom: 25px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        }
        
        .upgrade-options {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .upgrade-card {
            width: 180px;
            padding: 15px;
            background: rgba(30, 30, 40, 0.9);
            border: 3px solid #444;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }
        
        .upgrade-card:hover {
            transform: scale(1.05);
        }
        
        .upgrade-card canvas {
            width: 60px;
            height: 60px;
            image-rendering: pixelated;
            margin-bottom: 10px;
        }
        
        .upgrade-name {
            font-size: 1rem;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .upgrade-type {
            font-size: 0.75rem;
            color: #888;
            margin-bottom: 5px;
        }
        
        .upgrade-level {
            font-size: 0.8rem;
            margin-bottom: 5px;
        }
        
        .upgrade-desc {
            font-size: 0.75rem;
            color: #aaa;
        }
        
        .upgrade-rarity {
            font-size: 0.7rem;
            font-weight: bold;
            margin-top: 8px;
            padding: 3px 8px;
            border-radius: 10px;
            display: inline-block;
        }
        
        /* Game Over Screen */
        #gameOverScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
        }
        
        .game-over-title {
            font-size: 2.5rem;
            color: #ff0000;
            margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(255, 0, 0, 0.8);
        }
        
        .victory-title {
            color: #ffd700 !important;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.8) !important;
        }
        
        .final-stats {
            margin-bottom: 25px;
            font-size: 1.1rem;
            line-height: 1.8;
        }
        
        /* Boss Warning */
        #bossWarning {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5rem;
            color: #ff0000;
            text-shadow: 0 0 30px rgba(255, 0, 0, 0.8);
            display: none;
            z-index: 150;
            text-align: center;
            animation: bossWarn 0.5s ease-in-out infinite alternate;
        }
        
        @keyframes bossWarn {
            from { transform: translate(-50%, -50%) scale(1); }
            to { transform: translate(-50%, -50%) scale(1.1); }
        }
        
        /* Pause indicator */
        #pauseIndicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5rem;
            color: #ffd700;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
            display: none;
            z-index: 150;
        }
        
        /* Item Pickup Notification */
        .item-notification {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            font-size: 1rem;
            z-index: 160;
            animation: itemNotify 2s ease-out forwards;
        }
        
        @keyframes itemNotify {
            0% { opacity: 0; transform: translateX(-50%) translateY(20px); }
            20% { opacity: 1; transform: translateX(-50%) translateY(0); }
            80% { opacity: 1; }
            100% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
        }
        
        /* Mobile optimization */
        @media (max-width: 768px) {
            .character-card {
                min-width: 140px;
                padding: 10px;
            }
            
            .hud-bar {
                width: 140px;
                height: 18px;
            }
            
            .upgrade-card {
                width: 150px;
                padding: 12px;
            }
            
            .equipment-slot {
                width: 40px;
                height: 40px;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <!-- Main Menu -->
    <div id="mainMenu">
        <h1 class="menu-title">ÿ∞Ÿáÿ® ÿ£ÿµŸÅÿ± ÿ£Ÿà ÿØŸÖ ÿ£ÿ≠ŸÖÿ±</h1>
        <p class="menu-subtitle">Gold or Blood - Survive 10 Minutes!</p>
        
        <div class="character-carousel" id="characterCarousel"></div>
        
        <button class="btn btn-primary" id="startBtn">ÿßÿ®ÿØÿ£ ÿßŸÑŸÑÿπÿ®</button>
        <p style="margin-top: 15px; font-size: 0.8rem; color: #666;">ÿ£ÿπŸÑŸâ ŸÜÿ™Ÿäÿ¨ÿ©: <span id="highScore">0</span> ŸÇÿ™ŸäŸÑ</p>
    </div>
    
    <!-- HUD -->
    <div id="hud">
        <div class="hud-left">
            <div class="hud-bar">
                <div class="hud-bar-fill health-fill" id="healthBar" style="width: 100%"></div>
                <span class="hud-bar-text" id="healthText">100/100</span>
            </div>
            <div class="hud-bar">
                <div class="hud-bar-fill xp-fill" id="xpBar" style="width: 0%"></div>
                <span class="hud-bar-text" id="xpText">0/10</span>
            </div>
            <span class="hud-stat level-text" id="levelText">ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ: 1</span>
        </div>
        <div class="hud-right">
            <span class="hud-stat gold-text">üí∞ <span id="goldText">0</span></span>
            <span class="hud-stat kill-text">üíÄ <span id="killText">0</span></span>
            <span class="hud-stat" id="timerText">‚è±Ô∏è 00:00</span>
        </div>
    </div>
    
    <!-- Equipment Slots -->
    <div class="equipment-slots" id="equipmentSlots">
        <div class="slot-group" id="weaponSlots" style="position: relative;">
            <span class="slot-group-label">ÿ£ÿ≥ŸÑÿ≠ÿ©</span>
        </div>
        <div class="slot-group" id="bookSlots" style="position: relative;">
            <span class="slot-group-label">ŸÉÿ™ÿ®</span>
        </div>
    </div>
    
    <!-- Level Up Modal -->
    <div id="levelUpModal">
        <div class="level-up-content">
            <h2 class="level-up-title">üéâ ŸÖÿ≥ÿ™ŸàŸâ ÿ¨ÿØŸäÿØ! üéâ</h2>
            <div class="upgrade-options" id="upgradeOptions"></div>
        </div>
    </div>
    
    <!-- Game Over Screen -->
    <div id="gameOverScreen">
        <h1 class="game-over-title" id="gameOverTitle">ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑŸÑÿπÿ®ÿ©</h1>
        <div class="final-stats" id="finalStats"></div>
        <button class="btn btn-primary" id="restartBtn">ÿßŸÑÿπÿ® ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ</button>
    </div>
    
    <!-- Boss Warning -->
    <div id="bossWarning">
        ‚ö†Ô∏è ÿ™ÿ≠ÿ∞Ÿäÿ±! ‚ö†Ô∏è<br>
        <span style="font-size: 1.5rem;">ÿßŸÑÿ™ŸÜŸäŸÜ ÿßŸÑÿµÿ≠ÿ±ÿßŸàŸä ŸÇÿßÿØŸÖ!</span>
    </div>
    
    <!-- Pause Indicator -->
    <div id="pauseIndicator">‚è∏Ô∏è ÿ•ŸäŸÇÿßŸÅ ŸÖÿ§ŸÇÿ™</div>

    <script>
// ==================== GAME CONFIGURATION ====================
const CONFIG = {
    WORLD_SIZE: 5000,
    TILE_SIZE: 64,
    PLAYER_LIGHT_RADIUS: 280,
    MAX_WEAPONS: 4,
    MAX_BOOKS: 4,
    MAX_UPGRADE_LEVEL: 20,
    BOSS_TIME: 600, // 10 minutes in seconds
};

// ==================== RARITY SYSTEM ====================
const RARITY = {
    COMMON: { name: 'ÿ¥ÿßÿ¶ÿπ', nameEn: 'common', color: '#9d9d9d', multiplier: 1.05, weight: 50 },
    UNCOMMON: { name: 'ÿ∫Ÿäÿ± ÿ¥ÿßÿ¶ÿπ', nameEn: 'uncommon', color: '#1eff00', multiplier: 1.10, weight: 30 },
    RARE: { name: 'ŸÜÿßÿØÿ±', nameEn: 'rare', color: '#0070dd', multiplier: 1.20, weight: 15 },
    EPIC: { name: 'ŸÖŸÑÿ≠ŸÖŸä', nameEn: 'epic', color: '#a335ee', multiplier: 1.35, weight: 4 },
    LEGENDARY: { name: 'ÿ£ÿ≥ÿ∑Ÿàÿ±Ÿä', nameEn: 'legendary', color: '#ff8000', multiplier: 1.50, weight: 1 }
};

function getRandomRarity() {
    const total = Object.values(RARITY).reduce((sum, r) => sum + r.weight, 0);
    let rand = Math.random() * total;
    for (const rarity of Object.values(RARITY)) {
        rand -= rarity.weight;
        if (rand <= 0) return rarity;
    }
    return RARITY.COMMON;
}

// ==================== CHARACTERS DATA ====================
const CHARACTERS = {
    abuSulaiman: {
        name: 'ÿ£ÿ®Ÿà ÿ≥ŸÑŸäŸÖÿßŸÜ',
        title: 'ÿßŸÑÿ™ÿßÿ¨ÿ± ÿßŸÑÿ´ÿ±Ÿä',
        weapon: 'agal',
        passive: '+25% ÿ∞Ÿáÿ®ÿå +10% ÿ≠ÿ∏',
        stats: { goldMult: 1.25, luck: 1.1, health: 100, speed: 200 },
        colors: { primary: '#f5f5f5', secondary: '#cc0000', skin: '#d4a574', accent: '#8b6914' }
    },
    jayzen: {
        name: 'ÿ¨Ÿäÿ≤ÿßŸÜ',
        title: 'ÿßŸÑŸÖŸÇÿßÿ™ŸÑ ÿßŸÑÿ¥ÿ±ÿ≥',
        weapon: 'rock',
        passive: '-30% ÿ∂ÿ±ÿ±ÿå +15% HP',
        stats: { damageReduction: 0.3, health: 115, speed: 200 },
        colors: { primary: '#6a1b9a', secondary: '#cc3333', skin: '#d4a574', accent: '#333' }
    },
    noura: {
        name: 'ŸÜŸàÿ±ÿ©',
        title: 'ÿßŸÑŸÖÿ±ÿ£ÿ© ÿßŸÑŸÇŸàŸäÿ©',
        weapon: 'aura',
        passive: '+150% ŸÖÿ∫ŸÜÿßÿ∑Ÿäÿ≥ÿå +20% XP',
        stats: { pickupRange: 2.5, xpMult: 1.2, health: 100, speed: 200 },
        colors: { primary: '#1e88e5', secondary: '#f5f5f5', skin: '#e8d5c4', accent: '#1565c0' }
    },
    fahd: {
        name: 'ŸÅŸáÿØ',
        title: 'ÿßŸÑÿ®ÿØŸàŸä ÿßŸÑÿµŸäÿßÿØ',
        weapon: 'spear',
        passive: '+40% ÿ≥ÿ±ÿπÿ© Ÿáÿ¨ŸàŸÖÿå +20% ÿ≠ÿ±ŸÉÿ©',
        stats: { attackSpeed: 1.4, speed: 240, health: 90 },
        colors: { primary: '#8b4513', secondary: '#d2691e', skin: '#c4956a', accent: '#2f1810' }
    },
    sultan: {
        name: 'ÿ≥ŸÑÿ∑ÿßŸÜ',
        title: 'ÿßŸÑŸÅÿßÿ±ÿ≥',
        weapon: 'sword',
        passive: '+50% ÿ∂ÿ±ÿ± ŸÇÿ±Ÿäÿ®ÿå ÿØÿ±ÿπ',
        stats: { meleeDamage: 1.5, health: 120, speed: 180, shield: true },
        colors: { primary: '#ffd700', secondary: '#8b0000', skin: '#d4a574', accent: '#4a4a4a' }
    },
    layla: {
        name: 'ŸÑŸäŸÑŸâ',
        title: 'ÿßŸÑÿ≥ÿßÿ≠ÿ±ÿ©',
        weapon: 'flame',
        passive: '-20% ŸÉŸàŸÑÿØÿßŸàŸÜÿå +30% ŸÖÿØŸâ',
        stats: { cooldownReduction: 0.8, range: 1.3, health: 85, speed: 210 },
        colors: { primary: '#1a1a2e', secondary: '#4a0080', skin: '#e8d5c4', accent: '#00ffff' }
    }
};

// ==================== WEAPONS DATA ====================
const WEAPONS = {
    agal: {
        name: 'ÿßŸÑÿπŸÇÿßŸÑ',
        desc: 'ÿ≠ÿ®ŸÑ ŸäÿØŸàÿ± ÿ≠ŸàŸÑ ÿßŸÑŸÑÿßÿπÿ®',
        type: 'orbit',
        baseDamage: 8,
        baseCooldown: 0.1,
        baseRange: 70,
        icon: '‚≠ï'
    },
    rock: {
        name: 'ÿßŸÑÿµÿÆÿ±ÿ©',
        desc: 'ŸÇÿ∞ŸäŸÅÿ© ÿ™ÿ≥ÿ™ŸáÿØŸÅ ÿ£ŸÇÿ±ÿ® ÿπÿØŸà',
        type: 'projectile',
        baseDamage: 25,
        baseCooldown: 1.2,
        baseRange: 400,
        icon: 'ü™®'
    },
    aura: {
        name: 'ÿßŸÑŸáŸäÿ®ÿ©',
        desc: 'ŸáÿßŸÑÿ© ÿ∂ÿ±ÿ± ŸÖÿ≥ÿ™ŸÖÿ±',
        type: 'aura',
        baseDamage: 5,
        baseCooldown: 0.5,
        baseRange: 90,
        icon: 'üí´'
    },
    spear: {
        name: 'ÿßŸÑÿ±ŸÖÿ≠',
        desc: 'Ÿäÿ±ŸÖŸä ÿ®ÿßÿ™ÿ¨ÿßŸá ÿßŸÑÿ≠ÿ±ŸÉÿ©',
        type: 'directional',
        baseDamage: 18,
        baseCooldown: 0.6,
        baseRange: 350,
        icon: 'üî±'
    },
    sword: {
        name: 'ÿßŸÑÿ≥ŸäŸÅ',
        desc: 'ÿ∂ÿ±ÿ®ÿ© ŸÇŸàÿ≥Ÿäÿ© ÿ£ŸÖÿßŸÖŸäÿ©',
        type: 'melee',
        baseDamage: 30,
        baseCooldown: 0.8,
        baseRange: 80,
        icon: '‚öîÔ∏è'
    },
    flame: {
        name: 'ÿßŸÑÿ¥ÿπŸÑÿ©',
        desc: 'ŸÉÿ±ÿßÿ™ ŸÜÿßÿ±Ÿäÿ© ÿπÿ¥Ÿàÿßÿ¶Ÿäÿ©',
        type: 'random',
        baseDamage: 15,
        baseCooldown: 0.4,
        baseRange: 300,
        icon: 'üî•'
    },
    arrows: {
        name: 'ÿßŸÑÿ≥ŸáÿßŸÖ',
        desc: 'ÿ™ÿ∑ŸÑŸÇ ÿ®ŸÉŸÑ ÿßŸÑÿßÿ™ÿ¨ÿßŸáÿßÿ™',
        type: 'radial',
        baseDamage: 10,
        baseCooldown: 1.0,
        baseRange: 350,
        icon: 'üèπ'
    },
    lightning: {
        name: 'ÿßŸÑÿ®ÿ±ŸÇ',
        desc: 'ÿµÿßÿπŸÇÿ© ÿπŸÑŸâ ÿπÿØŸà ÿπÿ¥Ÿàÿßÿ¶Ÿä',
        type: 'lightning',
        baseDamage: 50,
        baseCooldown: 2.5,
        baseRange: 500,
        icon: '‚ö°'
    },
    tornado: {
        name: 'ÿßŸÑÿØŸàÿßŸÖÿ©',
        desc: 'ÿ•ÿπÿµÿßÿ± Ÿäÿ®ÿ∑ÿ¶ ÿßŸÑÿ£ÿπÿØÿßÿ°',
        type: 'tornado',
        baseDamage: 12,
        baseCooldown: 3.0,
        baseRange: 200,
        icon: 'üå™Ô∏è'
    },
    meteor: {
        name: 'ÿßŸÑŸÜŸäÿ≤ŸÉ',
        desc: 'ÿµÿÆŸàÿ± ÿ™ÿ≥ŸÇÿ∑ ŸÖŸÜ ÿßŸÑÿ≥ŸÖÿßÿ°',
        type: 'meteor',
        baseDamage: 40,
        baseCooldown: 2.0,
        baseRange: 100,
        icon: '‚òÑÔ∏è'
    }
};

// ==================== BOOKS DATA ====================
const BOOKS = {
    power: {
        name: 'ŸÉÿ™ÿßÿ® ÿßŸÑŸÇŸàÿ©',
        desc: 'Ÿäÿ≤ŸäÿØ ŸÇŸàÿ© ÿßŸÑŸáÿ¨ŸàŸÖ',
        stat: 'damage',
        baseValue: 0.05,
        icon: 'üìï'
    },
    speed: {
        name: 'ŸÉÿ™ÿßÿ® ÿßŸÑÿ≥ÿ±ÿπÿ©',
        desc: 'Ÿäÿ≤ŸäÿØ ÿ≥ÿ±ÿπÿ© ÿßŸÑŸáÿ¨ŸàŸÖ',
        stat: 'attackSpeed',
        baseValue: 0.05,
        icon: 'üìó'
    },
    wind: {
        name: 'ŸÉÿ™ÿßÿ® ÿßŸÑÿ±Ÿäÿ≠',
        desc: 'Ÿäÿ≤ŸäÿØ ÿ≥ÿ±ÿπÿ© ÿßŸÑÿ≠ÿ±ŸÉÿ©',
        stat: 'moveSpeed',
        baseValue: 0.04,
        icon: 'üìò'
    },
    wisdom: {
        name: 'ŸÉÿ™ÿßÿ® ÿßŸÑÿ≠ŸÉŸÖÿ©',
        desc: 'Ÿäÿ≤ŸäÿØ XP ÿßŸÑŸÖŸÉÿ™ÿ≥ÿ®',
        stat: 'xpGain',
        baseValue: 0.08,
        icon: 'üìô'
    },
    life: {
        name: 'ŸÉÿ™ÿßÿ® ÿßŸÑÿ≠Ÿäÿßÿ©',
        desc: 'Ÿäÿ≤ŸäÿØ ÿßŸÑÿµÿ≠ÿ© ÿßŸÑŸÇÿµŸàŸâ',
        stat: 'maxHealth',
        baseValue: 0.06,
        icon: 'üìì'
    },
    armor: {
        name: 'ŸÉÿ™ÿßÿ® ÿßŸÑÿØÿ±ÿπ',
        desc: 'ŸäŸÇŸÑŸÑ ÿßŸÑÿ∂ÿ±ÿ± ÿßŸÑŸÖÿ≥ÿ™ŸÑŸÖ',
        stat: 'armor',
        baseValue: 0.03,
        icon: 'üìî'
    },
    magnet: {
        name: 'ŸÉÿ™ÿßÿ® ÿßŸÑŸÖÿ∫ŸÜÿßÿ∑Ÿäÿ≥',
        desc: 'Ÿäÿ≤ŸäÿØ ŸÖÿØŸâ ÿßŸÑÿ¨ŸÖÿπ',
        stat: 'pickup',
        baseValue: 0.10,
        icon: 'üìí'
    },
    luck: {
        name: 'ŸÉÿ™ÿßÿ® ÿßŸÑÿ≠ÿ∏',
        desc: 'Ÿäÿ≤ŸäÿØ ÿ≠ÿ∏ ÿßŸÑÿØÿ±Ÿàÿ®',
        stat: 'luck',
        baseValue: 0.05,
        icon: 'üìö'
    },
    curse: {
        name: 'ŸÉÿ™ÿßÿ® ÿßŸÑŸÑÿπŸÜÿ©',
        desc: '+50% ÿ£ÿπÿØÿßÿ°ÿå +100% XP',
        stat: 'curse',
        baseValue: 0.10,
        icon: 'üìñ'
    },
    regen: {
        name: 'ŸÉÿ™ÿßÿ® ÿßŸÑÿ™ÿ¨ÿØŸäÿØ',
        desc: 'Ÿäÿ≥ÿ™ÿπŸäÿØ HP ŸÉŸÑ ÿ´ÿßŸÜŸäÿ©',
        stat: 'regen',
        baseValue: 0.5,
        icon: 'üìú'
    }
};

// ==================== ITEMS DATA ====================
const ITEMS = {
    // Common
    bread: { name: 'ŸÇÿ∑ÿπÿ© ÿÆÿ®ÿ≤', desc: 'Ÿäÿ≥ÿ™ÿπŸäÿØ 10 HP', rarity: 'COMMON', effect: 'heal', value: 10, icon: 'üçû' },
    feather: { name: 'ÿ±Ÿäÿ¥ÿ©', desc: '+10% ÿ≥ÿ±ÿπÿ© ŸÑŸÄ10 ÿ´ŸàÿßŸÜŸä', rarity: 'COMMON', effect: 'tempSpeed', value: 0.1, duration: 10, icon: 'ü™∂' },
    pebble: { name: 'ÿ≠ÿ¨ÿ± ÿµÿ∫Ÿäÿ±', desc: '+5% ÿ∂ÿ±ÿ± ŸÑŸÄ15 ÿ´ÿßŸÜŸäÿ©', rarity: 'COMMON', effect: 'tempDamage', value: 0.05, duration: 15, icon: 'ü™®' },
    herb: { name: 'ÿπÿ¥ÿ®ÿ©', desc: 'Ÿäÿ≥ÿ™ÿπŸäÿØ 5 HP', rarity: 'COMMON', effect: 'heal', value: 5, icon: 'üåø' },
    copper: { name: 'ÿπŸÖŸÑÿ© ŸÜÿ≠ÿßÿ≥Ÿäÿ©', desc: '+5 ÿ∞Ÿáÿ®', rarity: 'COMMON', effect: 'gold', value: 5, icon: 'ü™ô' },
    
    // Rare
    redPotion: { name: 'ÿ¨ÿ±ÿπÿ© ÿ≠ŸÖÿ±ÿßÿ°', desc: 'Ÿäÿ≥ÿ™ÿπŸäÿØ 30 HP', rarity: 'RARE', effect: 'heal', value: 30, icon: 'üß™' },
    bluePotion: { name: 'ÿ¨ÿ±ÿπÿ© ÿ≤ÿ±ŸÇÿßÿ°', desc: '+25% ÿ≥ÿ±ÿπÿ© Ÿáÿ¨ŸàŸÖ ŸÑŸÄ20 ÿ´ÿßŸÜŸäÿ©', rarity: 'RARE', effect: 'tempAttackSpeed', value: 0.25, duration: 20, icon: 'üß¥' },
    silverAmulet: { name: 'ÿ™ŸÖŸäŸÖÿ© ŸÅÿ∂Ÿäÿ©', desc: 'ÿØÿ±ÿπ ŸäŸÖÿ™ÿµ 20 ÿ∂ÿ±ÿ±', rarity: 'RARE', effect: 'shield', value: 20, icon: 'üìø' },
    hourglass: { name: 'ÿ≥ÿßÿπÿ© ÿ±ŸÖŸÑŸäÿ©', desc: 'Ÿäÿ®ÿ∑ÿ¶ ÿßŸÑÿ£ÿπÿØÿßÿ° 50% ŸÑŸÄ5 ÿ´ŸàÿßŸÜŸä', rarity: 'RARE', effect: 'slow', value: 0.5, duration: 5, icon: '‚è≥' },
    silver: { name: 'ÿπŸÖŸÑÿ© ŸÅÿ∂Ÿäÿ©', desc: '+25 ÿ∞Ÿáÿ®', rarity: 'RARE', effect: 'gold', value: 25, icon: 'ü•à' },
    
    // Legendary
    elixir: { name: 'ÿ•ŸÉÿ≥Ÿäÿ± ÿßŸÑÿ≠Ÿäÿßÿ©', desc: 'Ÿäÿ≥ÿ™ÿπŸäÿØ ŸÉŸÑ HP +20 Max', rarity: 'LEGENDARY', effect: 'fullHeal', value: 20, icon: '‚öóÔ∏è' },
    dragonHeart: { name: 'ŸÇŸÑÿ® ÿßŸÑÿ™ŸÜŸäŸÜ', desc: '+50% ÿ∂ÿ±ÿ± ŸÑŸÄ30 ÿ´ÿßŸÜŸäÿ©', rarity: 'LEGENDARY', effect: 'tempDamage', value: 0.5, duration: 30, icon: '‚ù§Ô∏è‚Äçüî•' },
    phoenixEye: { name: 'ÿπŸäŸÜ ÿßŸÑÿπŸÜŸÇÿßÿ°', desc: 'ÿ•ÿ≠Ÿäÿßÿ° ŸÖÿ±ÿ© Ÿàÿßÿ≠ÿØÿ©', rarity: 'LEGENDARY', effect: 'revive', value: 1, icon: 'üëÅÔ∏è' },
    goldCrown: { name: 'ÿ™ÿßÿ¨ ÿ∞Ÿáÿ®Ÿä', desc: '+100% ÿ∞Ÿáÿ® ŸÑŸÑÿ¨ŸàŸÑÿ©', rarity: 'LEGENDARY', effect: 'permGold', value: 1.0, icon: 'üëë' },
    desertStar: { name: 'ŸÜÿ¨ŸÖÿ© ÿßŸÑÿµÿ≠ÿ±ÿßÿ°', desc: 'ÿ≥ŸÑÿßÿ≠/ŸÉÿ™ÿßÿ® ÿπÿ¥Ÿàÿßÿ¶Ÿä', rarity: 'LEGENDARY', effect: 'randomEquip', value: 1, icon: '‚≠ê' }
};

// ==================== ENEMIES DATA ====================
const ENEMIES = {
    wolf: { name: 'ÿßŸÑÿ∞ÿ¶ÿ®', health: 25, damage: 10, speed: 110, xp: 3, spawnTime: 0, color: '#6a6a6a' },
    scorpion: { name: 'ÿßŸÑÿπŸÇÿ±ÿ®', health: 15, damage: 8, speed: 140, xp: 2, spawnTime: 0, color: '#ffa500' },
    dhub: { name: 'ÿßŸÑÿ∂ÿ®', health: 50, damage: 15, speed: 50, xp: 5, spawnTime: 60, color: '#5a8a5a', pattern: 'zigzag' },
    snake: { name: 'ÿßŸÑÿ´ÿπÿ®ÿßŸÜ', health: 30, damage: 12, speed: 90, xp: 4, spawnTime: 120, color: '#2d5a27', ranged: true },
    hyena: { name: 'ÿßŸÑÿ∂ÿ®ÿπ', health: 20, damage: 8, speed: 120, xp: 3, spawnTime: 180, color: '#8b7355', pack: true },
    eagle: { name: 'ÿßŸÑŸÜÿ≥ÿ±', health: 25, damage: 15, speed: 150, xp: 5, spawnTime: 240, color: '#4a3728', flying: true },
    lion: { name: 'ÿßŸÑÿ£ÿ≥ÿØ', health: 100, damage: 25, speed: 70, xp: 10, spawnTime: 300, color: '#c4a35a' },
    djinn: { name: 'ÿßŸÑÿ¨ŸÜŸä', health: 40, damage: 20, speed: 130, xp: 8, spawnTime: 360, color: '#4a0080', teleport: true },
    ghoul: { name: 'ÿßŸÑÿ∫ŸàŸÑ', health: 200, damage: 30, speed: 40, xp: 15, spawnTime: 420, color: '#2a2a2a' },
    darkKnight: { name: 'ŸÅÿßÿ±ÿ≥ ÿßŸÑÿ∏ŸÑÿßŸÖ', health: 80, damage: 22, speed: 85, xp: 12, spawnTime: 480, color: '#1a1a1a' }
};

const BOSS = {
    name: 'ÿßŸÑÿ™ŸÜŸäŸÜ ÿßŸÑÿµÿ≠ÿ±ÿßŸàŸä',
    health: 10000,
    damage: 40,
    speed: 60,
    phases: 3,
    color: '#8b0000'
};

// ==================== PIXEL ART ENGINE ====================
class PixelArtEngine {
    createCharacterSprite(charData, scale = 3) {
        const canvas = document.createElement('canvas');
        canvas.width = 15 * scale;
        canvas.height = 22 * scale;
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;
        
        const c = charData.colors;
        
        // Simple character shape
        // Head
        ctx.fillStyle = c.skin;
        ctx.fillRect(5*scale, 2*scale, 5*scale, 5*scale);
        
        // Headwear
        ctx.fillStyle = c.secondary;
        ctx.fillRect(4*scale, 0, 7*scale, 3*scale);
        
        // Body
        ctx.fillStyle = c.primary;
        ctx.fillRect(3*scale, 7*scale, 9*scale, 10*scale);
        
        // Arms
        ctx.fillStyle = c.skin;
        ctx.fillRect(1*scale, 8*scale, 2*scale, 6*scale);
        ctx.fillRect(12*scale, 8*scale, 2*scale, 6*scale);
        
        // Legs
        ctx.fillStyle = c.accent;
        ctx.fillRect(4*scale, 17*scale, 3*scale, 5*scale);
        ctx.fillRect(8*scale, 17*scale, 3*scale, 5*scale);
        
        // Eyes
        ctx.fillStyle = '#000';
        ctx.fillRect(6*scale, 4*scale, scale, scale);
        ctx.fillRect(8*scale, 4*scale, scale, scale);
        
        return canvas;
    }
    
    createEnemySprite(enemyData, scale = 3) {
        const canvas = document.createElement('canvas');
        canvas.width = 12 * scale;
        canvas.height = 12 * scale;
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;
        
        ctx.fillStyle = enemyData.color;
        
        // Simple enemy shape
        ctx.beginPath();
        ctx.arc(6*scale, 6*scale, 5*scale, 0, Math.PI * 2);
        ctx.fill();
        
        // Eyes
        ctx.fillStyle = enemyData.flying ? '#ff0' : '#f00';
        ctx.fillRect(4*scale, 4*scale, scale, scale);
        ctx.fillRect(7*scale, 4*scale, scale, scale);
        
        return canvas;
    }
    
    createBossSprite(scale = 4) {
        const canvas = document.createElement('canvas');
        canvas.width = 32 * scale;
        canvas.height = 32 * scale;
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;
        
        // Dragon body
        ctx.fillStyle = BOSS.color;
        ctx.beginPath();
        ctx.ellipse(16*scale, 18*scale, 12*scale, 10*scale, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Head
        ctx.beginPath();
        ctx.ellipse(16*scale, 6*scale, 8*scale, 6*scale, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Eyes
        ctx.fillStyle = '#ff0';
        ctx.fillRect(12*scale, 4*scale, 2*scale, 2*scale);
        ctx.fillRect(18*scale, 4*scale, 2*scale, 2*scale);
        
        // Wings
        ctx.fillStyle = '#5a0000';
        ctx.beginPath();
        ctx.moveTo(4*scale, 15*scale);
        ctx.lineTo(0, 5*scale);
        ctx.lineTo(10*scale, 12*scale);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(28*scale, 15*scale);
        ctx.lineTo(32*scale, 5*scale);
        ctx.lineTo(22*scale, 12*scale);
        ctx.fill();
        
        return canvas;
    }
    
    createWeaponIcon(weapon, scale = 2) {
        const canvas = document.createElement('canvas');
        canvas.width = 16 * scale;
        canvas.height = 16 * scale;
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;
        
        ctx.font = `${12*scale}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(weapon.icon, 8*scale, 8*scale);
        
        return canvas;
    }
    
    createBookIcon(book, scale = 2) {
        const canvas = document.createElement('canvas');
        canvas.width = 16 * scale;
        canvas.height = 16 * scale;
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;
        
        ctx.font = `${12*scale}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(book.icon, 8*scale, 8*scale);
        
        return canvas;
    }
    
    createItemSprite(item, scale = 2) {
        const canvas = document.createElement('canvas');
        canvas.width = 12 * scale;
        canvas.height = 12 * scale;
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;
        
        // Glow based on rarity
        const rarity = RARITY[item.rarity];
        ctx.shadowColor = rarity.color;
        ctx.shadowBlur = 5;
        
        ctx.font = `${10*scale}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(item.icon, 6*scale, 6*scale);
        
        return canvas;
    }
    
    createPickupSprite(type, scale = 2) {
        const canvas = document.createElement('canvas');
        canvas.width = 8 * scale;
        canvas.height = 8 * scale;
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;
        
        if (type === 'xp') {
            ctx.fillStyle = '#0f0';
            ctx.beginPath();
            ctx.moveTo(4*scale, 0);
            ctx.lineTo(8*scale, 4*scale);
            ctx.lineTo(4*scale, 8*scale);
            ctx.lineTo(0, 4*scale);
            ctx.fill();
        } else if (type === 'gold') {
            ctx.fillStyle = '#ffd700';
            ctx.beginPath();
            ctx.arc(4*scale, 4*scale, 3*scale, 0, Math.PI * 2);
            ctx.fill();
        }
        
        return canvas;
    }
}

// ==================== AUDIO SYSTEM ====================
class AudioSystem {
    constructor() {
        this.ctx = null;
        this.initialized = false;
    }
    
    init() {
        if (this.initialized) return;
        try {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.initialized = true;
        } catch(e) {}
    }
    
    playTone(freq, duration, type = 'square', vol = 0.2) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.value = freq;
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }
    
    playHit() { this.playTone(150, 0.15, 'sawtooth', 0.3); }
    playShoot() { this.playTone(400, 0.05); this.playTone(200, 0.08); }
    playPickup() { this.playTone(600, 0.05, 'sine'); }
    playLevelUp() { [523,659,784,1047].forEach((f,i) => setTimeout(() => this.playTone(f,0.15,'sine',0.25), i*80)); }
    playBossWarn() { this.playTone(100, 0.5, 'sawtooth', 0.4); setTimeout(() => this.playTone(80, 0.5, 'sawtooth', 0.4), 600); }
    playVictory() { [523,659,784,880,1047].forEach((f,i) => setTimeout(() => this.playTone(f,0.3,'sine',0.3), i*150)); }
    playDeath() { this.playTone(200, 0.3, 'sawtooth'); this.playTone(100, 0.4, 'sawtooth'); }
    playItemPickup(rarity) {
        const base = rarity === 'LEGENDARY' ? 800 : rarity === 'RARE' ? 600 : 400;
        this.playTone(base, 0.1, 'sine');
        this.playTone(base * 1.5, 0.15, 'sine');
    }
}

// ==================== PARTICLE SYSTEM ====================
class ParticleSystem {
    constructor() {
        this.particles = [];
        this.bloodStains = [];
    }
    
    emit(x, y, count, options = {}) {
        for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = (options.minSpeed || 50) + Math.random() * ((options.maxSpeed || 150) - (options.minSpeed || 50));
            this.particles.push({
                x, y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                color: options.color || '#fff',
                size: (options.minSize || 2) + Math.random() * ((options.maxSize || 5) - (options.minSize || 2)),
                life: (options.minLife || 0.3) + Math.random() * ((options.maxLife || 1) - (options.minLife || 0.3)),
                maxLife: (options.maxLife || 1),
                gravity: options.gravity || 0
            });
        }
    }
    
    emitBlood(x, y) {
        this.emit(x, y, 12, { color: '#8b0000', minSpeed: 50, maxSpeed: 180, gravity: 200 });
        this.bloodStains.push({ x, y, size: 8 + Math.random() * 12 });
        if (this.bloodStains.length > 150) this.bloodStains.shift();
    }
    
    update(dt) {
        this.particles = this.particles.filter(p => {
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.vy += p.gravity * dt;
            p.life -= dt;
            return p.life > 0;
        });
    }
    
    draw(ctx, camera) {
        // Blood stains
        ctx.fillStyle = '#4a0000';
        for (const s of this.bloodStains) {
            ctx.globalAlpha = 0.4;
            ctx.beginPath();
            ctx.arc(s.x - camera.x, s.y - camera.y, s.size, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Particles
        for (const p of this.particles) {
            ctx.globalAlpha = p.life / p.maxLife;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x - camera.x, p.y - camera.y, p.size, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;
    }
}

// ==================== FLOATING TEXT ====================
class FloatingText {
    constructor(x, y, text, color = '#fff', size = 18) {
        this.x = x;
        this.y = y;
        this.text = text;
        this.color = color;
        this.size = size;
        this.life = 1;
        this.vy = -60;
    }
    
    update(dt) {
        this.y += this.vy * dt;
        this.life -= dt;
    }
    
    draw(ctx, camera) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.font = `bold ${this.size}px Cairo`;
        ctx.textAlign = 'center';
        ctx.fillText(this.text, this.x - camera.x, this.y - camera.y);
        ctx.globalAlpha = 1;
    }
}

// ==================== PLAYER CLASS ====================
class Player {
    constructor(x, y, charId) {
        this.x = x;
        this.y = y;
        this.charId = charId;
        this.charData = CHARACTERS[charId];
        
        // Stats
        this.maxHealth = this.charData.stats.health || 100;
        this.health = this.maxHealth;
        this.speed = this.charData.stats.speed || 200;
        this.damage = 1;
        this.attackSpeed = this.charData.stats.attackSpeed || 1;
        this.pickupRange = 50 * (this.charData.stats.pickupRange || 1);
        this.xpMult = this.charData.stats.xpMult || 1;
        this.goldMult = this.charData.stats.goldMult || 1;
        this.damageReduction = this.charData.stats.damageReduction || 0;
        this.luck = this.charData.stats.luck || 1;
        this.armor = 0;
        this.regen = 0;
        this.curseLevel = 0;
        this.range = this.charData.stats.range || 1;
        this.cooldownMult = this.charData.stats.cooldownReduction || 1;
        this.meleeDamageMult = this.charData.stats.meleeDamage || 1;
        
        // Equipment
        this.weapons = [{ id: this.charData.weapon, level: 1, upgrades: [] }];
        this.books = [];
        
        // State
        this.xp = 0;
        this.level = 1;
        this.gold = 0;
        this.kills = 0;
        this.invulnerable = 0;
        this.facing = 1;
        this.vx = 0;
        this.vy = 0;
        this.animTimer = 0;
        this.shieldAmount = 0;
        this.hasRevive = false;
        this.tempBuffs = [];
        
        // Weapon timers
        this.weaponTimers = {};
        
        this.width = 40;
        this.height = 60;
        this.sprite = null;
    }
    
    getWeaponDamage(weapon) {
        const base = WEAPONS[weapon.id].baseDamage;
        let mult = this.damage * this.meleeDamageMult;
        
        // Add upgrade bonuses
        weapon.upgrades.forEach(u => {
            mult *= u.rarity.multiplier;
        });
        
        // Temp buffs
        this.tempBuffs.forEach(b => {
            if (b.type === 'damage') mult *= (1 + b.value);
        });
        
        return base * mult * (1 + (weapon.level - 1) * 0.1);
    }
    
    getWeaponCooldown(weapon) {
        const base = WEAPONS[weapon.id].baseCooldown;
        let mult = this.cooldownMult / this.attackSpeed;
        
        this.tempBuffs.forEach(b => {
            if (b.type === 'attackSpeed') mult /= (1 + b.value);
        });
        
        return base * mult * Math.max(0.2, 1 - (weapon.level - 1) * 0.03);
    }
    
    getWeaponRange(weapon) {
        return WEAPONS[weapon.id].baseRange * this.range * (1 + (weapon.level - 1) * 0.05);
    }
    
    update(dt, input, game) {
        // Movement
        let dx = 0, dy = 0;
        if (input.left) dx -= 1;
        if (input.right) dx += 1;
        if (input.up) dy -= 1;
        if (input.down) dy += 1;
        if (input.joystick) {
            dx += input.joystick.x;
            dy += input.joystick.y;
        }
        
        const mag = Math.hypot(dx, dy);
        if (mag > 0) {
            dx /= mag;
            dy /= mag;
            
            let speed = this.speed;
            this.tempBuffs.forEach(b => {
                if (b.type === 'speed') speed *= (1 + b.value);
            });
            
            this.vx = dx * speed;
            this.vy = dy * speed;
            if (dx !== 0) this.facing = dx > 0 ? 1 : -1;
        } else {
            this.vx = 0;
            this.vy = 0;
        }
        
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.x = Math.max(-CONFIG.WORLD_SIZE/2, Math.min(CONFIG.WORLD_SIZE/2, this.x));
        this.y = Math.max(-CONFIG.WORLD_SIZE/2, Math.min(CONFIG.WORLD_SIZE/2, this.y));
        
        if (this.invulnerable > 0) this.invulnerable -= dt;
        this.animTimer += dt;
        
        // Regen
        if (this.regen > 0) {
            this.health = Math.min(this.maxHealth, this.health + this.regen * dt);
        }
        
        // Update temp buffs
        this.tempBuffs = this.tempBuffs.filter(b => {
            b.duration -= dt;
            return b.duration > 0;
        });
        
        // Fire weapons
        this.weapons.forEach(w => {
            if (!this.weaponTimers[w.id]) this.weaponTimers[w.id] = 0;
            this.weaponTimers[w.id] -= dt;
            
            if (this.weaponTimers[w.id] <= 0) {
                this.fireWeapon(w, game);
                this.weaponTimers[w.id] = this.getWeaponCooldown(w);
            }
        });
    }
    
    fireWeapon(weapon, game) {
        const wData = WEAPONS[weapon.id];
        const damage = this.getWeaponDamage(weapon);
        const range = this.getWeaponRange(weapon);
        
        switch(wData.type) {
            case 'projectile': {
                let nearest = null, nearestDist = Infinity;
                for (const e of game.enemies) {
                    const d = Math.hypot(e.x - this.x, e.y - this.y);
                    if (d < nearestDist && d < range) { nearestDist = d; nearest = e; }
                }
                if (nearest) {
                    const angle = Math.atan2(nearest.y - this.y, nearest.x - this.x);
                    game.projectiles.push({
                        x: this.x, y: this.y,
                        vx: Math.cos(angle) * 400, vy: Math.sin(angle) * 400,
                        damage, life: 3, size: 8, color: '#8b4513', pierce: weapon.level > 10 ? 2 : 1
                    });
                    game.audio.playShoot();
                }
                break;
            }
            case 'directional': {
                const angle = Math.atan2(this.vy || 0.01, this.vx || this.facing);
                game.projectiles.push({
                    x: this.x, y: this.y,
                    vx: Math.cos(angle) * 500, vy: Math.sin(angle) * 500,
                    damage, life: 2, size: 10, color: '#8b4513', pierce: weapon.level > 10 ? 3 : 1
                });
                game.audio.playShoot();
                break;
            }
            case 'radial': {
                const count = 4 + Math.floor(weapon.level / 5);
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    game.projectiles.push({
                        x: this.x, y: this.y,
                        vx: Math.cos(angle) * 350, vy: Math.sin(angle) * 350,
                        damage: damage * 0.6, life: 2, size: 5, color: '#4a2800'
                    });
                }
                game.audio.playShoot();
                break;
            }
            case 'random': {
                const count = 1 + Math.floor(weapon.level / 4);
                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    game.projectiles.push({
                        x: this.x, y: this.y,
                        vx: Math.cos(angle) * 300, vy: Math.sin(angle) * 300,
                        damage, life: 2, size: 7, color: '#ff4500'
                    });
                }
                game.audio.playShoot();
                break;
            }
            case 'lightning': {
                const targets = game.enemies.filter(e => Math.hypot(e.x - this.x, e.y - this.y) < range);
                if (targets.length > 0) {
                    const target = targets[Math.floor(Math.random() * targets.length)];
                    game.lightningEffects.push({ x: target.x, y: target.y, life: 0.3 });
                    if (target.takeDamage(damage, game)) game.killEnemy(target);
                    game.audio.playTone(800, 0.1, 'sawtooth');
                }
                break;
            }
            case 'meteor': {
                const count = 1 + Math.floor(weapon.level / 5);
                for (let i = 0; i < count; i++) {
                    const tx = this.x + (Math.random() - 0.5) * range * 2;
                    const ty = this.y + (Math.random() - 0.5) * range * 2;
                    game.meteorEffects.push({ x: tx, y: ty, damage, radius: 60, life: 1, delay: i * 0.2 });
                }
                break;
            }
            case 'tornado': {
                game.tornadoes.push({
                    x: this.x + this.facing * 50,
                    y: this.y,
                    vx: this.facing * 100,
                    vy: 0,
                    damage: damage * 0.5,
                    slowAmount: 0.5,
                    life: 4 + weapon.level * 0.2,
                    radius: 40
                });
                break;
            }
        }
    }
    
    takeDamage(amount, game) {
        if (this.invulnerable > 0) return;
        
        // Shield first
        if (this.shieldAmount > 0) {
            const absorbed = Math.min(this.shieldAmount, amount);
            this.shieldAmount -= absorbed;
            amount -= absorbed;
            if (amount <= 0) return;
        }
        
        // Armor and damage reduction
        const actualDamage = amount * (1 - this.damageReduction) * (1 - Math.min(0.75, this.armor * 0.02));
        this.health -= actualDamage;
        this.invulnerable = 0.5;
        
        game.audio.playHit();
        game.screenShake = 0.2;
        game.floatingTexts.push(new FloatingText(this.x, this.y - 30, `-${Math.round(actualDamage)}`, '#ff0000'));
        
        if (this.health <= 0) {
            if (this.hasRevive) {
                this.hasRevive = false;
                this.health = this.maxHealth * 0.5;
                this.invulnerable = 2;
                game.floatingTexts.push(new FloatingText(this.x, this.y - 50, 'ÿ•ÿ≠Ÿäÿßÿ°!', '#ffd700', 24));
            } else {
                game.gameOver(false);
            }
        }
    }
    
    draw(ctx, camera) {
        const sx = this.x - camera.x;
        const sy = this.y - camera.y;
        
        if (this.invulnerable > 0 && Math.floor(this.invulnerable * 10) % 2 === 0) {
            ctx.globalAlpha = 0.5;
        }
        
        ctx.save();
        if (this.facing < 0) {
            ctx.scale(-1, 1);
            ctx.drawImage(this.sprite, -sx - this.sprite.width/2, sy - this.sprite.height/2);
        } else {
            ctx.drawImage(this.sprite, sx - this.sprite.width/2, sy - this.sprite.height/2);
        }
        ctx.restore();
        ctx.globalAlpha = 1;
        
        // Draw weapon effects
        this.weapons.forEach(w => {
            const wData = WEAPONS[w.id];
            const range = this.getWeaponRange(w);
            
            if (wData.type === 'orbit') {
                const count = 6 + Math.floor(w.level / 3);
                for (let i = 0; i < count; i++) {
                    const angle = this.animTimer * 3 + (i / count) * Math.PI * 2;
                    const ox = sx + Math.cos(angle) * range;
                    const oy = sy + Math.sin(angle) * range;
                    ctx.fillStyle = '#1a1a1a';
                    ctx.beginPath();
                    ctx.arc(ox, oy, 4 + w.level * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (wData.type === 'aura') {
                const auraR = range + Math.sin(this.animTimer * 4) * 10;
                ctx.strokeStyle = `rgba(138, 43, 226, ${0.3 + w.level * 0.02})`;
                ctx.lineWidth = 2 + w.level * 0.2;
                ctx.beginPath();
                ctx.arc(sx, sy, auraR, 0, Math.PI * 2);
                ctx.stroke();
            } else if (wData.type === 'melee') {
                // Sword swing visualization
                const swingPhase = (this.weaponTimers[w.id] || 0) / this.getWeaponCooldown(w);
                if (swingPhase > 0.7) {
                    ctx.strokeStyle = '#aaa';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(sx, sy, range, -Math.PI/3 * this.facing, Math.PI/3 * this.facing);
                    ctx.stroke();
                }
            }
        });
        
        // Shield indicator
        if (this.shieldAmount > 0) {
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.6)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(sx, sy, 35, 0, Math.PI * 2);
            ctx.stroke();
        }
    }
}

// ==================== ENEMY CLASS ====================
class Enemy {
    constructor(x, y, type, difficulty = 1) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.data = ENEMIES[type];
        
        this.maxHealth = this.data.health * difficulty;
        this.health = this.maxHealth;
        this.damage = this.data.damage * (0.8 + difficulty * 0.2);
        this.speed = this.data.speed;
        this.xpValue = this.data.xp;
        
        this.vx = 0;
        this.vy = 0;
        this.hitFlash = 0;
        this.slowAmount = 1;
        this.slowTimer = 0;
        
        // Special behaviors
        this.zigzagTimer = 0;
        this.zigzagDir = 1;
        this.teleportTimer = 0;
        this.attackTimer = 0;
        
        this.width = 30;
        this.height = 30;
        this.sprite = null;
    }
    
    update(dt, player, enemies, game) {
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const dist = Math.hypot(dx, dy);
        
        // Update slow
        if (this.slowTimer > 0) {
            this.slowTimer -= dt;
            if (this.slowTimer <= 0) this.slowAmount = 1;
        }
        
        if (dist > 0) {
            let moveX = dx / dist;
            let moveY = dy / dist;
            
            // Special movement patterns
            if (this.data.pattern === 'zigzag') {
                this.zigzagTimer += dt;
                if (this.zigzagTimer > 0.5) {
                    this.zigzagTimer = 0;
                    this.zigzagDir *= -1;
                }
                const perpX = -moveY * this.zigzagDir;
                const perpY = moveX * this.zigzagDir;
                moveX = moveX * 0.7 + perpX * 0.3;
                moveY = moveY * 0.7 + perpY * 0.3;
            }
            
            if (this.data.teleport) {
                this.teleportTimer += dt;
                if (this.teleportTimer > 2 && dist > 100) {
                    this.teleportTimer = 0;
                    const angle = Math.random() * Math.PI * 2;
                    this.x = player.x + Math.cos(angle) * 150;
                    this.y = player.y + Math.sin(angle) * 150;
                    game.particles.emit(this.x, this.y, 10, { color: '#4a0080' });
                }
            }
            
            // Ranged attack
            if (this.data.ranged && dist < 300) {
                this.attackTimer -= dt;
                if (this.attackTimer <= 0) {
                    this.attackTimer = 2;
                    const angle = Math.atan2(dy, dx);
                    game.enemyProjectiles.push({
                        x: this.x, y: this.y,
                        vx: Math.cos(angle) * 200, vy: Math.sin(angle) * 200,
                        damage: this.damage * 0.5, life: 3, size: 5, color: '#2d5a27'
                    });
                }
            }
            
            // Separation
            let sepX = 0, sepY = 0;
            for (const other of enemies) {
                if (other === this) continue;
                const ox = this.x - other.x;
                const oy = this.y - other.y;
                const od = Math.hypot(ox, oy);
                if (od < 35 && od > 0) {
                    sepX += ox / od * (35 - od) / 35;
                    sepY += oy / od * (35 - od) / 35;
                }
            }
            moveX += sepX * 0.5;
            moveY += sepY * 0.5;
            
            const moveMag = Math.hypot(moveX, moveY);
            if (moveMag > 0) {
                this.vx = (moveX / moveMag) * this.speed * this.slowAmount;
                this.vy = (moveY / moveMag) * this.speed * this.slowAmount;
            }
        }
        
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        
        if (this.hitFlash > 0) this.hitFlash -= dt;
    }
    
    takeDamage(amount, game) {
        this.health -= amount;
        this.hitFlash = 0.1;
        game.floatingTexts.push(new FloatingText(
            this.x + (Math.random() - 0.5) * 20,
            this.y - 20,
            Math.round(amount).toString(),
            '#ffff00'
        ));
        return this.health <= 0;
    }
    
    draw(ctx, camera) {
        const sx = this.x - camera.x;
        const sy = this.y - camera.y;
        
        if (this.hitFlash > 0) ctx.globalAlpha = 0.7;
        
        if (this.sprite) {
            ctx.drawImage(this.sprite, sx - this.sprite.width/2, sy - this.sprite.height/2);
        }
        
        ctx.globalAlpha = 1;
        
        // Health bar
        if (this.health < this.maxHealth) {
            const barW = 30;
            ctx.fillStyle = '#333';
            ctx.fillRect(sx - barW/2, sy - this.height/2 - 8, barW, 4);
            ctx.fillStyle = '#f00';
            ctx.fillRect(sx - barW/2, sy - this.height/2 - 8, barW * (this.health / this.maxHealth), 4);
        }
        
        // Slow indicator
        if (this.slowTimer > 0) {
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(sx, sy, 20, 0, Math.PI * 2);
            ctx.stroke();
        }
    }
}

// ==================== BOSS CLASS ====================
class Boss {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.maxHealth = BOSS.health;
        this.health = this.maxHealth;
        this.damage = BOSS.damage;
        this.speed = BOSS.speed;
        this.phase = 1;
        
        this.attackTimer = 0;
        this.specialTimer = 0;
        this.hitFlash = 0;
        
        this.width = 100;
        this.height = 100;
        this.sprite = null;
    }
    
    update(dt, player, game) {
        // Update phase
        const healthPercent = this.health / this.maxHealth;
        if (healthPercent < 0.33) this.phase = 3;
        else if (healthPercent < 0.66) this.phase = 2;
        
        // Move towards player
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const dist = Math.hypot(dx, dy);
        
        if (dist > 0) {
            const speed = this.speed * (1 + (3 - this.phase) * 0.2);
            this.x += (dx / dist) * speed * dt;
            this.y += (dy / dist) * speed * dt;
        }
        
        // Fire breath
        this.attackTimer -= dt;
        if (this.attackTimer <= 0) {
            this.attackTimer = 2 / this.phase;
            const angle = Math.atan2(dy, dx);
            for (let i = -2; i <= 2; i++) {
                game.enemyProjectiles.push({
                    x: this.x, y: this.y,
                    vx: Math.cos(angle + i * 0.2) * 250,
                    vy: Math.sin(angle + i * 0.2) * 250,
                    damage: this.damage, life: 3, size: 10, color: '#ff4500'
                });
            }
        }
        
        // Summon minions (phase 2+)
        if (this.phase >= 2) {
            this.specialTimer -= dt;
            if (this.specialTimer <= 0) {
                this.specialTimer = 5;
                const types = ['wolf', 'scorpion'];
                for (let i = 0; i < this.phase * 2; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const enemy = new Enemy(
                        this.x + Math.cos(angle) * 100,
                        this.y + Math.sin(angle) * 100,
                        types[Math.floor(Math.random() * types.length)],
                        2
                    );
                    enemy.sprite = game.sprites.enemies[enemy.type];
                    game.enemies.push(enemy);
                }
            }
        }
        
        if (this.hitFlash > 0) this.hitFlash -= dt;
    }
    
    takeDamage(amount, game) {
        this.health -= amount;
        this.hitFlash = 0.1;
        game.floatingTexts.push(new FloatingText(
            this.x + (Math.random() - 0.5) * 40,
            this.y - 40,
            Math.round(amount).toString(),
            '#ffff00',
            22
        ));
        return this.health <= 0;
    }
    
    draw(ctx, camera) {
        const sx = this.x - camera.x;
        const sy = this.y - camera.y;
        
        if (this.hitFlash > 0) ctx.globalAlpha = 0.7;
        
        if (this.sprite) {
            ctx.drawImage(this.sprite, sx - this.sprite.width/2, sy - this.sprite.height/2);
        }
        
        ctx.globalAlpha = 1;
        
        // Boss health bar
        const barW = 80;
        ctx.fillStyle = '#333';
        ctx.fillRect(sx - barW/2, sy - 70, barW, 8);
        ctx.fillStyle = this.phase === 3 ? '#ff0000' : this.phase === 2 ? '#ff8800' : '#ffff00';
        ctx.fillRect(sx - barW/2, sy - 70, barW * (this.health / this.maxHealth), 8);
        
        // Phase indicator
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 12px Cairo';
        ctx.textAlign = 'center';
        ctx.fillText(`ÿßŸÑŸÖÿ±ÿ≠ŸÑÿ© ${this.phase}`, sx, sy - 78);
    }
}

// ==================== ITEM DROP CLASS ====================
class ItemDrop {
    constructor(x, y, itemId) {
        this.x = x;
        this.y = y;
        this.itemId = itemId;
        this.item = ITEMS[itemId];
        this.bobTimer = Math.random() * Math.PI * 2;
        this.sprite = null;
    }
    
    update(dt) {
        this.bobTimer += dt * 4;
    }
    
    draw(ctx, camera) {
        const sx = this.x - camera.x;
        const sy = this.y - camera.y + Math.sin(this.bobTimer) * 4;
        
        const rarity = RARITY[this.item.rarity];
        
        // Glow
        ctx.fillStyle = rarity.color + '40';
        ctx.beginPath();
        ctx.arc(sx, sy, 18, 0, Math.PI * 2);
        ctx.fill();
        
        // Icon
        ctx.font = '20px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.item.icon, sx, sy);
    }
}

// ==================== PICKUP CLASS ====================
class Pickup {
    constructor(x, y, type, value) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.value = value;
        this.bobTimer = Math.random() * Math.PI * 2;
    }
    
    update(dt) {
        this.bobTimer += dt * 4;
    }
    
    draw(ctx, camera) {
        const sx = this.x - camera.x;
        const sy = this.y - camera.y + Math.sin(this.bobTimer) * 3;
        
        if (this.type === 'xp') {
            ctx.fillStyle = '#0f0';
            ctx.beginPath();
            ctx.moveTo(sx, sy - 6);
            ctx.lineTo(sx + 6, sy);
            ctx.lineTo(sx, sy + 6);
            ctx.lineTo(sx - 6, sy);
            ctx.fill();
        } else if (this.type === 'gold') {
            ctx.fillStyle = '#ffd700';
            ctx.beginPath();
            ctx.arc(sx, sy, 5, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}

// ==================== MAIN GAME CLASS ====================
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        this.pixelArt = new PixelArtEngine();
        this.audio = new AudioSystem();
        this.particles = new ParticleSystem();
        
        this.state = 'menu';
        this.selectedCharacter = 'abuSulaiman';
        
        this.player = null;
        this.enemies = [];
        this.boss = null;
        this.projectiles = [];
        this.enemyProjectiles = [];
        this.pickups = [];
        this.itemDrops = [];
        this.floatingTexts = [];
        this.tornadoes = [];
        this.lightningEffects = [];
        this.meteorEffects = [];
        
        this.camera = { x: 0, y: 0 };
        this.screenShake = 0;
        
        this.input = { up: false, down: false, left: false, right: false, joystick: null };
        
        this.spawnTimer = 0;
        this.gameTime = 0;
        this.difficulty = 1;
        this.bossSpawned = false;
        this.bossWarningShown = false;
        this.globalSlowTimer = 0;
        
        this.sprites = { characters: {}, enemies: {}, weapons: {}, books: {} };
        
        this.lastTime = 0;
        
        // High score
        this.highScore = parseInt(localStorage.getItem('goldBloodHighScore') || '0');
        document.getElementById('highScore').textContent = this.highScore;
        
        this.init();
    }
    
    init() {
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        this.setupInput();
        this.generateSprites();
        this.setupMenu();
        this.setupEquipmentSlots();
        
        requestAnimationFrame(t => this.gameLoop(t));
    }
    
    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.ctx.imageSmoothingEnabled = false;
    }
    
    generateSprites() {
        // Characters
        for (const [id, data] of Object.entries(CHARACTERS)) {
            this.sprites.characters[id] = this.pixelArt.createCharacterSprite(data);
        }
        
        // Enemies
        for (const [id, data] of Object.entries(ENEMIES)) {
            this.sprites.enemies[id] = this.pixelArt.createEnemySprite(data);
        }
        
        // Boss
        this.sprites.boss = this.pixelArt.createBossSprite();
        
        // Weapons
        for (const [id, data] of Object.entries(WEAPONS)) {
            this.sprites.weapons[id] = this.pixelArt.createWeaponIcon(data);
        }
        
        // Books
        for (const [id, data] of Object.entries(BOOKS)) {
            this.sprites.books[id] = this.pixelArt.createBookIcon(data);
        }
    }
    
    setupMenu() {
        const carousel = document.getElementById('characterCarousel');
        carousel.innerHTML = '';
        
        for (const [id, data] of Object.entries(CHARACTERS)) {
            const card = document.createElement('div');
            card.className = 'character-card' + (id === this.selectedCharacter ? ' selected' : '');
            card.dataset.character = id;
            
            const preview = document.createElement('canvas');
            preview.width = 80;
            preview.height = 80;
            const pCtx = preview.getContext('2d');
            pCtx.imageSmoothingEnabled = false;
            const sprite = this.sprites.characters[id];
            const scale = Math.min(70 / sprite.width, 70 / sprite.height);
            pCtx.drawImage(sprite, 40 - sprite.width * scale / 2, 40 - sprite.height * scale / 2, sprite.width * scale, sprite.height * scale);
            
            card.innerHTML = `
                <div class="character-name">${data.name}</div>
                <div style="font-size: 0.75rem; color: #888; margin-bottom: 5px;">${data.title}</div>
                <div class="character-passive">${data.passive}</div>
                <div class="character-weapon">üó°Ô∏è ${WEAPONS[data.weapon].name}</div>
            `;
            card.insertBefore(preview, card.firstChild);
            
            card.addEventListener('click', () => {
                document.querySelectorAll('.character-card').forEach(c => c.classList.remove('selected'));
                card.classList.add('selected');
                this.selectedCharacter = id;
            });
            
            carousel.appendChild(card);
        }
        
        document.getElementById('startBtn').addEventListener('click', () => this.startGame());
        document.getElementById('restartBtn').addEventListener('click', () => this.restartGame());
    }
    
    setupEquipmentSlots() {
        const weaponSlots = document.getElementById('weaponSlots');
        const bookSlots = document.getElementById('bookSlots');
        
        for (let i = 0; i < CONFIG.MAX_WEAPONS; i++) {
            const slot = document.createElement('div');
            slot.className = 'equipment-slot';
            slot.id = `weaponSlot${i}`;
            weaponSlots.appendChild(slot);
        }
        
        for (let i = 0; i < CONFIG.MAX_BOOKS; i++) {
            const slot = document.createElement('div');
            slot.className = 'equipment-slot';
            slot.id = `bookSlot${i}`;
            bookSlots.appendChild(slot);
        }
    }
    
    updateEquipmentSlots() {
        // Weapons
        for (let i = 0; i < CONFIG.MAX_WEAPONS; i++) {
            const slot = document.getElementById(`weaponSlot${i}`);
            slot.innerHTML = '';
            
            if (this.player.weapons[i]) {
                const w = this.player.weapons[i];
                const icon = this.sprites.weapons[w.id];
                if (icon) {
                    const canvas = document.createElement('canvas');
                    canvas.width = 35;
                    canvas.height = 35;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(icon, 0, 0, 35, 35);
                    slot.appendChild(canvas);
                }
                
                const lvl = document.createElement('span');
                lvl.className = 'slot-level';
                lvl.textContent = w.level;
                slot.appendChild(lvl);
                
                // Rarity border
                if (w.upgrades.length > 0) {
                    const lastRarity = w.upgrades[w.upgrades.length - 1].rarity;
                    slot.style.borderColor = lastRarity.color;
                }
            }
        }
        
        // Books
        for (let i = 0; i < CONFIG.MAX_BOOKS; i++) {
            const slot = document.getElementById(`bookSlot${i}`);
            slot.innerHTML = '';
            
            if (this.player.books[i]) {
                const b = this.player.books[i];
                const icon = this.sprites.books[b.id];
                if (icon) {
                    const canvas = document.createElement('canvas');
                    canvas.width = 35;
                    canvas.height = 35;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(icon, 0, 0, 35, 35);
                    slot.appendChild(canvas);
                }
                
                const lvl = document.createElement('span');
                lvl.className = 'slot-level';
                lvl.textContent = b.level;
                slot.appendChild(lvl);
                
                if (b.upgrades.length > 0) {
                    const lastRarity = b.upgrades[b.upgrades.length - 1].rarity;
                    slot.style.borderColor = lastRarity.color;
                }
            }
        }
    }
    
    setupInput() {
        window.addEventListener('keydown', e => {
            if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') this.input.up = true;
            if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') this.input.down = true;
            if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') this.input.left = true;
            if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') this.input.right = true;
            if ((e.key === 'Escape' || e.key === 'p' || e.key === 'P') && this.state === 'playing') this.togglePause();
        });
        
        window.addEventListener('keyup', e => {
            if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') this.input.up = false;
            if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') this.input.down = false;
            if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') this.input.left = false;
            if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') this.input.right = false;
        });
        
        let touchStart = null;
        this.canvas.addEventListener('touchstart', e => {
            if (this.state !== 'playing') return;
            e.preventDefault();
            touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            this.input.joystick = { x: 0, y: 0 };
        }, { passive: false });
        
        this.canvas.addEventListener('touchmove', e => {
            if (this.state !== 'playing' || !touchStart) return;
            e.preventDefault();
            const dx = e.touches[0].clientX - touchStart.x;
            const dy = e.touches[0].clientY - touchStart.y;
            const dist = Math.min(Math.hypot(dx, dy), 80);
            const angle = Math.atan2(dy, dx);
            this.input.joystick = { x: Math.cos(angle) * dist / 80, y: Math.sin(angle) * dist / 80 };
        }, { passive: false });
        
        this.canvas.addEventListener('touchend', () => {
            touchStart = null;
            this.input.joystick = null;
        });
    }
    
    startGame() {
        this.audio.init();
        
        this.state = 'playing';
        document.getElementById('mainMenu').style.display = 'none';
        document.getElementById('hud').style.display = 'flex';
        document.getElementById('equipmentSlots').style.display = 'flex';
        
        this.player = new Player(0, 0, this.selectedCharacter);
        this.player.sprite = this.sprites.characters[this.selectedCharacter];
        
        this.enemies = [];
        this.boss = null;
        this.projectiles = [];
        this.enemyProjectiles = [];
        this.pickups = [];
        this.itemDrops = [];
        this.floatingTexts = [];
        this.tornadoes = [];
        this.lightningEffects = [];
        this.meteorEffects = [];
        this.particles.particles = [];
        this.particles.bloodStains = [];
        
        this.gameTime = 0;
        this.spawnTimer = 0;
        this.difficulty = 1;
        this.bossSpawned = false;
        this.bossWarningShown = false;
        
        this.updateEquipmentSlots();
    }
    
    restartGame() {
        document.getElementById('gameOverScreen').style.display = 'none';
        document.getElementById('mainMenu').style.display = 'flex';
        document.getElementById('hud').style.display = 'none';
        document.getElementById('equipmentSlots').style.display = 'none';
        this.state = 'menu';
    }
    
    togglePause() {
        if (this.state === 'playing') {
            this.state = 'paused';
            document.getElementById('pauseIndicator').style.display = 'block';
        } else if (this.state === 'paused') {
            this.state = 'playing';
            document.getElementById('pauseIndicator').style.display = 'none';
        }
    }
    
    gameLoop(time) {
        const dt = Math.min((time - this.lastTime) / 1000, 0.1);
        this.lastTime = time;
        
        if (this.state === 'playing') this.update(dt);
        this.draw();
        
        requestAnimationFrame(t => this.gameLoop(t));
    }
    
    update(dt) {
        this.gameTime += dt;
        this.difficulty = 1 + this.gameTime / 60 * 0.5;
        
        // Boss warning at 9:30
        if (this.gameTime >= CONFIG.BOSS_TIME - 30 && !this.bossWarningShown) {
            this.bossWarningShown = true;
            document.getElementById('bossWarning').style.display = 'block';
            this.audio.playBossWarn();
            setTimeout(() => {
                document.getElementById('bossWarning').style.display = 'none';
            }, 3000);
        }
        
        // Spawn boss at 10:00
        if (this.gameTime >= CONFIG.BOSS_TIME && !this.bossSpawned) {
            this.bossSpawned = true;
            const angle = Math.random() * Math.PI * 2;
            this.boss = new Boss(
                this.player.x + Math.cos(angle) * 400,
                this.player.y + Math.sin(angle) * 400
            );
            this.boss.sprite = this.sprites.boss;
        }
        
        // Update global slow
        if (this.globalSlowTimer > 0) {
            this.globalSlowTimer -= dt;
        }
        
        // Update player
        this.player.update(dt, this.input, this);
        
        // Camera
        this.camera.x = this.player.x - this.canvas.width / 2;
        this.camera.y = this.player.y - this.canvas.height / 2;
        
        if (this.screenShake > 0) {
            this.screenShake -= dt;
            this.camera.x += (Math.random() - 0.5) * 10;
            this.camera.y += (Math.random() - 0.5) * 10;
        }
        
        // Spawn enemies
        if (!this.bossSpawned) {
            this.spawnTimer -= dt;
            const spawnRate = 1.5 / (1 + this.player.curseLevel * 0.5);
            if (this.spawnTimer <= 0 && this.enemies.length < 80 + this.player.curseLevel * 20) {
                this.spawnEnemy();
                this.spawnTimer = spawnRate / this.difficulty;
            }
        }
        
        // Update enemies
        const effectiveDt = this.globalSlowTimer > 0 ? dt * 0.5 : dt;
        for (const enemy of this.enemies) {
            enemy.update(effectiveDt, this.player, this.enemies, this);
            
            if (Math.hypot(enemy.x - this.player.x, enemy.y - this.player.y) < (enemy.width + this.player.width) / 2) {
                this.player.takeDamage(enemy.damage, this);
            }
            
            // Aura/orbit damage
            for (const w of this.player.weapons) {
                const wData = WEAPONS[w.id];
                if (wData.type === 'orbit' || wData.type === 'aura') {
                    const range = this.player.getWeaponRange(w);
                    const dist = Math.hypot(enemy.x - this.player.x, enemy.y - this.player.y);
                    if (dist < range + enemy.width / 2) {
                        const dps = this.player.getWeaponDamage(w) * (wData.type === 'aura' ? 1 : 2);
                        if (enemy.takeDamage(dps * dt, this)) {
                            this.killEnemy(enemy);
                        }
                    }
                } else if (wData.type === 'melee') {
                    const range = this.player.getWeaponRange(w);
                    const dist = Math.hypot(enemy.x - this.player.x, enemy.y - this.player.y);
                    const angle = Math.atan2(enemy.y - this.player.y, enemy.x - this.player.x);
                    const playerAngle = this.player.facing > 0 ? 0 : Math.PI;
                    const angleDiff = Math.abs(angle - playerAngle);
                    
                    if (dist < range + enemy.width / 2 && angleDiff < Math.PI / 2) {
                        const timer = this.player.weaponTimers[w.id] || 0;
                        const cd = this.player.getWeaponCooldown(w);
                        if (timer > cd * 0.7 && timer < cd * 0.9) {
                            if (enemy.takeDamage(this.player.getWeaponDamage(w), this)) {
                                this.killEnemy(enemy);
                            }
                        }
                    }
                }
            }
        }
        this.enemies = this.enemies.filter(e => e.health > 0);
        
        // Update boss
        if (this.boss) {
            this.boss.update(dt, this.player, this);
            
            if (Math.hypot(this.boss.x - this.player.x, this.boss.y - this.player.y) < (this.boss.width + this.player.width) / 2) {
                this.player.takeDamage(this.boss.damage, this);
            }
            
            // Boss takes damage from auras
            for (const w of this.player.weapons) {
                const wData = WEAPONS[w.id];
                if (wData.type === 'orbit' || wData.type === 'aura') {
                    const range = this.player.getWeaponRange(w);
                    const dist = Math.hypot(this.boss.x - this.player.x, this.boss.y - this.player.y);
                    if (dist < range + this.boss.width / 2) {
                        this.boss.takeDamage(this.player.getWeaponDamage(w) * dt, this);
                    }
                }
            }
            
            if (this.boss.health <= 0) {
                this.gameOver(true);
            }
        }
        
        // Update projectiles
        for (let i = this.projectiles.length - 1; i >= 0; i--) {
            const p = this.projectiles[i];
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.life -= dt;
            
            if (p.life <= 0) {
                this.projectiles.splice(i, 1);
                continue;
            }
            
            // Hit enemies
            for (const enemy of this.enemies) {
                if (Math.hypot(p.x - enemy.x, p.y - enemy.y) < p.size + enemy.width / 2) {
                    if (enemy.takeDamage(p.damage, this)) {
                        this.killEnemy(enemy);
                    }
                    p.pierce = (p.pierce || 1) - 1;
                    if (p.pierce <= 0) {
                        this.projectiles.splice(i, 1);
                    }
                    break;
                }
            }
            
            // Hit boss
            if (this.boss && Math.hypot(p.x - this.boss.x, p.y - this.boss.y) < p.size + this.boss.width / 2) {
                this.boss.takeDamage(p.damage, this);
                this.projectiles.splice(i, 1);
            }
        }
        
        // Update enemy projectiles
        for (let i = this.enemyProjectiles.length - 1; i >= 0; i--) {
            const p = this.enemyProjectiles[i];
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.life -= dt;
            
            if (p.life <= 0) {
                this.enemyProjectiles.splice(i, 1);
                continue;
            }
            
            if (Math.hypot(p.x - this.player.x, p.y - this.player.y) < p.size + this.player.width / 2) {
                this.player.takeDamage(p.damage, this);
                this.enemyProjectiles.splice(i, 1);
            }
        }
        
        // Update tornadoes
        for (let i = this.tornadoes.length - 1; i >= 0; i--) {
            const t = this.tornadoes[i];
            t.x += t.vx * dt;
            t.y += t.vy * dt;
            t.life -= dt;
            
            if (t.life <= 0) {
                this.tornadoes.splice(i, 1);
                continue;
            }
            
            // Damage and slow enemies
            for (const enemy of this.enemies) {
                if (Math.hypot(t.x - enemy.x, t.y - enemy.y) < t.radius + enemy.width / 2) {
                    enemy.takeDamage(t.damage * dt, this);
                    enemy.slowAmount = t.slowAmount;
                    enemy.slowTimer = 0.5;
                }
            }
        }
        
        // Update lightning effects
        this.lightningEffects = this.lightningEffects.filter(l => {
            l.life -= dt;
            return l.life > 0;
        });
        
        // Update meteor effects
        for (let i = this.meteorEffects.length - 1; i >= 0; i--) {
            const m = this.meteorEffects[i];
            if (m.delay > 0) {
                m.delay -= dt;
                continue;
            }
            
            m.life -= dt;
            
            if (m.life <= 0.5 && !m.hit) {
                m.hit = true;
                this.particles.emit(m.x, m.y, 15, { color: '#ff4500', minSpeed: 80, maxSpeed: 200 });
                
                for (const enemy of this.enemies) {
                    if (Math.hypot(m.x - enemy.x, m.y - enemy.y) < m.radius) {
                        if (enemy.takeDamage(m.damage, this)) {
                            this.killEnemy(enemy);
                        }
                    }
                }
            }
            
            if (m.life <= 0) {
                this.meteorEffects.splice(i, 1);
            }
        }
        
        // Update pickups
        for (let i = this.pickups.length - 1; i >= 0; i--) {
            const p = this.pickups[i];
            p.update(dt);
            
            const dist = Math.hypot(p.x - this.player.x, p.y - this.player.y);
            
            // Magnet
            if (dist < this.player.pickupRange * 2) {
                const angle = Math.atan2(this.player.y - p.y, this.player.x - p.x);
                const speed = 250 * (1 - dist / (this.player.pickupRange * 2));
                p.x += Math.cos(angle) * speed * dt;
                p.y += Math.sin(angle) * speed * dt;
            }
            
            if (dist < this.player.pickupRange) {
                if (p.type === 'xp') {
                    const xpGain = p.value * this.player.xpMult * (1 + this.player.curseLevel);
                    this.player.xp += xpGain;
                    this.audio.playPickup();
                    this.checkLevelUp();
                } else if (p.type === 'gold') {
                    this.player.gold += Math.round(p.value * this.player.goldMult);
                    this.audio.playPickup();
                }
                this.pickups.splice(i, 1);
            }
        }
        
        // Update item drops
        for (let i = this.itemDrops.length - 1; i >= 0; i--) {
            const item = this.itemDrops[i];
            item.update(dt);
            
            const dist = Math.hypot(item.x - this.player.x, item.y - this.player.y);
            if (dist < 30) {
                this.collectItem(item);
                this.itemDrops.splice(i, 1);
            }
        }
        
        // Update floating texts
        this.floatingTexts = this.floatingTexts.filter(t => {
            t.update(dt);
            return t.life > 0;
        });
        
        // Update particles
        this.particles.update(dt);
        
        // Update HUD
        this.updateHUD();
        this.updateEquipmentSlots();
    }
    
    spawnEnemy() {
        const angle = Math.random() * Math.PI * 2;
        const dist = 500 + Math.random() * 100;
        const x = this.player.x + Math.cos(angle) * dist;
        const y = this.player.y + Math.sin(angle) * dist;
        
        // Choose enemy type based on time
        const availableTypes = Object.entries(ENEMIES).filter(([id, data]) => this.gameTime >= data.spawnTime);
        
        // Weight towards newer enemies
        const weights = availableTypes.map(([id, data], i) => Math.pow(2, i));
        const totalWeight = weights.reduce((a, b) => a + b, 0);
        let rand = Math.random() * totalWeight;
        
        let chosenType = availableTypes[0][0];
        for (let i = 0; i < weights.length; i++) {
            rand -= weights[i];
            if (rand <= 0) {
                chosenType = availableTypes[i][0];
                break;
            }
        }
        
        const enemy = new Enemy(x, y, chosenType, this.difficulty);
        enemy.sprite = this.sprites.enemies[chosenType];
        this.enemies.push(enemy);
        
        // Pack spawning
        if (ENEMIES[chosenType].pack) {
            for (let i = 0; i < 3; i++) {
                const packEnemy = new Enemy(
                    x + (Math.random() - 0.5) * 50,
                    y + (Math.random() - 0.5) * 50,
                    chosenType,
                    this.difficulty
                );
                packEnemy.sprite = this.sprites.enemies[chosenType];
                this.enemies.push(packEnemy);
            }
        }
    }
    
    killEnemy(enemy) {
        this.player.kills++;
        this.audio.playPickup();
        this.particles.emitBlood(enemy.x, enemy.y);
        
        // Drop XP
        this.pickups.push(new Pickup(enemy.x, enemy.y, 'xp', enemy.xpValue));
        
        // Drop gold
        if (Math.random() < 0.25) {
            this.pickups.push(new Pickup(
                enemy.x + (Math.random() - 0.5) * 20,
                enemy.y + (Math.random() - 0.5) * 20,
                'gold', 1 + Math.floor(this.difficulty)
            ));
        }
        
        // Drop item
        const dropChance = 0.02 * this.player.luck;
        if (Math.random() < dropChance) {
            this.dropRandomItem(enemy.x, enemy.y);
        }
    }
    
    dropRandomItem(x, y) {
        // Choose rarity based on luck
        const rarityRoll = Math.random() * 100 / this.player.luck;
        let itemRarity;
        if (rarityRoll < 2) itemRarity = 'LEGENDARY';
        else if (rarityRoll < 15) itemRarity = 'RARE';
        else itemRarity = 'COMMON';
        
        const itemsOfRarity = Object.entries(ITEMS).filter(([id, data]) => data.rarity === itemRarity);
        if (itemsOfRarity.length > 0) {
            const [itemId] = itemsOfRarity[Math.floor(Math.random() * itemsOfRarity.length)];
            this.itemDrops.push(new ItemDrop(x, y, itemId));
        }
    }
    
    collectItem(itemDrop) {
        const item = itemDrop.item;
        this.audio.playItemPickup(item.rarity);
        
        // Show notification
        const notif = document.createElement('div');
        notif.className = `item-notification rarity-${RARITY[item.rarity].nameEn}`;
        notif.innerHTML = `${item.icon} ${item.name}`;
        notif.style.borderLeft = `4px solid ${RARITY[item.rarity].color}`;
        document.body.appendChild(notif);
        setTimeout(() => notif.remove(), 2000);
        
        // Apply effect
        switch (item.effect) {
            case 'heal':
                this.player.health = Math.min(this.player.maxHealth, this.player.health + item.value);
                this.floatingTexts.push(new FloatingText(this.player.x, this.player.y - 30, `+${item.value} HP`, '#0f0'));
                break;
            case 'fullHeal':
                this.player.maxHealth += item.value;
                this.player.health = this.player.maxHealth;
                this.floatingTexts.push(new FloatingText(this.player.x, this.player.y - 30, 'ÿ¥ŸÅÿßÿ° ŸÉÿßŸÖŸÑ!', '#0f0', 22));
                break;
            case 'gold':
                this.player.gold += Math.round(item.value * this.player.goldMult);
                break;
            case 'tempSpeed':
                this.player.tempBuffs.push({ type: 'speed', value: item.value, duration: item.duration });
                break;
            case 'tempDamage':
                this.player.tempBuffs.push({ type: 'damage', value: item.value, duration: item.duration });
                break;
            case 'tempAttackSpeed':
                this.player.tempBuffs.push({ type: 'attackSpeed', value: item.value, duration: item.duration });
                break;
            case 'shield':
                this.player.shieldAmount += item.value;
                break;
            case 'slow':
                this.globalSlowTimer = item.duration;
                break;
            case 'revive':
                this.player.hasRevive = true;
                this.floatingTexts.push(new FloatingText(this.player.x, this.player.y - 30, 'ÿ•ÿ≠Ÿäÿßÿ° ŸÖÿ≠ŸÅŸàÿ∏!', '#ffd700', 20));
                break;
            case 'permGold':
                this.player.goldMult += item.value;
                break;
            case 'randomEquip':
                this.giveRandomEquipment();
                break;
        }
    }
    
    giveRandomEquipment() {
        if (Math.random() < 0.5 && this.player.weapons.length < CONFIG.MAX_WEAPONS) {
            const available = Object.keys(WEAPONS).filter(w => !this.player.weapons.find(pw => pw.id === w));
            if (available.length > 0) {
                const weaponId = available[Math.floor(Math.random() * available.length)];
                this.player.weapons.push({ id: weaponId, level: 1, upgrades: [] });
                this.floatingTexts.push(new FloatingText(this.player.x, this.player.y - 40, `ÿ≥ŸÑÿßÿ≠ ÿ¨ÿØŸäÿØ: ${WEAPONS[weaponId].name}`, '#ffd700', 20));
            }
        } else if (this.player.books.length < CONFIG.MAX_BOOKS) {
            const available = Object.keys(BOOKS).filter(b => !this.player.books.find(pb => pb.id === b));
            if (available.length > 0) {
                const bookId = available[Math.floor(Math.random() * available.length)];
                this.player.books.push({ id: bookId, level: 1, upgrades: [] });
                this.applyBookEffect(bookId, 1);
                this.floatingTexts.push(new FloatingText(this.player.x, this.player.y - 40, `ŸÉÿ™ÿßÿ® ÿ¨ÿØŸäÿØ: ${BOOKS[bookId].name}`, '#ffd700', 20));
            }
        }
    }
    
    checkLevelUp() {
        const xpRequired = Math.floor(10 * Math.pow(1.5, this.player.level - 1));
        
        if (this.player.xp >= xpRequired) {
            this.player.xp -= xpRequired;
            this.player.level++;
            this.player.health = Math.min(this.player.maxHealth, this.player.health + this.player.maxHealth * 0.2);
            
            this.audio.playLevelUp();
            this.showLevelUpModal();
        }
    }
    
    showLevelUpModal() {
        this.state = 'levelup';
        const modal = document.getElementById('levelUpModal');
        const options = document.getElementById('upgradeOptions');
        
        // Generate 3 random options
        const choices = [];
        
        // Weapons the player has or can get
        const availableWeapons = [];
        for (const w of this.player.weapons) {
            if (w.level < CONFIG.MAX_UPGRADE_LEVEL) {
                availableWeapons.push({ type: 'weapon', id: w.id, isNew: false });
            }
        }
        if (this.player.weapons.length < CONFIG.MAX_WEAPONS) {
            const newWeapons = Object.keys(WEAPONS).filter(w => !this.player.weapons.find(pw => pw.id === w));
            newWeapons.forEach(w => availableWeapons.push({ type: 'weapon', id: w, isNew: true }));
        }
        
        // Books the player has or can get
        const availableBooks = [];
        for (const b of this.player.books) {
            if (b.level < CONFIG.MAX_UPGRADE_LEVEL) {
                availableBooks.push({ type: 'book', id: b.id, isNew: false });
            }
        }
        if (this.player.books.length < CONFIG.MAX_BOOKS) {
            const newBooks = Object.keys(BOOKS).filter(b => !this.player.books.find(pb => pb.id === b));
            newBooks.forEach(b => availableBooks.push({ type: 'book', id: b, isNew: true }));
        }
        
        const allOptions = [...availableWeapons, ...availableBooks];
        
        // Pick 3 unique options
        while (choices.length < 3 && allOptions.length > 0) {
            const idx = Math.floor(Math.random() * allOptions.length);
            choices.push(allOptions.splice(idx, 1)[0]);
        }
        
        options.innerHTML = '';
        
        choices.forEach(choice => {
            const rarity = getRandomRarity();
            const card = document.createElement('div');
            card.className = `upgrade-card rarity-glow-${rarity.nameEn}`;
            card.style.borderColor = rarity.color;
            
            let data, icon, currentLevel;
            if (choice.type === 'weapon') {
                data = WEAPONS[choice.id];
                icon = data.icon;
                currentLevel = choice.isNew ? 0 : this.player.weapons.find(w => w.id === choice.id).level;
            } else {
                data = BOOKS[choice.id];
                icon = data.icon;
                currentLevel = choice.isNew ? 0 : this.player.books.find(b => b.id === choice.id).level;
            }
            
            card.innerHTML = `
                <div style="font-size: 2.5rem; margin-bottom: 10px;">${icon}</div>
                <div class="upgrade-name" style="color: ${rarity.color}">${data.name}</div>
                <div class="upgrade-type">${choice.type === 'weapon' ? 'ÿ≥ŸÑÿßÿ≠' : 'ŸÉÿ™ÿßÿ®'}</div>
                <div class="upgrade-level">${choice.isNew ? 'ÿ¨ÿØŸäÿØ!' : `ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ ${currentLevel} ‚Üí ${currentLevel + 1}`}</div>
                <div class="upgrade-desc">${data.desc}</div>
                <div class="upgrade-rarity" style="background: ${rarity.color}30; color: ${rarity.color}">${rarity.name}</div>
            `;
            
            card.addEventListener('click', () => {
                this.selectUpgrade(choice, rarity);
                modal.style.display = 'none';
                this.state = 'playing';
            });
            
            options.appendChild(card);
        });
        
        modal.style.display = 'flex';
    }
    
    selectUpgrade(choice, rarity) {
        if (choice.type === 'weapon') {
            if (choice.isNew) {
                this.player.weapons.push({ id: choice.id, level: 1, upgrades: [{ rarity }] });
            } else {
                const weapon = this.player.weapons.find(w => w.id === choice.id);
                weapon.level++;
                weapon.upgrades.push({ rarity });
            }
        } else {
            if (choice.isNew) {
                this.player.books.push({ id: choice.id, level: 1, upgrades: [{ rarity }] });
                this.applyBookEffect(choice.id, 1, rarity);
            } else {
                const book = this.player.books.find(b => b.id === choice.id);
                book.level++;
                book.upgrades.push({ rarity });
                this.applyBookEffect(choice.id, book.level, rarity);
            }
        }
        
        this.updateEquipmentSlots();
    }
    
    applyBookEffect(bookId, level, rarity = RARITY.COMMON) {
        const book = BOOKS[bookId];
        const value = book.baseValue * rarity.multiplier;
        
        switch (book.stat) {
            case 'damage': this.player.damage += value; break;
            case 'attackSpeed': this.player.attackSpeed += value; break;
            case 'moveSpeed': this.player.speed += this.player.speed * value; break;
            case 'xpGain': this.player.xpMult += value; break;
            case 'maxHealth':
                const hpIncrease = this.player.maxHealth * value;
                this.player.maxHealth += hpIncrease;
                this.player.health += hpIncrease;
                break;
            case 'armor': this.player.armor += value * 10; break;
            case 'pickup': this.player.pickupRange += this.player.pickupRange * value; break;
            case 'luck': this.player.luck += value; break;
            case 'curse': this.player.curseLevel += value; break;
            case 'regen': this.player.regen += value; break;
        }
    }
    
    gameOver(victory) {
        this.state = 'gameover';
        document.getElementById('hud').style.display = 'none';
        document.getElementById('equipmentSlots').style.display = 'none';
        
        if (victory) {
            this.audio.playVictory();
            document.getElementById('gameOverTitle').textContent = 'üéâ ÿßŸÜÿ™ÿµÿßÿ±! üéâ';
            document.getElementById('gameOverTitle').className = 'game-over-title victory-title';
        } else {
            this.audio.playDeath();
            document.getElementById('gameOverTitle').textContent = 'ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑŸÑÿπÿ®ÿ©';
            document.getElementById('gameOverTitle').className = 'game-over-title';
        }
        
        // Save high score
        if (this.player.kills > this.highScore) {
            this.highScore = this.player.kills;
            localStorage.setItem('goldBloodHighScore', this.highScore.toString());
            document.getElementById('highScore').textContent = this.highScore;
        }
        
        const mins = Math.floor(this.gameTime / 60);
        const secs = Math.floor(this.gameTime % 60);
        
        document.getElementById('finalStats').innerHTML = `
            <p>‚è±Ô∏è ÿßŸÑŸàŸÇÿ™: ${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}</p>
            <p>‚≠ê ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ: ${this.player.level}</p>
            <p>üíÄ ÿßŸÑŸÇÿ™ŸÑŸâ: ${this.player.kills}</p>
            <p>üí∞ ÿßŸÑÿ∞Ÿáÿ®: ${this.player.gold}</p>
            <p>‚öîÔ∏è ÿßŸÑÿ£ÿ≥ŸÑÿ≠ÿ©: ${this.player.weapons.length}</p>
            <p>üìö ÿßŸÑŸÉÿ™ÿ®: ${this.player.books.length}</p>
        `;
        
        document.getElementById('gameOverScreen').style.display = 'flex';
    }
    
    updateHUD() {
        const healthPercent = (this.player.health / this.player.maxHealth) * 100;
        document.getElementById('healthBar').style.width = `${healthPercent}%`;
        document.getElementById('healthText').textContent = `${Math.ceil(this.player.health)}/${Math.ceil(this.player.maxHealth)}`;
        
        const xpRequired = Math.floor(10 * Math.pow(1.5, this.player.level - 1));
        const xpPercent = (this.player.xp / xpRequired) * 100;
        document.getElementById('xpBar').style.width = `${xpPercent}%`;
        document.getElementById('xpText').textContent = `${Math.floor(this.player.xp)}/${xpRequired}`;
        
        document.getElementById('levelText').textContent = `ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ: ${this.player.level}`;
        document.getElementById('goldText').textContent = this.player.gold;
        document.getElementById('killText').textContent = this.player.kills;
        
        const mins = Math.floor(this.gameTime / 60);
        const secs = Math.floor(this.gameTime % 60);
        document.getElementById('timerText').textContent = `‚è±Ô∏è ${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
    
    draw() {
        const ctx = this.ctx;
        
        ctx.fillStyle = '#1a1510';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        if (this.state === 'menu') {
            this.drawMenuBackground();
            return;
        }
        
        if (['playing', 'paused', 'levelup', 'gameover'].includes(this.state)) {
            this.drawGame();
        }
    }
    
    drawMenuBackground() {
        const ctx = this.ctx;
        const time = Date.now() / 1000;
        
        for (let i = 0; i < 5; i++) {
            const y = this.canvas.height * 0.4 + i * 80;
            ctx.fillStyle = `rgba(${60 + i * 10}, ${50 + i * 5}, ${30 + i * 3}, 0.5)`;
            ctx.beginPath();
            ctx.moveTo(0, y);
            for (let x = 0; x <= this.canvas.width; x += 50) {
                ctx.lineTo(x, y + Math.sin(x * 0.01 + time + i) * 20);
            }
            ctx.lineTo(this.canvas.width, this.canvas.height);
            ctx.lineTo(0, this.canvas.height);
            ctx.fill();
        }
    }
    
    drawGame() {
        const ctx = this.ctx;
        
        // Background
        this.drawBackground();
        
        // Blood stains
        this.particles.draw(ctx, this.camera);
        
        // Pickups
        for (const p of this.pickups) p.draw(ctx, this.camera);
        
        // Item drops
        for (const item of this.itemDrops) item.draw(ctx, this.camera);
        
        // Tornadoes
        for (const t of this.tornadoes) {
            const sx = t.x - this.camera.x;
            const sy = t.y - this.camera.y;
            ctx.strokeStyle = 'rgba(200, 180, 150, 0.7)';
            ctx.lineWidth = 3;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.arc(sx, sy, t.radius - i * 10, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        
        // Meteor warnings
        for (const m of this.meteorEffects) {
            if (m.delay > 0) continue;
            const sx = m.x - this.camera.x;
            const sy = m.y - this.camera.y;
            
            if (m.life > 0.5) {
                // Warning circle
                ctx.strokeStyle = 'rgba(255, 100, 0, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(sx, sy, m.radius, 0, Math.PI * 2);
                ctx.stroke();
            } else {
                // Impact
                ctx.fillStyle = 'rgba(255, 100, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(sx, sy, m.radius * (1 - m.life / 0.5), 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Lightning effects
        for (const l of this.lightningEffects) {
            const sx = l.x - this.camera.x;
            const sy = l.y - this.camera.y;
            ctx.strokeStyle = `rgba(255, 255, 100, ${l.life / 0.3})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(sx, sy - 500);
            ctx.lineTo(sx, sy);
            ctx.stroke();
            
            ctx.fillStyle = `rgba(255, 255, 200, ${l.life / 0.3 * 0.5})`;
            ctx.beginPath();
            ctx.arc(sx, sy, 30, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Enemies
        for (const e of this.enemies) e.draw(ctx, this.camera);
        
        // Boss
        if (this.boss) this.boss.draw(ctx, this.camera);
        
        // Player
        this.player.draw(ctx, this.camera);
        
        // Projectiles
        for (const p of this.projectiles) {
            const sx = p.x - this.camera.x;
            const sy = p.y - this.camera.y;
            
            const grad = ctx.createRadialGradient(sx, sy, 0, sx, sy, p.size * 2);
            grad.addColorStop(0, p.color);
            grad.addColorStop(1, 'transparent');
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(sx, sy, p.size * 2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(sx, sy, p.size / 2, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Enemy projectiles
        for (const p of this.enemyProjectiles) {
            const sx = p.x - this.camera.x;
            const sy = p.y - this.camera.y;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(sx, sy, p.size, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Floating texts
        for (const t of this.floatingTexts) t.draw(ctx, this.camera);
        
        // Lighting
        this.drawLighting();
        
        // Virtual joystick
        if (this.input.joystick) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.beginPath();
            ctx.arc(100, this.canvas.height - 100, 60, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'rgba(255, 215, 0, 0.4)';
            ctx.beginPath();
            ctx.arc(100 + this.input.joystick.x * 40, this.canvas.height - 100 + this.input.joystick.y * 40, 25, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Boss health bar at top
        if (this.boss) {
            const barW = 400;
            const barX = (this.canvas.width - barW) / 2;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(barX - 5, 50, barW + 10, 30);
            
            ctx.fillStyle = '#333';
            ctx.fillRect(barX, 55, barW, 20);
            
            const healthColor = this.boss.phase === 3 ? '#ff0000' : this.boss.phase === 2 ? '#ff8800' : '#ffff00';
            ctx.fillStyle = healthColor;
            ctx.fillRect(barX, 55, barW * (this.boss.health / this.boss.maxHealth), 20);
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px Cairo';
            ctx.textAlign = 'center';
            ctx.fillText(`${BOSS.name} - ÿßŸÑŸÖÿ±ÿ≠ŸÑÿ© ${this.boss.phase}`, this.canvas.width / 2, 48);
        }
    }
    
    drawBackground() {
        const ctx = this.ctx;
        const tileSize = CONFIG.TILE_SIZE;
        
        const startX = Math.floor(this.camera.x / tileSize) - 1;
        const startY = Math.floor(this.camera.y / tileSize) - 1;
        const endX = Math.ceil((this.camera.x + this.canvas.width) / tileSize) + 1;
        const endY = Math.ceil((this.camera.y + this.canvas.height) / tileSize) + 1;
        
        for (let y = startY; y <= endY; y++) {
            for (let x = startX; x <= endX; x++) {
                const sx = x * tileSize - this.camera.x;
                const sy = y * tileSize - this.camera.y;
                
                const noise = Math.sin(x * 0.5) * Math.cos(y * 0.5) * 0.1;
                const r = Math.floor(210 + noise * 30);
                const g = Math.floor(180 + noise * 20);
                const b = Math.floor(140 + noise * 10);
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                ctx.fillRect(sx, sy, tileSize + 1, tileSize + 1);
                
                // Props
                const seed = Math.abs(Math.sin(x * 12.9898 + y * 78.233) * 43758.5453) % 1;
                if (seed < 0.02) {
                    ctx.fillStyle = '#5a5a5a';
                    ctx.beginPath();
                    ctx.arc(sx + tileSize/2, sy + tileSize/2, 6 + seed * 8, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
    }
    
    drawLighting() {
        const ctx = this.ctx;
        
        ctx.fillStyle = 'rgba(0, 0, 0, 0.35)';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        const px = this.player.x - this.camera.x;
        const py = this.player.y - this.camera.y;
        
        ctx.globalCompositeOperation = 'destination-out';
        
        const grad = ctx.createRadialGradient(px, py, 0, px, py, CONFIG.PLAYER_LIGHT_RADIUS);
        grad.addColorStop(0, 'rgba(0, 0, 0, 1)');
        grad.addColorStop(0.5, 'rgba(0, 0, 0, 0.5)');
        grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(px, py, CONFIG.PLAYER_LIGHT_RADIUS, 0, Math.PI * 2);
        ctx.fill();
        
        // Projectile lights
        for (const p of this.projectiles) {
            const sx = p.x - this.camera.x;
            const sy = p.y - this.camera.y;
            const pGrad = ctx.createRadialGradient(sx, sy, 0, sx, sy, 40);
            pGrad.addColorStop(0, 'rgba(0, 0, 0, 0.7)');
            pGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = pGrad;
            ctx.beginPath();
            ctx.arc(sx, sy, 40, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.globalCompositeOperation = 'source-over';
        
        ctx.fillStyle = 'rgba(255, 200, 100, 0.04)';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }
}

// Start
window.addEventListener('load', () => new Game());
    </script>
</body>
</html>
