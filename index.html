<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, viewport-fit=cover">
    <title>Ø°Ù‡Ø¨ Ø£ØµÙØ± Ø£Ùˆ Ø¯Ù… Ø£Ø­Ù…Ø± - Gold or Blood</title>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700;900&family=Changa:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Custom Pixel Arabic Font */
        @font-face {
            font-family: 'PixelAE';
            src: url('assets/font/PixelAE-Regular.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }
        @font-face {
            font-family: 'PixelAE';
            src: url('assets/font/PixelAE-Bold.ttf') format('truetype');
            font-weight: bold;
            font-style: normal;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
        body { background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0f0f1a 100%); font-family: 'PixelAE', 'Cairo', sans-serif; overflow: hidden; min-height: 100vh; color: #fff; }
        #gameCanvas { display: block; position: absolute; top: 0; left: 0; }
        
        .rarity-common { color: #9d9d9d; }
        .rarity-uncommon { color: #1eff00; }
        .rarity-rare { color: #0070dd; }
        .rarity-epic { color: #a335ee; }
        .rarity-legendary { color: #ff8000; }
        
        /* Safe area for mobile browsers */
        :root {
            --safe-top: env(safe-area-inset-top, 10px);
            --safe-bottom: env(safe-area-inset-bottom, 20px);
            --safe-left: env(safe-area-inset-left, 15px);
            --safe-right: env(safe-area-inset-right, 15px);
        }
        
        #mainMenu { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            display: flex; flex-direction: column; align-items: center; 
            justify-content: flex-start; /* Changed from center to allow scrolling */
            z-index: 100; background: linear-gradient(180deg, rgba(10,10,15,0.97) 0%, rgba(26,26,46,0.98) 100%); 
            padding: 15px;
            padding-top: max(15px, var(--safe-top));
            padding-bottom: max(20px, var(--safe-bottom));
            padding-left: max(10px, var(--safe-left));
            padding-right: max(10px, var(--safe-right));
            box-sizing: border-box;
            overflow-y: auto; /* Allow scrolling */
            -webkit-overflow-scrolling: touch;
            gap: 10px;
        }
        .menu-title { font-size: clamp(1.3rem, 4vw, 2rem); font-weight: 900; text-align: center; margin-bottom: 2px; background: linear-gradient(135deg, #ffd700 0%, #ff8c00 50%, #ffd700 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
        .menu-subtitle { font-size: clamp(0.7rem, 2vw, 0.9rem); color: #888; margin-bottom: 8px; }
        
        .character-select { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; flex-shrink: 0; }
        .char-arrow { width: 50px; height: 50px; background: rgba(255, 215, 0, 0.1); border: 2px solid rgba(255, 215, 0, 0.3); border-radius: 50%; color: #ffd700; font-size: 1.5rem; cursor: pointer; transition: all 0.3s; display: flex; align-items: center; justify-content: center; }
        .char-arrow:hover { background: rgba(255, 215, 0, 0.2); border-color: #ffd700; transform: scale(1.1); }
        
        .character-display { width: 260px; padding: 12px; background: rgba(30, 30, 40, 0.9); border: 2px solid rgba(255, 215, 0, 0.3); border-radius: 15px; text-align: center; flex-shrink: 0; }
        .char-preview { width: 90px; height: 90px; margin: 0 auto 8px; image-rendering: pixelated; border-radius: 8px; background: rgba(0,0,0,0.3); }
        .char-name { font-size: 1.2rem; font-weight: 900; color: #ffd700; margin-bottom: 3px; }
        .char-title { font-size: 0.75rem; color: #888; margin-bottom: 5px; }
        .char-desc { font-size: 0.7rem; color: #aaa; margin-bottom: 8px; line-height: 1.3; min-height: 30px; }
        .char-stats { background: rgba(0,0,0,0.3); padding: 8px; border-radius: 8px; margin-bottom: 8px; }
        .char-stat { display: flex; justify-content: space-between; font-size: 0.7rem; margin: 3px 0; }
        .char-stat-label { color: #888; }
        .char-stat-value { color: #4f4; font-weight: bold; }
        .char-stat-negative { color: #f44; }
        .char-weapon { font-size: 0.7rem; color: #ff8888; padding: 6px; background: rgba(255,0,0,0.1); border-radius: 6px; }
        
        .city-select { 
            display: flex; gap: 8px; margin-bottom: 10px; 
            max-width: 100%; overflow-x: auto; 
            padding: 5px; 
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            flex-shrink: 0;
        }
        .city-select::-webkit-scrollbar { display: none; }
        .city-card { 
            min-width: 95px; width: 95px; flex-shrink: 0;
            padding: 10px 6px; background: rgba(30, 30, 40, 0.9); 
            border: 2px solid rgba(100, 100, 100, 0.3); border-radius: 10px; 
            cursor: pointer; transition: all 0.2s; text-align: center; 
        }
        .city-card:hover:not(.locked), .city-card.selected { border-color: #ffd700; background: rgba(255, 215, 0, 0.1); }
        .city-card.locked { opacity: 0.5; cursor: not-allowed; }
        .city-icon { font-size: 1.8rem; margin-bottom: 4px; }
        .city-name { font-size: 0.8rem; font-weight: bold; color: #ffd700; margin-bottom: 3px; }
        .city-desc { font-size: 0.7rem; color: #888; }
        .city-locked { font-size: 0.7rem; color: #f44; margin-top: 8px; }
        
        .btn { padding: 12px 40px; font-size: 1.1rem; font-family: 'PixelAE', sans-serif; font-weight: 700; border: none; border-radius: 50px; cursor: pointer; transition: all 0.3s ease; }
        .btn-primary { background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%); color: #000; box-shadow: 0 6px 20px rgba(255, 215, 0, 0.4); }
        .btn-primary:hover { transform: scale(1.03); box-shadow: 0 8px 25px rgba(255, 215, 0, 0.5); }
        .high-score { margin-top: 5px; font-size: 0.75rem; color: #666; }
        
        /* Bottom buttons container with safe spacing */
        .menu-buttons { 
            display: flex; flex-direction: column; align-items: center; gap: 6px;
            width: 100%;
            max-width: 280px;
            flex-shrink: 0;
            margin-top: auto; /* Push to bottom if there's space */
            padding-bottom: 5px;
        }
        
        /* Pixel-style HUD - Retro Style (Like reference image) */
        #hud { 
            position: fixed; 
            top: max(6px, var(--safe-top)); 
            left: max(6px, var(--safe-left)); 
            display: none; z-index: 50; pointer-events: none; 
            image-rendering: pixelated; font-family: 'PixelAE', monospace; 
        }
        .hud-left { display: flex; flex-direction: column; gap: 2px; }
        .hud-right { 
            position: fixed; 
            top: max(6px, var(--safe-top)); 
            right: max(6px, var(--safe-right)); 
            display: flex; flex-direction: column; gap: 3px; align-items: flex-end; 
        }
        
        /* Main HUD panel - dark solid frame like reference */
        .hud-panel { 
            background: #2a2530;
            border: 3px solid #1a1518;
            padding: 4px;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        /* Character avatar box - like reference bunny icon */
        .hud-avatar {
            width: 36px;
            height: 36px;
            background: #1a1518;
            border: 2px solid #3a3540;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3rem;
        }
        
        /* Bars container */
        .hud-bars {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        /* HP/XP bars - pixel style like reference */
        .hud-bar { 
            width: 110px; 
            height: 10px; 
            background: #0a0808; 
            border: 1px solid #3a3540;
            overflow: hidden; 
            position: relative;
        }
        .hud-bar-fill { height: 100%; transition: width 0.1s linear; }
        .hud-bar-text { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            font-size: 7px; 
            font-weight: bold; 
            text-shadow: 1px 1px 0 #000; 
            white-space: nowrap; 
            z-index: 10; 
            color: #fff;
            letter-spacing: 0.5px;
        }
        /* Red HP bar like reference */
        .health-fill { background: linear-gradient(180deg, #ff4444 0%, #cc2222 100%); }
        /* Green XP bar like reference */
        .xp-fill { background: linear-gradient(180deg, #44ff44 0%, #22cc22 100%); }
        
        /* Gold counter - separate box below */
        .hud-gold {
            background: #2a2530;
            border: 3px solid #1a1518;
            padding: 2px 10px;
            display: flex;
            align-items: center;
            gap: 4px;
            margin-left: 0px;
        }
        .hud-gold-icon { font-size: 14px; }
        .hud-gold-text { color: #ffd700; font-size: 12px; font-weight: bold; text-shadow: 1px 1px 0 #000; letter-spacing: 1px; }
        
        /* Right side stats - compact boxes */
        .hud-stat { 
            font-size: 11px; 
            font-weight: 700; 
            text-shadow: 1px 1px 0 #000; 
            display: flex; 
            align-items: center; 
            gap: 4px; 
            padding: 3px 8px; 
            background: #2a2530;
            border: 2px solid #1a1518;
            color: #fff;
        }
        .hud-stat-icon { font-size: 12px; }
        .kill-text { color: #ff6666; }
        .level-text { color: #88ff88; }
        .timer-text { color: #88ccff; }
        
        /* Equipment slots - smaller for mobile */
        .equipment-slots { 
            position: fixed; 
            bottom: max(8px, var(--safe-bottom)); 
            left: 50%; 
            transform: translateX(-50%); 
            display: none; gap: 6px; z-index: 50; 
            pointer-events: none; 
            max-width: calc(100vw - 110px - max(16px, var(--safe-right))); /* Leave space for minimap */
        }
        .slot-group { display: flex; gap: 4px; padding: 5px 8px; background: #3d3846; border: 2px solid #5a5060; }
        .equipment-slot { width: 32px; height: 32px; background: #2a2530; border: 2px solid #5a5060; display: flex; align-items: center; justify-content: center; position: relative; font-size: 1rem; }
        .equipment-slot:hover { border-color: #ffd700; }
        .slot-level { position: absolute; bottom: -2px; right: -2px; background: #ffd700; color: #000; font-size: 0.5rem; padding: 1px 3px; font-weight: bold; }
        
        #levelUpModal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); display: none; justify-content: center; align-items: center; z-index: 200; }
        .level-up-content { text-align: center; padding: 25px; background: rgba(20, 20, 30, 0.95); border: 3px solid #ffd700; border-radius: 20px; max-width: 95%; max-height: 85vh; overflow-y: auto; }
        .level-up-title { font-size: 1.6rem; color: #ffd700; margin-bottom: 20px; }
        .upgrade-options { display: flex; gap: 8px; flex-wrap: nowrap; justify-content: center; align-items: stretch; }
        .upgrade-card { width: 100px; min-width: 80px; flex: 1; max-width: 120px; padding: 8px; background: #3d3846; border: 3px solid #5a5060; cursor: pointer; transition: all 0.2s ease; text-align: center; }
        .upgrade-card:hover { transform: scale(1.02); border-color: #ffd700; }
        .upgrade-icon { font-size: 1.5rem; margin-bottom: 5px; }
        .upgrade-name { font-size: 0.75rem; font-weight: bold; margin-bottom: 3px; }
        .upgrade-type { font-size: 0.6rem; color: #888; margin-bottom: 3px; }
        .upgrade-level { font-size: 0.75rem; margin-bottom: 4px; }
        .upgrade-desc { font-size: 0.65rem; color: #aaa; }
        .upgrade-rarity { font-size: 0.65rem; font-weight: bold; margin-top: 6px; padding: 2px 6px; border-radius: 8px; display: inline-block; }
        
        /* Item Pickup Modal */
        #itemPickupModal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); display: none; justify-content: center; align-items: center; z-index: 250; }
        .item-pickup-content { text-align: center; padding: 30px; background: rgba(20, 20, 30, 0.95); border: 3px solid #ffd700; border-radius: 20px; max-width: 320px; }
        .item-pickup-icon { font-size: 4rem; margin-bottom: 15px; }
        .item-pickup-name { font-size: 1.4rem; font-weight: bold; margin-bottom: 8px; }
        .item-pickup-rarity { font-size: 0.85rem; margin-bottom: 12px; padding: 4px 12px; border-radius: 10px; display: inline-block; }
        .item-pickup-desc { font-size: 0.95rem; color: #ccc; margin-bottom: 20px; line-height: 1.5; }
        .item-pickup-btn { padding: 10px 30px; font-size: 1rem; font-family: 'PixelAE', sans-serif; font-weight: 700; border: none; border-radius: 25px; cursor: pointer; background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%); color: #000; }
        
        #gameOverScreen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.9); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 300; }
        .game-over-title { font-size: 2rem; color: #ff0000; margin-bottom: 15px; text-shadow: 0 0 20px rgba(255, 0, 0, 0.8); }
        .victory-title { color: #ffd700 !important; text-shadow: 0 0 20px rgba(255, 215, 0, 0.8) !important; }
        .final-stats { margin-bottom: 20px; font-size: 1rem; line-height: 1.6; }
        .unlock-message { color: #ffd700; font-size: 1.1rem; margin-bottom: 15px; padding: 10px 20px; background: rgba(255, 215, 0, 0.1); border-radius: 10px; }
        
        #bossWarning { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 2rem; color: #ff0000; text-shadow: 0 0 30px rgba(255, 0, 0, 0.8); display: none; z-index: 150; text-align: center; animation: bossWarn 0.5s ease-in-out infinite alternate; }
        @keyframes bossWarn { from { transform: translate(-50%, -50%) scale(1); } to { transform: translate(-50%, -50%) scale(1.1); } }
        @keyframes pulse { 0%, 100% { opacity: 1; box-shadow: 0 0 15px rgba(255, 50, 50, 0.5); } 50% { opacity: 0.7; box-shadow: 0 0 25px rgba(255, 0, 0, 0.8); } }
        
        #pauseIndicator { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 2rem; color: #ffd700; display: none; z-index: 150; }
        
        /* Pause Button */
        #pauseBtn { 
            position: fixed; 
            top: max(10px, var(--safe-top)); 
            left: 50%; 
            transform: translateX(-50%); 
            width: 44px; height: 44px; 
            background: rgba(0,0,0,0.6); 
            border: 2px solid rgba(255,215,0,0.5); 
            border-radius: 50%; 
            color: #ffd700; font-size: 1.3rem; 
            cursor: pointer; z-index: 60; 
            display: none; transition: all 0.2s; 
        }
        #pauseBtn:hover { background: rgba(255,215,0,0.2); border-color: #ffd700; }
        
        /* Pause Menu - Pixel Style - Mobile Friendly */
        #pauseMenu { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; flex-direction: column; justify-content: center; align-items: center; gap: 10px; z-index: 200; image-rendering: pixelated; overflow-y: auto; padding: 10px; box-sizing: border-box; }
        .pause-title { font-size: 1.2rem; color: #ffd700; margin-bottom: 8px; text-shadow: 2px 2px #000; }
        
        /* Stats Panel */
        .pause-stats-panel { background: #3d3846; border: 3px solid #8b7355; padding: 10px; width: 90%; max-width: 280px; image-rendering: pixelated; }
        .pause-stats-title { font-size: 0.9rem; color: #ffd700; margin-bottom: 8px; text-align: center; border-bottom: 2px solid #8b7355; padding-bottom: 5px; }
        .pause-char-preview { width: 48px; height: 48px; margin: 0 auto 8px; background: #2a2530; border: 2px solid #5a5060; display: flex; align-items: center; justify-content: center; }
        .pause-char-preview canvas { image-rendering: pixelated; width: 48px; height: 48px; }
        .pause-stat-row { display: flex; justify-content: space-between; align-items: center; padding: 2px 0; font-size: 0.7rem; }
        .pause-stat-icon { width: 14px; height: 14px; margin-right: 4px; }
        .pause-stat-name { color: #ccc; display: flex; align-items: center; }
        .pause-stat-value { color: #4f4; font-weight: bold; }
        .pause-stat-value.negative { color: #f44; }
        
        /* Controls Panel */
        .pause-controls { background: #3d3846; border: 3px solid #8b7355; padding: 12px; width: 90%; max-width: 280px; }
        .volume-control { margin: 8px 0; }
        .volume-label { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; font-size: 0.7rem; color: #ccc; }
        .volume-label span:last-child { color: #ffd700; font-weight: bold; }
        .volume-slider { width: 100%; height: 6px; -webkit-appearance: none; background: #2a2530; border: 2px solid #5a5060; outline: none; }
        .volume-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 12px; height: 12px; background: #ffd700; cursor: pointer; border: 1px solid #000; }
        .volume-slider::-moz-range-thumb { width: 12px; height: 12px; background: #ffd700; cursor: pointer; border: 1px solid #000; }
        .pause-buttons { display: flex; flex-direction: column; gap: 6px; margin-top: 12px; }
        .pause-btn { padding: 8px 15px; font-size: 0.8rem; font-family: 'PixelAE', sans-serif; font-weight: 700; border: 2px solid #000; cursor: pointer; transition: all 0.1s; }
        .pause-btn-resume { background: #c9a66b; color: #000; border-color: #8b7355; }
        .pause-btn-resume:hover { background: #dab77c; }
        .pause-btn-quit { background: #8b4444; color: #fff; border-color: #5a2020; }
        .pause-btn-quit:hover { background: #a05555; }
        
        /* Mini Map */
        #miniMap { 
            position: fixed; 
            bottom: max(8px, var(--safe-bottom)); 
            right: max(8px, var(--safe-right)); 
            width: 90px; height: 90px; 
            background: #2a2530; 
            border: 2px solid #5a5060; 
            display: none; z-index: 55; overflow: hidden; 
            border-radius: 6px;
        }
        #miniMapCanvas { width: 100%; height: 100%; }
        
        /* Damage numbers animation */
        @keyframes floatUp { 0% { opacity: 1; transform: translateY(0); } 100% { opacity: 0; transform: translateY(-30px); } }
        
        @media (max-width: 600px) {
            #mainMenu { 
                padding: 10px;
                padding-top: max(10px, var(--safe-top));
                padding-bottom: max(15px, var(--safe-bottom));
                gap: 8px;
            }
            .menu-title { font-size: 1.2rem; }
            .menu-subtitle { font-size: 0.7rem; margin-bottom: 5px; }
            .character-select { gap: 8px; margin-bottom: 8px; }
            .char-arrow { width: 40px; height: 40px; font-size: 1.2rem; }
            .character-display { width: 200px; padding: 10px; }
            .char-preview { width: 70px; height: 70px; }
            .char-name { font-size: 1rem; }
            .char-title { font-size: 0.65rem; }
            .char-desc { font-size: 0.6rem; min-height: 25px; }
            .char-stats { padding: 6px; }
            .char-stat { font-size: 0.65rem; }
            .char-weapon { font-size: 0.7rem; padding: 5px; }
            .city-select { gap: 6px; margin-bottom: 8px; }
            .city-card { min-width: 85px; width: 85px; padding: 8px 5px; }
            .city-icon { font-size: 1.5rem; margin-bottom: 3px; }
            .city-name { font-size: 0.7rem; }
            .city-desc { font-size: 0.55rem; }
            .btn { padding: 8px 25px; font-size: 0.9rem; }
            .menu-buttons { gap: 5px; }
            .high-score { font-size: 0.65rem; }
            .upgrade-card { width: 85px; min-width: 70px; padding: 6px; font-size: 0.75rem; }
            .upgrade-icon { font-size: 1.2rem; }
            .hud-panel { padding: 4px; gap: 4px; }
            .hud-avatar { width: 32px; height: 32px; font-size: 1.1rem; }
            .hud-bar { width: 90px; height: 10px; }
            .hud-bar-text { font-size: 7px; }
            .hud-gold { margin-left: 38px; padding: 2px 6px; }
            .hud-gold-text { font-size: 10px; }
            .hud-stat { font-size: 0.6rem; padding: 2px 5px; }
            .pause-stats-panel, .pause-controls { width: 95%; max-width: 250px; padding: 8px; }
            .pause-stat-row { font-size: 0.65rem; }
            .equipment-slot { width: 28px; height: 28px; font-size: 0.85rem; }
            
            /* Minimap smaller on mobile */
            #miniMap { width: 70px; height: 70px; }
            .equipment-slots { max-width: calc(100vw - 90px - max(12px, var(--safe-right))); }
        }
        
        /* Extra small screens (iPhone SE, etc) */
        @media (max-width: 380px) {
            #mainMenu { padding: 8px; gap: 6px; }
            .menu-title { font-size: 1rem; }
            .character-select { gap: 5px; }
            .char-arrow { width: 35px; height: 35px; font-size: 1rem; }
            .character-display { width: 180px; padding: 8px; }
            .char-preview { width: 60px; height: 60px; }
            .char-name { font-size: 0.9rem; }
            .city-card { min-width: 75px; width: 75px; padding: 6px 4px; }
            .city-icon { font-size: 1.3rem; }
            .city-name { font-size: 0.6rem; }
            .city-desc { font-size: 0.5rem; }
            .btn { padding: 7px 20px; font-size: 0.8rem; }
            
            /* Even smaller minimap */
            #miniMap { width: 60px; height: 60px; }
            .equipment-slots { max-width: calc(100vw - 80px - max(10px, var(--safe-right))); }
            .equipment-slot { width: 24px; height: 24px; font-size: 0.75rem; }
        }
        
        /* Very small height screens (landscape or small phones) */
        @media (max-height: 700px) {
            .character-display { padding: 8px; }
            .char-preview { width: 60px; height: 60px; margin-bottom: 5px; }
            .char-desc { display: none; }
            .char-stats { padding: 5px; margin-bottom: 5px; }
            .city-card { padding: 6px 4px; }
            .city-icon { font-size: 1.3rem; margin-bottom: 2px; }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="mainMenu">
        <h1 class="menu-title">Ø°Ù‡Ø¨ Ø£ØµÙØ± Ø£Ùˆ Ø¯Ù… Ø£Ø­Ù…Ø±</h1>
        <p class="menu-subtitle">Ø§Ù‚ØªÙ„ Ø§Ø¨Ùˆ Ø­Ù„Ø²Ù‡ ÙÙŠ 10 Ø¯Ù‚Ø§Ø¦Ù‚!</p>
        <div class="character-select">
            <button class="char-arrow" id="charPrev">â†’</button>
            <div class="character-display">
                <canvas class="char-preview" id="charPreview" width="120" height="120"></canvas>
                <div class="char-name" id="charName">Ø£Ø¨Ùˆ Ø³Ù„ÙŠÙ…Ø§Ù†</div>
                <div class="char-title" id="charTitle">Ø§Ù„ØªØ§Ø¬Ø± Ø§Ù„Ø«Ø±ÙŠ</div>
                <div class="char-desc" id="charDesc">ØªØ§Ø¬Ø± Ø«Ø±ÙŠ ÙŠØ­Ø¨ Ø§Ù„Ø°Ù‡Ø¨</div>
                <div class="char-stats" id="charStats"></div>
                <div class="char-weapon" id="charWeapon">ğŸ—¡ï¸ Ø§Ù„Ø¹Ù‚Ø§Ù„</div>
            </div>
            <button class="char-arrow" id="charNext">â†</button>
        </div>
        <div class="city-select">
            <div class="city-card selected" id="cityBadaya" data-city="badaya">
                <div class="city-icon">ğŸœï¸</div>
                <div class="city-name">Ø§Ù„Ø¨Ø¯Ø§Ø¦Ø¹</div>
                <div class="city-desc">ØµØ­Ø±Ø§Ø¡ ÙˆÙ†Ø®ÙŠÙ„</div>
            </div>
            <div class="city-card" id="cityEndless" data-city="endless">
                <div class="city-icon">â™¾ï¸</div>
                <div class="city-name">Ù„Ø§ Ù†Ù‡Ø§ÙŠØ©</div>
                <div class="city-desc">Ø£Ø¹Ø¯Ø§Ø¡ Ø£Ù‚ÙˆÙ‰ Ã— 1.25</div>
                <div style="font-size:0.6rem;color:#ff8800;margin-top:4px">Ø¨Ø¯ÙˆÙ† Ø¨ÙˆØ³ - Ø¨Ø¯ÙˆÙ† Ù†Ù‡Ø§ÙŠØ©</div>
            </div>
            <div class="city-card locked" id="cityBaghdad" data-city="baghdad">
                <div class="city-icon">ğŸ›ï¸</div>
                <div class="city-name">Ø¨ØºØ¯Ø§Ø¯</div>
                <div class="city-desc">Ù…Ø¯ÙŠÙ†Ø© Ø­Ø¶Ø§Ø±ÙŠØ©</div>
                <div class="city-locked">ğŸ”’ Ø§Ù‚ØªÙ„ Ø§Ø¨Ùˆ Ø­Ù„Ø²Ù‡ Ø£ÙˆÙ„Ø§Ù‹</div>
            </div>
        </div>
        <div class="menu-buttons">
            <button class="btn btn-primary" id="startBtn">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù„Ø¹Ø¨</button>
            <button class="btn" id="leaderboardBtn" style="background:linear-gradient(135deg,#4a4a4a,#2a2a2a);color:#ffd700;border:2px solid #ffd700;padding:8px 25px;font-size:0.9rem">ğŸ† Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø¨Ø·Ø§Ù„</button>
            <p class="high-score">Ø£Ø¹Ù„Ù‰ Ù†ØªÙŠØ¬Ø©: <span id="highScore">0</span> Ù‚ØªÙŠÙ„</p>
        </div>
    </div>
    
    <div id="hud">
        <div class="hud-left">
            <!-- Main panel with avatar and bars -->
            <div class="hud-panel">
                <div class="hud-avatar" id="hudAvatar"><canvas id="hudAvatarCanvas" width="32" height="32"></canvas></div>
                <div class="hud-bars">
                    <div class="hud-bar"><div class="hud-bar-fill health-fill" id="healthBar" style="width: 100%"></div><span class="hud-bar-text"><span id="healthText">100/100</span></span></div>
                    <div class="hud-bar"><div class="hud-bar-fill xp-fill" id="xpBar" style="width: 0%"></div><span class="hud-bar-text"><span id="xpText">0/10</span></span></div>
                </div>
            </div>
            <!-- Gold counter below -->
            <div class="hud-gold">
                <span class="hud-gold-icon">ğŸª™</span>
                <span class="hud-gold-text" id="goldText">0</span>
            </div>
        </div>
        <div class="hud-right">
            <span class="hud-stat level-text"><span class="hud-stat-icon">ğŸ“Š</span> <span id="levelText">Lv.1</span></span>
            <span class="hud-stat kill-text"><span class="hud-stat-icon">ğŸ’€</span> <span id="killText">0</span></span>
            <span class="hud-stat timer-text"><span class="hud-stat-icon">â±ï¸</span> <span id="timerText">00:00</span></span>
            <span class="hud-stat" id="endlessIndicator" style="display:none;color:#ff8800"><span class="hud-stat-icon">â™¾ï¸</span> âˆ</span>
        </div>
    </div>
    
    <div class="equipment-slots" id="equipmentSlots">
        <div class="slot-group" id="weaponSlots"></div>
        <div class="slot-group" id="bookSlots"></div>
    </div>
    
    <div id="miniMap">
        <canvas id="miniMapCanvas" width="110" height="110"></canvas>
    </div>
    
    <div id="levelUpModal">
        <div class="level-up-content">
            <h2 class="level-up-title">ğŸ‰ Ù…Ø³ØªÙˆÙ‰ Ø¬Ø¯ÙŠØ¯! ğŸ‰</h2>
            <div class="upgrade-options" id="upgradeOptions"></div>
        </div>
    </div>
    
    <div id="itemPickupModal">
        <div class="item-pickup-content">
            <div class="item-pickup-icon" id="itemIcon">â­</div>
            <div class="item-pickup-name" id="itemName">Ø§Ø³Ù… Ø§Ù„Ø£ÙŠØªÙ…</div>
            <div class="item-pickup-rarity" id="itemRarity">Ø£Ø³Ø·ÙˆØ±ÙŠ</div>
            <div class="item-pickup-desc" id="itemDesc">ÙˆØµÙ Ø§Ù„Ø£ÙŠØªÙ…</div>
            <button class="item-pickup-btn" id="itemContinueBtn">Ø§Ø³ØªÙ…Ø±Ø§Ø±</button>
        </div>
    </div>
    
    <div id="gameOverScreen">
        <h1 class="game-over-title" id="gameOverTitle">Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©</h1>
        <div class="unlock-message" id="unlockMessage" style="display: none;"></div>
        <div class="final-stats" id="finalStats"></div>
        <div id="nameInputSection" style="margin:15px 0;display:none">
            <p style="color:#ffd700;margin-bottom:8px">Ø³Ø¬Ù„ Ø§Ø³Ù…Ùƒ ÙÙŠ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø¨Ø·Ø§Ù„!</p>
            <input type="text" id="playerNameInput" placeholder="Ø§Ø³Ù…Ùƒ Ù‡Ù†Ø§..." maxlength="15" style="padding:10px 15px;font-size:1rem;border-radius:8px;border:2px solid #ffd700;background:#1a1a2e;color:#fff;text-align:center;font-family:'PixelAE',sans-serif;width:200px">
            <button id="submitScoreBtn" class="btn" style="background:#ffd700;color:#000;padding:10px 20px;margin-top:10px;font-size:0.9rem">ğŸ“¤ Ø³Ø¬Ù„ Ø§Ù„Ù†ØªÙŠØ¬Ø©</button>
        </div>
        <button class="btn btn-primary" id="restartBtn">Ø§Ù„Ø¹Ø¨ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰</button>
    </div>
    
    <div id="leaderboardModal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:1000;justify-content:center;align-items:center">
        <div style="background:linear-gradient(135deg,#1a1a2e,#0a0a15);border:3px solid #ffd700;border-radius:20px;padding:25px;max-width:400px;width:90%;max-height:80vh;overflow-y:auto">
            <h2 style="color:#ffd700;text-align:center;margin-bottom:20px">ğŸ† Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø¨Ø·Ø§Ù„ ğŸ†</h2>
            <p style="text-align:center;font-size:0.7rem;color:#888;margin-bottom:15px">Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ù…Ø­Ù„ÙŠØ© + Ø§Ù„Ø¹Ø§Ù„Ù…ÙŠØ©</p>
            <div id="leaderboardList" style="display:flex;flex-direction:column;gap:8px"></div>
            <div style="display:flex;gap:10px;margin-top:20px">
                <button id="shareScoreBtn" class="btn" style="background:#28a745;color:#fff;padding:10px 15px;flex:1;font-size:0.8rem">ğŸ“¤ Ø´Ø§Ø±Ùƒ Ù†ØªÙŠØ¬ØªÙƒ</button>
                <button id="closeLeaderboardBtn" class="btn" style="background:#444;color:#fff;padding:10px 15px;flex:1">Ø¥ØºÙ„Ø§Ù‚</button>
            </div>
        </div>
    </div>
    
    <div id="bossWarning">âš ï¸ ØªØ­Ø°ÙŠØ±! âš ï¸<br><span style="font-size: 1.2rem;">Ø§Ø¨Ùˆ Ø­Ù„Ø²Ù‡ Ù‚Ø§Ø¯Ù…!</span></div>
    <div id="pauseIndicator">â¸ï¸ Ø¥ÙŠÙ‚Ø§Ù Ù…Ø¤Ù‚Øª</div>
    
    <button id="pauseBtn">â¸ï¸</button>
    
    <div id="pauseMenu">
        <!-- Stats Panel -->
        <div class="pause-stats-panel">
            <div class="pause-stats-title">ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª</div>
            <div class="pause-char-preview">
                <canvas id="pauseCharCanvas" width="48" height="48"></canvas>
            </div>
            <div id="pauseCharName" style="text-align:center; color:#ffd700; margin-bottom:10px; font-size:0.9rem;">---</div>
            <div class="pause-stat-row">
                <span class="pause-stat-name">â¤ï¸ Ø§Ù„ØµØ­Ø©</span>
                <span class="pause-stat-value" id="pauseStatHP">100/100</span>
            </div>
            <div class="pause-stat-row">
                <span class="pause-stat-name">âš”ï¸ Ø§Ù„Ø¶Ø±Ø±</span>
                <span class="pause-stat-value" id="pauseStatDMG">10</span>
            </div>
            <div class="pause-stat-row">
                <span class="pause-stat-name">ğŸ›¡ï¸ Ø§Ù„Ø¯ÙØ§Ø¹</span>
                <span class="pause-stat-value" id="pauseStatDEF">0</span>
            </div>
            <div class="pause-stat-row">
                <span class="pause-stat-name">ğŸ€ Ø§Ù„Ø­Ø¸</span>
                <span class="pause-stat-value" id="pauseStatLUCK">1.0</span>
            </div>
            <div class="pause-stat-row">
                <span class="pause-stat-name">ğŸ’¥ Ø¶Ø±Ø¨Ø© Ø­Ø±Ø¬Ø©</span>
                <span class="pause-stat-value" id="pauseStatCRIT">5%</span>
            </div>
            <div class="pause-stat-row">
                <span class="pause-stat-name">ğŸ‘Ÿ Ø§Ù„Ø³Ø±Ø¹Ø©</span>
                <span class="pause-stat-value" id="pauseStatSPD">100%</span>
            </div>
            <div class="pause-stat-row">
                <span class="pause-stat-name">âš¡ Ø³Ø±Ø¹Ø© Ø§Ù„Ù‡Ø¬ÙˆÙ…</span>
                <span class="pause-stat-value" id="pauseStatATKSPD">100%</span>
            </div>
            <div class="pause-stat-row">
                <span class="pause-stat-name">ğŸ’° Ø§Ù„Ø°Ù‡Ø¨</span>
                <span class="pause-stat-value" id="pauseStatGold">0</span>
            </div>
            <div class="pause-stat-row">
                <span class="pause-stat-name">ğŸ’€ Ø§Ù„Ù‚ØªÙ„Ù‰</span>
                <span class="pause-stat-value" id="pauseStatKills">0</span>
            </div>
        </div>
        
        <!-- Controls Panel -->
        <div class="pause-controls">
            <div class="pause-stats-title">â¸ï¸ Ø¥ÙŠÙ‚Ø§Ù Ù…Ø¤Ù‚Øª</div>
            <div class="volume-control">
                <div class="volume-label">
                    <span>ğŸµ Ø§Ù„Ù…ÙˆØ³ÙŠÙ‚Ù‰</span>
                    <span id="musicVolText">50%</span>
                </div>
                <input type="range" class="volume-slider" id="musicVolume" min="0" max="100" value="50">
            </div>
            <div class="volume-control">
                <div class="volume-label">
                    <span>ğŸ”Š Ø§Ù„Ù…Ø¤Ø«Ø±Ø§Øª</span>
                    <span id="sfxVolText">70%</span>
                </div>
                <input type="range" class="volume-slider" id="sfxVolume" min="0" max="100" value="70">
            </div>
            <div class="pause-buttons">
                <button class="pause-btn pause-btn-resume" id="resumeBtn">â–¶ï¸ Ø§Ø³ØªÙ…Ø±Ø§Ø±</button>
                <button class="pause-btn pause-btn-quit" id="quitBtn">ğŸšª Ø®Ø±ÙˆØ¬</button>
            </div>
        </div>
    </div>

    <script>
// ==================== GAME CONFIG ====================
const CONFIG = {
    WORLD_SIZE: 4000, // Match map.png size
    TILE_SIZE: 32,
    PLAYER_LIGHT_RADIUS: 300,
    MAX_WEAPONS: 4,
    MAX_BOOKS: 4,
    MAX_UPGRADE_LEVEL: 10,  // Reduced from 20 - each level more impactful
    BOSS_TIME: 600, // 10 minutes
    
    // Enemy base stats (BALANCED for challenge)
    ENEMY_BASE_HP: 22,      // Takes 4-5 hits early game
    ENEMY_BASE_ATK: 10,     // More threatening - forces dodging
    ENEMY_BASE_SPEED: 65,   // Keeps pressure on player
    
    // Scaling per minute (BALANCED for late game challenge)
    SCALING_PER_MIN: 0.30,  // +30% per minute - enemies stay dangerous
    
    // Weapon base damage
    WEAPON_BASE_DMG: 5
};

// ==================== MAP TILES (arabtown-tile.png 246x135) ====================
// Tileset is arranged with various buildings and decorations
// Each tile definition: { x, y, w, h, collision: true/false }
const ARABTOWN_TILES = {
    // Simplified tiles from 246x135 arabtown-tile.png
    // Only using clearly separated elements
    
    // Fence for borders
    fence_top: { x: 0, y: 0, w: 133, h: 12, collision: true },
    
    // Main buildings - carefully selected
    building1: { x: 0, y: 13, w: 62, h: 50, collision: true },     // Large gate building
    building2: { x: 64, y: 13, w: 30, h: 50, collision: true },    // Dome building  
    tower: { x: 96, y: 0, w: 35, h: 63, collision: true },         // Tower
    house: { x: 147, y: 0, w: 32, h: 40, collision: true },        // Small house
    building_tall: { x: 205, y: 0, w: 40, h: 70, collision: true }, // Tall building
    
    // Decorations
    palm: { x: 133, y: 40, w: 14, h: 24, collision: true },
    well: { x: 178, y: 42, w: 24, h: 20, collision: true },
    rock1: { x: 148, y: 55, w: 10, h: 9, collision: false },
    rock2: { x: 160, y: 55, w: 12, h: 9, collision: false },
    
    // Bottom buildings
    shop: { x: 42, y: 85, w: 50, h: 33, collision: true },
    fence_small: { x: 0, y: 64, w: 40, h: 18, collision: true }
};

// ==================== RARITY ====================
const RARITY = {
    COMMON: { name: 'Ø´Ø§Ø¦Ø¹', color: '#9d9d9d', bonus: 1, weight: 50 },
    UNCOMMON: { name: 'ØºÙŠØ± Ø´Ø§Ø¦Ø¹', color: '#1eff00', bonus: 2, weight: 25 },
    RARE: { name: 'Ù†Ø§Ø¯Ø±', color: '#0070dd', bonus: 3, weight: 13 },
    EPIC: { name: 'Ù…Ù„Ø­Ù…ÙŠ', color: '#a335ee', bonus: 4, weight: 7 },
    LEGENDARY: { name: 'Ø£Ø³Ø·ÙˆØ±ÙŠ', color: '#ff8000', bonus: 5, weight: 5 }
};

function getRandomRarity(luck = 1) {
    // Luck has stronger effect on rarity chances
    // luck^2 for rare items, dramatically reduces common
    const luckPower = Math.pow(luck, 2);
    const adjustedRarity = {
        COMMON: { ...RARITY.COMMON, weight: RARITY.COMMON.weight / luckPower },
        UNCOMMON: { ...RARITY.UNCOMMON, weight: RARITY.UNCOMMON.weight * luck },
        RARE: { ...RARITY.RARE, weight: RARITY.RARE.weight * luckPower },
        EPIC: { ...RARITY.EPIC, weight: RARITY.EPIC.weight * luckPower * 1.5 },
        LEGENDARY: { ...RARITY.LEGENDARY, weight: RARITY.LEGENDARY.weight * luckPower * 2 }
    };
    
    const total = Object.values(adjustedRarity).reduce((s, r) => s + r.weight, 0);
    let r = Math.random() * total;
    for (const [key, rar] of Object.entries(adjustedRarity)) { 
        r -= rar.weight; 
        if (r <= 0) return RARITY[key]; 
    }
    return RARITY.COMMON;
}

// ==================== CHARACTERS ====================
const CHARACTERS = {
    abuSulaiman: {
        name: 'Ø£Ø¨Ùˆ Ø³Ù„ÙŠÙ…Ø§Ù†', title: 'Ø§Ù„ØªØ§Ø¬Ø± Ø§Ù„Ø«Ø±ÙŠ',
        desc: 'Ø§ÙˆÙ„Ø§Ùˆ ÙŠØ­Ø¨ Ø§Ù„Ø¯Ø±Ø§Ù‡Ù…',
        weapon: 'agal',
        stats: { gold: 1.5, luck: 1.2, hp: 110, speed: 200, crit: 0, enemyBuff: 0, chestDiscount: 0.3 },
        passiveText: ['+50% Ø°Ù‡Ø¨', '+20% Ø­Ø¸', '-30% Ø³Ø¹Ø± Ø§Ù„ØµÙ†Ø§Ø¯ÙŠÙ‚'],
        colors: { body: '#f5f5f5', head: '#cc0000', skin: '#d4a574', legs: '#2a2a2a' }
    },
    jayzen: {
        name: 'Ø¬ÙŠØ²Ù†', title: 'Ø§Ù„Ù…Ù‚Ø§ØªÙ„ Ø§Ù„Ø´Ø±Ø³',
        desc: 'Ù„Ø­Ø¬ÙŠ Ø¨Ø³ Ù…ØªØ¹Ø§ÙÙŠ',
        weapon: 'vape',
        stats: { gold: 1, luck: 1, hp: 115, speed: 200, dmgReduce: 0.2, crit: 0, enemyBuff: 0 },
        passiveText: ['-20% Ø¶Ø±Ø± Ù…Ø³ØªÙ„Ù…', '+15% ØµØ­Ø©'],
        colors: { body: '#6a1b9a', head: '#cc3333', skin: '#d4a574', legs: '#333' }
    },
    noura: {
        name: 'Ù†ÙˆØ±Ø©', title: 'Ø§Ù„Ù…Ø±Ø£Ø© Ø§Ù„Ù‚ÙˆÙŠØ©',
        desc: 'Ø³ØªØ±ÙˆÙ†Ù‚ Ø§Ù†Ø¯Ø¨Ù†Ø¯Øª ÙˆÙ…Ù†',
        weapon: 'aura',
        stats: { gold: 1, luck: 1, hp: 100, speed: 200, pickup: 2.5, xpMult: 1.2, crit: 0, enemyBuff: 0 },
        passiveText: ['+150% Ù…ØºÙ†Ø§Ø·ÙŠØ³', '+20% Ø®Ø¨Ø±Ø©'],
        colors: { body: '#1e88e5', head: '#f5f5f5', skin: '#e8d5c4', legs: '#1565c0' }
    },
    bedouin: {
        name: 'Ø§Ù„Ø§Ø¹Ø±Ø§Ø¨ÙŠ', title: 'Ø¨Ø¯ÙˆÙŠ ØºØ¯Ø§Ø±',
        desc: 'Ø¨Ø¯ÙˆÙŠ ÙˆØºØ¯Ø§Ø±ØŒ Ø§Ù„Ù„Ù‡ ÙŠØ±Ø­Ù… Ù…Ù† Ø·Ù„Ø¹Ù‡Ù… Ù…Ù† Ø®ÙŠØ§Ù…Ù‡Ù…',
        weapon: 'sword',
        stats: { gold: 1, luck: 1, hp: 90, speed: 220, crit: 0.20, enemyBuff: 0 },
        passiveText: ['+20% Ø¶Ø±Ø¨Ø© Ø­Ø±Ø¬Ø©', '+10% Ø³Ø±Ø¹Ø©'],
        colors: { body: '#8b4513', head: '#d2691e', skin: '#c4956a', legs: '#2f1810' }
    },
    hawshabi: {
        name: 'Ø§Ù„Ø­ÙˆØ´Ø¨ÙŠ', title: 'ØµØ¹ÙˆØ¨Ø© Ù…ØªÙ‚Ø¯Ù…Ø©',
        desc: 'Ø®Ù„ÙŠÙ‡Ø§ Ø¹Ù„Ù‰ Ø§Ù„Ù„Ù‡',
        weapon: 'mgma',
        stats: { gold: 1.5, luck: 1.2, hp: 80, speed: 180, crit: 0, enemyBuff: 0.20 },
        passiveText: ['+20% Ù‚ÙˆØ© Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡', '+50% Ø°Ù‡Ø¨', '+20% Ø­Ø¸'],
        colors: { body: '#4a0000', head: '#1a1a1a', skin: '#d4a574', legs: '#222' }
    },
    layla: {
        name: 'Ù„ÙŠÙ„Ù‰', title: 'Ø§Ù„Ø³Ø§Ø­Ø±Ø©',
        desc: 'Ø³Ø§Ø­Ø±Ø© ØºØ§Ù…Ø¶Ø© ØªØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù†Ø§Ø± Ø§Ù„Ø²Ø±Ù‚Ø§Ø¡',
        weapon: 'meteor',
        stats: { gold: 1, luck: 1, hp: 85, speed: 210, cooldown: 0.8, range: 1.3, crit: 0, enemyBuff: 0 },
        passiveText: ['-20% ÙƒÙˆÙ„Ø¯Ø§ÙˆÙ†', '+30% Ù…Ø¯Ù‰'],
        colors: { body: '#1a1a2e', head: '#4a0080', skin: '#e8d5c4', legs: '#0a0a15' }
    },
    mrBassla: {
        name: 'Ø³ÙŠØ¯ Ø¨ØµÙ„Ù‡', title: 'Ø§Ù„Ù…Ø®ÙŠÙ',
        desc: 'Ø§Ø°Ø§ Ø´Ø§ÙÙƒ ÙˆÙ‚Ø§Ù„Ùƒ ØªØ§Ø¨ÙŠÙ‡Ø§ ÙˆÙ„Ø§ Ù…Ø§ØªØ§Ø¨ÙŠÙ‡Ø§ Ø§Ù‡Ø±Ø¨',
        weapon: 'onion',
        stats: { gold: 1, luck: 1, hp: 100, speed: 200, atkSpd: 1.25, crit: 0, enemyBuff: 0, poison: 0.15 },
        passiveText: ['+25% Ø³Ø±Ø¹Ø© Ù‡Ø¬ÙˆÙ…', '15% ØªØ³Ù…ÙŠÙ… Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡'],
        colors: { body: '#9a7b4f', head: '#f5f5dc', skin: '#d4a574', legs: '#5a4a3a' }
    },
    samurai: {
        name: 'Ø³Ø§Ù…ÙˆØ±Ø§ÙŠ Ø§Ù„Ù…Ø¹', title: 'Ø§Ù„Ù†ÙŠÙ†Ø¬Ø§',
        desc: 'Ù„Ø§ ÙŠØºØ±Ùƒ Ø§Ù„Ø´ÙŠØ¨ ØªØ±Ø§Ù‡ Ù…ØªØ¹Ø§ÙÙŠ!',
        weapon: 'shuriken',
        stats: { gold: 1, luck: 1, hp: 100, speed: 220, dmgMult: 1.25, crit: 0.05, enemyBuff: 0, dodge: 0.10 },
        passiveText: ['+25% Ø¶Ø±Ø±', '10% ØªÙØ§Ø¯ÙŠ', '+5% ÙƒØ±ÙŠØª'],
        colors: { body: '#2a2a4a', head: '#1a1a2a', skin: '#d4a574', legs: '#1a1a2a' }
    }
};

// ==================== WEAPONS ====================
const WEAPONS = {
    // Weapon sprite info from JSON: frameW (width per frame), frameH (height), frames (total), fps
    agal: { 
        name: 'Ø§Ù„Ø¹Ù‚Ø§Ù„', desc: 'Ø­Ø¨Ù„ ÙŠØ¯ÙˆØ± Ø­ÙˆÙ„Ùƒ ÙˆÙŠØ¶Ø±Ø¨ Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡', 
        type: 'orbit', dmg: 5, cd: 0.1, range: 65, icon: 'â­•',
        effectSprite: 'weapon_agal_effect', frameW: 64, frameH: 64, frames: 10, fps: 8,
        iconSprite: 'weapon_agal_icon', offset: 0 // centered on player
    },
    vape: { 
        name: 'Ø§Ù„ÙÙŠØ¨', desc: 'Ø¯Ø®Ø§Ù† Ø³Ø§Ù… ÙŠØ³Ø¨Ø¨ Ø¶Ø±Ø± Ù…Ø³ØªÙ…Ø± Ø£Ù…Ø§Ù…Ùƒ', 
        type: 'cone_aoe', dmg: 10, cd: 0.1, range: 70, icon: 'ğŸ’¨',
        effectSprite: 'weapon_vape_effect', frameW: 63, frameH: 64, frames: 15, fps: 8,
        iconSprite: 'weapon_vape_icon', offset: 40, dotDmg: 10 // 10 damage per second, cone in front
    },
    aura: { 
        name: 'Ø§Ù„Ù‡ÙŠØ¨Ø©', desc: 'Ù‡Ø§Ù„Ø© Ø¶Ø±Ø± Ø­ÙˆÙ„Ùƒ ÙƒÙ„ 0.5 Ø«Ø§Ù†ÙŠØ©', 
        type: 'aura', dmg: 4, cd: 0.5, range: 60, icon: 'ğŸ’«',
        effectSprite: 'weapon_aura_effect', frameW: 64, frameH: 69, frames: 11, fps: 8,
        iconSprite: 'weapon_aura_icon', offset: 0 // centered on player
    },
    sword: { 
        name: 'Ø§Ù„Ø³ÙŠÙ', desc: 'Ø¶Ø±Ø¨Ø© Ù‚ÙˆØ³ÙŠØ© Ø£Ù…Ø§Ù…Ùƒ', 
        type: 'melee', dmg: 6, cd: 0.65, range: 75, icon: 'âš”ï¸',
        effectSprite: 'weapon_sword_effect', frameW: 64, frameH: 67, frames: 8, fps: 8,
        iconSprite: 'weapon_sword_icon', offset: 35 // in front of player
    },
    mgma: { 
        name: 'Ø§Ù„Ù…Ù‚Ù…Ø¹', desc: 'Ø·Ù„Ù‚Ø© Ø´ÙˆØªØ¬Ù† Ù…ØªÙˆØ³Ø·Ø© Ø§Ù„Ù…Ø¯Ù‰', 
        type: 'projectile', dmg: 5, cd: 1.0, range: 200, icon: 'ğŸ”«',
        effectSprite: 'weapon_mgma_effect', frameW: 64, frameH: 68, frames: 8, fps: 8,
        iconSprite: 'weapon_mgma_icon', offset: 25 // muzzle flash offset
    },
    meteor: { 
        name: 'Ø§Ù„Ù†ÙŠØ²Ùƒ', desc: 'Ù‚Ø°ÙŠÙØ© Ù„Ø¹Ø¯Ùˆ Ø¹Ø´ÙˆØ§Ø¦ÙŠ', 
        type: 'lightning', dmg: 6, cd: 1.4, range: 400, icon: 'â˜„ï¸',
        effectSprite: 'weapon_meteor_effect', frameW: 64, frameH: 66, frames: 14, fps: 16,
        iconSprite: 'weapon_meteor_icon', offset: 0 // effect at target
    },
    brain: { 
        name: 'Ø§Ù„Ø¹Ù‚Ù„', desc: 'Ù‚Ø°ÙŠÙØ© ØªÙ‚ÙØ² Ø¨ÙŠÙ† Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡', 
        type: 'chain', dmg: 4, cd: 1.2, range: 300, icon: 'ğŸ§ ',
        effectSprite: 'weapon_brain_effect', frameW: 64, frameH: 69, frames: 7, fps: 8,
        iconSprite: 'weapon_brain_icon', offset: 0 // effect at target
    },
    onion: { 
        name: 'Ø§Ù„Ø¨ØµÙ„', desc: 'Ù‚Ø°ÙŠÙØ© Ø·ÙˆÙŠÙ„Ø© Ø§Ù„Ù…Ø¯Ù‰ ØªØ³Ø¨Ø¨ Ø¶Ø±Ø± Ù…Ø³ØªÙ…Ø±', 
        type: 'dot', dmg: 3, cd: 1.5, range: 450, icon: 'ğŸ§…',
        effectSprite: 'weapon_onion_effect', frameW: 64, frameH: 65, frames: 15, fps: 8,
        projectileSprite: 'weapon_onion_projectile', projFrameW: 64, projFrameH: 65, projFrames: 14, projFps: 8,
        iconSprite: 'weapon_onion_icon', offset: 0
    },
    shuriken: {
        name: 'Ø§Ù„Ø´ÙˆØ±ÙŠÙƒÙ†', desc: 'Ù†Ø¬Ù…Ø© Ù†ÙŠÙ†Ø¬Ø§ ØªÙ‚ÙØ² Ø¨ÙŠÙ† Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡',
        type: 'bounce', dmg: 5, cd: 0.8, range: 350, icon: 'âœ´ï¸',
        effectSprite: 'weapon_shuriken_effect', frameW: 146, frameH: 137, frames: 3, fps: 8,
        iconSprite: 'weapon_shuriken_icon', offset: 0,
        bounces: 2, bounceDmgReduce: 0.3 // Bounces to 2 more enemies, -30% damage each bounce
    }
};

// ==================== BOOKS ====================
const BOOKS = {
    // BALANCED - bigger bonuses per level to feel impactful
    power: { name: 'ÙƒØªØ§Ø¨ Ø§Ù„Ù‚ÙˆØ©', desc: '+15% Ù‚ÙˆØ© Ø§Ù„Ù‡Ø¬ÙˆÙ…', stat: 'damage', val: 0.15, icon: 'ğŸ“•' },
    speed: { name: 'ÙƒØªØ§Ø¨ Ø§Ù„Ø³Ø±Ø¹Ø©', desc: '+12% Ø³Ø±Ø¹Ø© Ø§Ù„Ù‡Ø¬ÙˆÙ…', stat: 'atkSpd', val: 0.12, icon: 'ğŸ“—' },
    wind: { name: 'ÙƒØªØ§Ø¨ Ø§Ù„Ø±ÙŠØ­', desc: '+10% Ø³Ø±Ø¹Ø© Ø§Ù„Ø­Ø±ÙƒØ©', stat: 'moveSpd', val: 0.10, icon: 'ğŸ“˜' },
    wisdom: { name: 'ÙƒØªØ§Ø¨ Ø§Ù„Ø­ÙƒÙ…Ø©', desc: '+15% Ø§Ù„Ø®Ø¨Ø±Ø© Ø§Ù„Ù…ÙƒØªØ³Ø¨Ø©', stat: 'xp', val: 0.15, icon: 'ğŸ“™' },
    life: { name: 'ÙƒØªØ§Ø¨ Ø§Ù„Ø­ÙŠØ§Ø©', desc: '+15% Ø§Ù„ØµØ­Ø© Ø§Ù„Ù‚ØµÙˆÙ‰', stat: 'maxHp', val: 0.15, icon: 'ğŸ““' },
    armor: { name: 'ÙƒØªØ§Ø¨ Ø§Ù„Ø¯Ø±Ø¹', desc: '+8% ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø¶Ø±Ø±', stat: 'armor', val: 0.08, icon: 'ğŸ“”' },
    magnet: { name: 'ÙƒØªØ§Ø¨ Ø§Ù„Ù…ØºÙ†Ø§Ø·ÙŠØ³', desc: '+20% Ù…Ø¯Ù‰ Ø§Ù„Ø¬Ù…Ø¹', stat: 'pickup', val: 0.20, icon: 'ğŸ“’' },
    luck: { name: 'ÙƒØªØ§Ø¨ Ø§Ù„Ø­Ø¸', desc: '+12% Ø­Ø¸ Ø§Ù„Ø¯Ø±ÙˆØ¨', stat: 'luck', val: 0.12, icon: 'ğŸ“š' },
    curse: { name: 'ÙƒØªØ§Ø¨ Ø§Ù„Ù„Ø¹Ù†Ø©', desc: '+20% Ø£Ø¹Ø¯Ø§Ø¡ ÙˆØ®Ø¨Ø±Ø©', stat: 'curse', val: 0.20, icon: 'ğŸ“–' },
    regen: { name: 'ÙƒØªØ§Ø¨ Ø§Ù„ØªØ¬Ø¯ÙŠØ¯', desc: '+1.5 Ø´ÙØ§Ø¡/Ø«Ø§Ù†ÙŠØ©', stat: 'regen', val: 1.5, icon: 'ğŸ“œ' },
    critical: { name: 'ÙƒØªØ§Ø¨ Ø§Ù„Ø¶Ø±Ø¨Ø© Ø§Ù„Ø­Ø±Ø¬Ø©', desc: '+6% Ø¶Ø±Ø¨Ø© Ø­Ø±Ø¬Ø©', stat: 'crit', val: 0.06, icon: 'ğŸ’¥' }
};

// ==================== ITEMS ====================
const ITEMS = {
    // Common (Ø´Ø§Ø¦Ø¹) - iconPos: {row, col} in IconSet.png (24x24 grid)
    mirinda: { name: 'Ø­Ù…Ø¶ÙŠØ§Øª', desc: 'Ø­Ø§Ø± ÙŠÙ„Ø¯ .. ÙŠÙ†Ø¹Ù†Ø´ ÙˆÙŠØ±Ø¬Ø¹ Ù„Ùƒ 10 Ù‡ÙŠÙ„', rarity: 'COMMON', effect: 'heal', val: 10, icon: 'ğŸŠ', sprite: 'item_mirinda' },
    dalla: { name: 'Ø¯Ù„Ù‡ Ù‚Ù‡ÙˆÙ‡', desc: 'Ø§Ù„Ù…Ù‡ÙŠÙ„Ù‡ ØªØ²ÙŠØ¯ Ø¯ÙØ§Ø¹Ùƒ 1 Ø¨Ø´ÙƒÙ„ Ø¯Ø§ÙŠÙ…', rarity: 'COMMON', effect: 'permArmor', val: 1, icon: 'â˜•', sprite: 'item_dalla' },
    sandal: { name: 'Ù†Ø¹Ø§Ù„ Ø´Ø±Ù‚ÙŠØ©', desc: 'ØªØ®Ù„ÙŠÙƒ ØªÙÙƒ Ø³Ø¨Ø±Ù†Øª', rarity: 'COMMON', effect: 'permSpeed', val: 0.025, icon: 'ğŸ‘Ÿ', sprite: 'item_sandal' },
    klega: { name: 'ÙƒÙ„ÙŠØ¬Ù‡', desc: 'Ø§ÙˆÙ„Ø§Ùˆ Ù…Ù† Ø­Ù„Ø§ØªÙ‡ ØªØ²ÙŠØ¯ ØµØ­ØªÙƒ', rarity: 'COMMON', effect: 'permHP', val: 2, icon: 'ğŸª', sprite: 'item_klega' },
    copper: { name: 'Ù†Ø­Ø§Ø³', desc: '+5 Ø°Ù‡Ø¨', rarity: 'COMMON', effect: 'gold', val: 5, icon: 'ğŸª™', iconPos: {row: 11, col: 0} },
    
    // Rare (Ù†Ø§Ø¯Ø±)
    magnet: { name: 'Ù…ØºÙ†Ø§Ø·ÙŠØ³', desc: 'Ø§Ø³Ø­Ø¨ ÙƒÙ„ Ø§Ù„Ø§ÙƒØ³ Ø¨ÙŠ ÙˆØ§Ù„ÙÙ„ÙˆØ³', rarity: 'RARE', effect: 'magnetPull', val: 1, icon: 'ğŸ§²', sprite: 'item_magnet' },
    redPotion: { name: 'Ø¬Ø±Ø¹Ø© Ø­Ù…Ø±Ø§Ø¡', desc: 'ÙŠØ³ØªØ¹ÙŠØ¯ 30 ØµØ­Ø©', rarity: 'RARE', effect: 'heal', val: 30, icon: 'ğŸ§ª', iconPos: {row: 0, col: 0} },
    bluePotion: { name: 'Ø¬Ø±Ø¹Ø© Ø²Ø±Ù‚Ø§Ø¡', desc: '+30% Ø³Ø±Ø¹Ø© Ù‡Ø¬ÙˆÙ… Ù„Ù…Ø¯Ø© 15 Ø«Ø§Ù†ÙŠØ©', rarity: 'RARE', effect: 'tempAtkSpd', val: 0.3, dur: 15, icon: 'ğŸ§´', iconPos: {row: 0, col: 1} },
    amulet: { name: 'ØªÙ…ÙŠÙ…Ø©', desc: 'Ø¯Ø±Ø¹ ÙŠÙ…ØªØµ 20 Ø¶Ø±Ø±', rarity: 'RARE', effect: 'shield', val: 20, icon: 'ğŸ“¿', iconPos: {row: 12, col: 8} },
    hourglass: { name: 'Ø³Ø§Ø¹Ø© Ø±Ù…Ù„ÙŠØ©', desc: 'ÙŠØ¨Ø·Ø¦ Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡ 50% Ù„Ù…Ø¯Ø© 5 Ø«ÙˆØ§Ù†ÙŠ', rarity: 'RARE', effect: 'slow', val: 0.5, dur: 5, icon: 'â³', iconPos: {row: 9, col: 7} },
    silver: { name: 'ÙØ¶Ø©', desc: '+25 Ø°Ù‡Ø¨', rarity: 'RARE', effect: 'gold', val: 25, icon: 'ğŸ¥ˆ', iconPos: {row: 11, col: 1} },
    
    // Legendary (Ø£Ø³Ø·ÙˆØ±ÙŠ)
    elixir: { name: 'Ø¥ÙƒØ³ÙŠØ±', desc: 'ÙŠØ³ØªØ¹ÙŠØ¯ ÙƒÙ„ Ø§Ù„ØµØ­Ø© ÙˆÙŠØ²ÙŠØ¯ Ø§Ù„ØµØ­Ø© Ø§Ù„Ù‚ØµÙˆÙ‰ 20', rarity: 'LEGENDARY', effect: 'fullHeal', val: 20, icon: 'âš—ï¸', iconPos: {row: 0, col: 4} },
    dragonHeart: { name: 'Ù‚Ù„Ø¨ Ø§Ù„ØªÙ†ÙŠÙ†', desc: '+50% Ø¶Ø±Ø± Ù„Ù…Ø¯Ø© 25 Ø«Ø§Ù†ÙŠØ©', rarity: 'LEGENDARY', effect: 'tempDmg', val: 0.5, dur: 25, icon: 'â¤ï¸â€ğŸ”¥', iconPos: {row: 10, col: 0} },
    arika: { name: 'Ø¹Ø±ÙŠÙƒÙ‡', desc: 'Ø¥Ø°Ø§ Ù…ØªØŒ ØªØ¹ÙˆØ¯ Ù„Ù„Ø­ÙŠØ§Ø© Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø©', rarity: 'LEGENDARY', effect: 'revive', val: 1, icon: 'ğŸš', sprite: 'item_arika' },
    crown: { name: 'ØªØ§Ø¬ Ø°Ù‡Ø¨ÙŠ', desc: '+50% Ø°Ù‡Ø¨ Ø¨Ø´ÙƒÙ„ Ø¯Ø§Ø¦Ù…', rarity: 'LEGENDARY', effect: 'permGold', val: 0.5, icon: 'ğŸ‘‘', iconPos: {row: 12, col: 0} },
    star: { name: 'Ù†Ø¬Ù…Ø© Ø§Ù„ØµØ­Ø±Ø§Ø¡', desc: 'ØªØ­ØµÙ„ Ø¹Ù„Ù‰ Ø³Ù„Ø§Ø­ Ø£Ùˆ ÙƒØªØ§Ø¨ Ø¹Ø´ÙˆØ§Ø¦ÙŠ', rarity: 'LEGENDARY', effect: 'randomEquip', val: 1, icon: 'â­', iconPos: {row: 10, col: 8} },
    khazouq: { name: 'Ø®Ø§Ø²ÙˆÙ‚', desc: 'ÙŠØ²ÙŠØ¯ Ù†Ø³Ø¨Ø© Ø¸Ù‡ÙˆØ± Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡ 10%ØŒ Ø£Ù†Øª ØºØ¨ÙŠ Ù„ÙŠØ´ Ø£Ø®Ø°ØªÙ‡ØŸ', rarity: 'LEGENDARY', effect: 'moreEnemies', val: 0.10, icon: 'ğŸ†', iconPos: {row: 2, col: 5} }
};

// ==================== ENEMIES ====================
const ENEMIES = {
    // BALANCED enemy stats
    flyingEye: { name: 'Ø§Ù„Ø¹ÙŠÙ† Ø§Ù„Ø·Ø§Ø¦Ø±Ø©', hpM: 0.7, atkM: 0.7, spdM: 1.1, xp: 3, time: 0, color: '#ff4444', ranged: true },
    goblin: { name: 'Ø§Ù„ØºÙˆØ¨Ù„ÙŠÙ†', hpM: 1.0, atkM: 1.0, spdM: 1.0, xp: 4, time: 0, color: '#44aa44' },
    mushroom: { name: 'Ø§Ù„ÙØ·Ø±', hpM: 1.4, atkM: 1.2, spdM: 0.8, xp: 6, time: 30, color: '#cc88ff', ranged: true },
    skeleton: { name: 'Ø§Ù„Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø¹Ø¸Ù…ÙŠ', hpM: 2.0, atkM: 1.5, spdM: 0.85, xp: 8, time: 60, color: '#eeeecc' }
};

const BOSS = { name: 'Ø§Ø¨Ùˆ Ø­Ù„Ø²Ù‡', hp: 12000, atk: 40, spd: 60, color: '#8b0000' };

// ==================== ASSET LOADER ====================
class AssetLoader {
    constructor() {
        this.images = {};
        this.loaded = false;
    }
    
    loadImage(name, src) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => { this.images[name] = img; resolve(img); };
            img.onerror = reject;
            // Add cache buster to force reload
            const cacheBuster = '?v=' + Date.now();
            img.src = src + cacheBuster;
        });
    }
    
    // Remove white background from enemy sprites
    removeWhiteBackground(name) {
        const img = this.images[name];
        if (!img) return;
        
        const canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0);
        
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Make white/near-white pixels transparent
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i], g = data[i + 1], b = data[i + 2];
            // If pixel is white or near-white (threshold 240)
            if (r > 240 && g > 240 && b > 240) {
                data[i + 3] = 0; // Set alpha to 0 (transparent)
            }
            // Also handle light gray backgrounds
            else if (r > 220 && g > 220 && b > 220 && Math.abs(r - g) < 15 && Math.abs(g - b) < 15) {
                data[i + 3] = 0;
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
        
        // Create new image from processed canvas
        const newImg = new Image();
        newImg.src = canvas.toDataURL();
        this.images[name] = newImg;
    }
    
    async loadAll() {
        const assets = [
            // Characters
            ['char_001', 'assets/characters/Char_001.png'],
            ['char_001_idle', 'assets/characters/Char_001_Idle.png'],
            ['char_002', 'assets/characters/Char_002.png'],
            ['char_002_idle', 'assets/characters/Char_002_Idle.png'],
            ['char_003', 'assets/characters/Char_003.png'],
            ['char_003_idle', 'assets/characters/Char_003_Idle.png'],
            ['char_004', 'assets/characters/Char_004.png'],
            ['char_004_idle', 'assets/characters/Char_004_Idle.png'],
            ['char_005', 'assets/characters/Char_005.png'],
            ['char_005_idle', 'assets/characters/Char_005_Idle.png'],
            ['char_006', 'assets/characters/Char_006.png'],
            ['char_006_idle', 'assets/characters/Char_006_Idle.png'],
            
            // Wind Hashashin (Bedouin) sprites - 4 frames for idle animation
            ['bedouin_frame1', 'assets/characters/wind_hashashin/wind_hashashin_1.png'],
            ['bedouin_frame2', 'assets/characters/wind_hashashin/wind_hashashin_2.png'],
            ['bedouin_frame3', 'assets/characters/wind_hashashin/wind_hashashin_3.png'],
            ['bedouin_frame4', 'assets/characters/wind_hashashin/wind_hashashin_4.png'],
            
            // Ground Monk (Jayzen) sprites - 4 frames for idle animation
            ['jayzen_frame1', 'assets/characters/ground_monk/ground_monk_1.png'],
            ['jayzen_frame2', 'assets/characters/ground_monk/ground_monk_2.png'],
            ['jayzen_frame3', 'assets/characters/ground_monk/ground_monk_3.png'],
            ['jayzen_frame4', 'assets/characters/ground_monk/ground_monk_4.png'],
            
            // Adventurer (Hawshabi) sprites - 5 frames for idle animation
            ['hawshabi_frame0', 'assets/characters/adventurer_01/adventurer_01_00.png'],
            ['hawshabi_frame1', 'assets/characters/adventurer_01/adventurer_01_01.png'],
            ['hawshabi_frame2', 'assets/characters/adventurer_01/adventurer_01_02.png'],
            ['hawshabi_frame3', 'assets/characters/adventurer_01/adventurer_01_03.png'],
            ['hawshabi_frame4', 'assets/characters/adventurer_01/adventurer_01_04.png'],
            
            // Water Priestess (Noura) sprites - 4 frames for idle animation
            ['noura_frame1', 'assets/characters/water_priestess/water_priestess_1.png'],
            ['noura_frame2', 'assets/characters/water_priestess/water_priestess_2.png'],
            ['noura_frame3', 'assets/characters/water_priestess/water_priestess_3.png'],
            ['noura_frame4', 'assets/characters/water_priestess/water_priestess_4.png'],
            
            // Elder (Abu Sulaiman) sprites - 4 frames for idle animation
            ['abusulaiman_frame1', 'assets/characters/elder/elder_1.png'],
            ['abusulaiman_frame2', 'assets/characters/elder/elder_2.png'],
            ['abusulaiman_frame3', 'assets/characters/elder/elder_3.png'],
            ['abusulaiman_frame4', 'assets/characters/elder/elder_4.png'],
            
            // Boss sprite (Abu Halza)
            ['boss_halza', 'assets/characters/1769115033155(1).png'],
            
            // Enemies - New animated monster sprites
            ['enemy_flyingeye', 'assets/New enemy/Flying eye/Attack3.png'],
            ['enemy_goblin', 'assets/New enemy/Goblin/Attack3.png'],
            ['enemy_mushroom', 'assets/New enemy/Mushroom/Attack3.png'],
            ['enemy_skeleton', 'assets/New enemy/Skeleton/Attack3.png'],
            
            // Enemies - Old static monster sprites (for fallback)
            ['enemy_wolf', 'assets/enemies/NB_01.png'],
            ['enemy_scorpion', 'assets/enemies/NB_09.png'],
            ['enemy_dhub', 'assets/enemies/NB_03.png'],
            ['enemy_snake', 'assets/enemies/NB_06.png'],
            ['enemy_hyena', 'assets/enemies/NB_02.png'],
            ['enemy_eagle', 'assets/enemies/NB_29.png'],
            ['enemy_lion', 'assets/enemies/NB_26.png'],
            ['enemy_djinn', 'assets/enemies/NB_05.png'],
            ['enemy_ghoul', 'assets/enemies/NB_08.png'],
            ['enemy_knight', 'assets/enemies/NB_16.png'],
            
            // Pickups (old static)
            ['gold_coin', 'assets/pickups/gold_coin.png'],
            ['xp_gem', 'assets/pickups/xp_gem.png'],
            // Pickups (new animated)
            ['pickup_xp', 'assets/pickups/XP.png'],
            ['pickup_coin', 'assets/pickups/Coin.png'],
            
            // Item Icons (new arranged icons - 500x500)
            ['item_mirinda', 'assets/New Items Icon/arrainged/icons/mirinda.png'],
            ['item_dalla', 'assets/New Items Icon/arrainged/icons/dalla.png'],
            ['item_klega', 'assets/New Items Icon/arrainged/icons/klega.png'],
            ['item_arika', 'assets/New Items Icon/arrainged/icons/arika.png'],
            ['item_sandal', 'assets/New Items Icon/arrainged/icons/9.png'],
            ['item_magnet', 'assets/New Items Icon/Magnetic.png'],
            
            // IconSet sprite sheet (24x24 icons)
            ['iconset', 'assets/IconSet.png'],
            
            // Pixel GUI elements
            ['gui_sprites', "assets/Cryo's Mini GUI/GUI/GUI_2x.png"],
            ['gui_buttons', "assets/Cryo's Mini GUI/Buttons/buttons_2x.png"],
            
            // Desert Map
            ['desert_tiles', 'assets/New Maps/DesertTileset16x16/Tileset16x16/DesertTilemap16x16.png'],
            
            // Arab Town Tileset (main map)
            ['arabtown', 'assets/New Maps/arabtown-tile.png'],
            // Full map image
            ['map_bg', 'assets/map.png'],
            
            // Forest Map (Baghdad)
            ['forest_tiles', 'assets/New Maps/gentle sheets/gentle forest v01.png'],
            
            // Buildings
            ['building_house', 'assets/Yellow Buildings/House1.png'],
            ['building_castle', 'assets/Yellow Buildings/Castle.png'],
            ['building_tower', 'assets/Yellow Buildings/Tower.png'],
            ['building_house2', 'assets/Yellow Buildings/House2.png'],
            ['building_house3', 'assets/Yellow Buildings/House3.png'],
            
            // Decorations
            ['rock1', 'assets/Terrain/Decorations/Rocks/Rock1.png'],
            ['rock2', 'assets/Terrain/Decorations/Rocks/Rock2.png'],
            ['rock3', 'assets/Terrain/Decorations/Rocks/Rock3.png'],
            ['bush1', 'assets/Terrain/Decorations/Bushes/Bushe1.png'],
            ['bush2', 'assets/Terrain/Decorations/Bushes/Bushe2.png'],
            ['trees', 'assets/New Maps/gentle sheets/gentle trees 80x96 v01.png'],
            
            // UI Elements
            ['ui_bar_base', 'assets/UI Elements/UI Elements/Bars/BigBar_Base.png'],
            ['ui_bar_fill', 'assets/UI Elements/UI Elements/Bars/BigBar_Fill.png'],
            
            // Backgrounds
            ['sand_tile', 'assets/backgrounds/sand_tile.png'],
            ['tiles', 'assets/tiles-all-32x32.png'],
            
            // Effects
            ['fx_spark', 'assets/01.png'],
            ['fx_fire_small', 'assets/02.png'],
            ['fx_explosion', 'assets/03.png'],
            ['fx_fireball', 'assets/04.png'],
            ['fx_flames', 'assets/05.png'],
            ['fx_ice', 'assets/10.png'],
            ['fx_magic', 'assets/15.png'],
            ['fx_heal', 'assets/20.png'],
            ['fx_dust', 'assets/25.png'],
            ['fx_circle', 'assets/30.png'],
            ['fx_water', 'assets/35.png'],
            
            // New Weapon Effects (original paths)
            ['weapon_agal_effect', 'assets/New Weapons/agal/effect.png'],
            ['weapon_aura_effect', 'assets/New Weapons/aura/effect.png'],
            ['weapon_sword_effect', 'assets/New Weapons/sword/effect.png'],
            ['weapon_vape_effect', 'assets/New Weapons/vape/New_effect2.png'],
            ['weapon_meteor_effect', 'assets/New Weapons/meteor/effect.png'],
            ['weapon_mgma_effect', 'assets/New Weapons/Mgma/effect.png'],
            ['weapon_mgma_fire', 'assets/New Weapons/Mgma/Fire_03.png'],
            ['weapon_brain_effect', 'assets/New Weapons/brain/effect.png'],
            ['weapon_onion_effect', 'assets/New Weapons/Onion/hit effect.png'],
            ['weapon_onion_projectile', 'assets/New Weapons/Onion/projectile on the way.png'],
            
            // New Weapon Icons (arranged - 500x500)
            ['weapon_agal_icon', 'assets/New Items Icon/arrainged/weapon icons/aqal.png'],
            ['weapon_aura_icon', 'assets/New Items Icon/arrainged/weapon icons/haybah.png'],
            ['weapon_sword_icon', 'assets/New Items Icon/arrainged/weapon icons/sword.png'],
            ['weapon_vape_icon', 'assets/New Items Icon/arrainged/weapon icons/vape.png'],
            ['weapon_meteor_icon', 'assets/New Items Icon/arrainged/weapon icons/meteor.png'],
            ['weapon_mgma_icon', 'assets/New Items Icon/arrainged/weapon icons/mgma.png'],
            ['weapon_brain_icon', 'assets/New Items Icon/arrainged/weapon icons/brain.png'],
            ['weapon_onion_icon', 'assets/New Items Icon/arrainged/weapon icons/onion.png'],
            
            // Jayzan new sprites
            ['jayzan_idle', 'assets/characters/Jayzan/idle.png'],
            ['jayzan_1', 'assets/characters/Jayzan/1.png'],
            ['jayzan_2', 'assets/characters/Jayzan/2.png'],
            
            // Mr Bassla sprites
            ['mrbassla_idle', 'assets/characters/Mr Bassla/Idle.png'],
            ['mrbassla_walk', 'assets/characters/Mr Bassla/walk.png'],
            
            // Samurai sprites
            ['samurai_idle', 'assets/characters/Samurai/IDLE(1).png'],  // For menu/leaderboard/HUD
            ['samurai_idle_anim', 'assets/characters/Samurai/IDLE.png'], // For in-game idle animation
            ['samurai_run', 'assets/characters/Samurai/RUN.png'],
            
            // Shuriken weapon
            ['weapon_shuriken_effect', 'assets/New Weapons/Shuriken/Shuriken animation.png'],
            ['weapon_shuriken_icon', 'assets/New Weapons/Shuriken/shurikon.png'],
            
            // New Music & SFX
            ['sfx_item_drop', 'assets/New Music & SFX/Item Drop.mp3'],
            ['sfx_item_taken', 'assets/New Music & SFX/Item Taken.mp3'],
            ['sfx_lvl_up', 'assets/New Music & SFX/Lvl up.mp3'],
            ['sfx_hit', 'assets/New Music & SFX/charecter getting hit.mp3'],
            
            // Retro UI Elements
            ['retro_ui', 'assets/UI Elements/Retro.png']
        ];
        
        try {
            await Promise.all(assets.map(([name, src]) => this.loadImage(name, src)));
            
            // Remove white background from enemy sprites
            const enemySprites = ['enemy_wolf', 'enemy_scorpion', 'enemy_dhub', 'enemy_snake', 
                                  'enemy_hyena', 'enemy_eagle', 'enemy_lion', 'enemy_djinn', 
                                  'enemy_ghoul', 'enemy_knight', 'wolf', 'scorpion', 'dhub'];
            
            // Small delay to ensure images are fully loaded before processing
            await new Promise(resolve => setTimeout(resolve, 100));
            
            enemySprites.forEach(name => {
                if (this.images[name]) this.removeWhiteBackground(name);
            });
            
            this.loaded = true;
            console.log('All assets loaded!');
        } catch (e) {
            console.warn('Some assets failed to load, using fallback rendering');
            this.loaded = false;
        }
    }
    
    get(name) {
        return this.images[name];
    }
    
    // Get icon position from IconSet (24x24 grid)
    // Row and col are 0-indexed
    getIconRect(row, col, size = 24) {
        return { x: col * size, y: row * size, w: size, h: size };
    }
}

// Character sprite mappings
const CHAR_SPRITES = {
    // Standard 192x192 sprites: 4 columns x 4 rows = 48x48 per frame
    // Row order: 0=down, 1=left, 2=right, 3=up
    // Elder (Abu Sulaiman) - 4 separate 32x32 frames for idle animation
    abuSulaiman: { 
        type: 'multiframe',
        frames: ['abusulaiman_frame1', 'abusulaiman_frame2', 'abusulaiman_frame3', 'abusulaiman_frame4'],
        frameWidth: 32, 
        frameHeight: 32,
        fps: 6
    },
    // Jayzen - idle + walk sprites (1, 2)
    jayzen: { 
        type: 'walk_idle',
        idleSprite: 'jayzan_idle',
        walkSprites: ['jayzan_1', 'jayzan_2'],
        fps: 6
    },
    // Water Priestess (Noura) - 4 separate 32x32 frames for idle animation
    noura: { 
        type: 'multiframe',
        frames: ['noura_frame1', 'noura_frame2', 'noura_frame3', 'noura_frame4'],
        frameWidth: 32, 
        frameHeight: 32,
        fps: 6
    },
    // Wind Hashashin (Bedouin) - 4 separate 32x32 frames for idle animation
    // Flip horizontally for left/right direction
    bedouin: { 
        type: 'multiframe', // Separate images as animation frames
        frames: ['bedouin_frame1', 'bedouin_frame2', 'bedouin_frame3', 'bedouin_frame4'],
        frameWidth: 32, 
        frameHeight: 32,
        fps: 6 // 6 frames per second as recommended
    },
    // Adventurer (Hawshabi) - 5 separate 32x32 frames for idle animation
    hawshabi: { 
        type: 'multiframe',
        frames: ['hawshabi_frame0', 'hawshabi_frame1', 'hawshabi_frame2', 'hawshabi_frame3', 'hawshabi_frame4'],
        frameWidth: 32, 
        frameHeight: 32,
        fps: 6
    },
    layla: { sprite: 'char_001', idle: 'char_001_idle', frameWidth: 48, frameHeight: 48, frames: 4, rows: 4 },
    // Mr Bassla - idle + walk sprites (from JSON: 231x190 per frame)
    mrBassla: { 
        type: 'walk_idle',
        idleSprite: 'mrbassla_idle',
        walkSprites: ['mrbassla_walk'],
        frameWidth: 231,
        frameHeight: 190,
        idleFrames: 6,
        walkFrames: 8,
        idleFps: 8,
        walkFps: 5,
        scale: 0.45,
        previewScale: 0.8 // 200% bigger preview in menu
    },
    samurai: {
        type: 'walk_idle',
        idleSprite: 'samurai_idle_anim',  // Animated idle spritesheet for in-game
        previewSprite: 'samurai_idle',     // Static image for menu/HUD
        walkSprites: ['samurai_run'],
        frameWidth: 96,
        frameHeight: 96,
        idleFrames: 10,
        walkFrames: 16,
        idleFps: 8,
        walkFps: 12,
        scale: 1.5,
        previewScale: 1.3,
        yOffset: -25
    }
};

// Standard character draw size (all characters should be roughly this height)
const CHARACTER_TARGET_HEIGHT = 75;

// Enemy sprite mappings - using new animated monster sprites
const ENEMY_SPRITES = {
    // Old static sprites (fallback)
    wolf: { sprite: 'enemy_wolf', width: 80, height: 80 },
    scorpion: { sprite: 'enemy_scorpion', width: 80, height: 80 },
    dhub: { sprite: 'enemy_dhub', width: 80, height: 80 },
    snake: { sprite: 'enemy_snake', width: 80, height: 80 },
    hyena: { sprite: 'enemy_hyena', width: 80, height: 80 },
    eagle: { sprite: 'enemy_eagle', width: 80, height: 80 },
    lion: { sprite: 'enemy_lion', width: 80, height: 80 },
    djinn: { sprite: 'enemy_djinn', width: 80, height: 80 },
    ghoul: { sprite: 'enemy_ghoul', width: 80, height: 80 },
    knight: { sprite: 'enemy_knight', width: 80, height: 80 },
    // New animated sprites
    flyingEye: { sprite: 'enemy_flyingeye', width: 150, height: 150, frames: 6, fps: 8, animated: true },
    goblin: { sprite: 'enemy_goblin', width: 150, height: 150, frames: 12, fps: 10, animated: true },
    mushroom: { sprite: 'enemy_mushroom', width: 150, height: 150, frames: 11, fps: 8, animated: true },
    skeleton: { sprite: 'enemy_skeleton', width: 150, height: 150, frames: 6, fps: 8, animated: true }
};

// ==================== AUDIO ====================
class Audio {
    constructor() { 
        this.ctx = null; 
        this.bgm = null;
        this.bossBgm = null;
        this.bgmPlaying = false;
        this.bossBgmPlaying = false;
        this.musicVolume = 0.5;
        this.sfxVolume = 0.7;
        this.fadeInterval = null;
        
        // SFX audio elements
        this.sfxItemDrop = null;
        this.sfxItemTaken = null;
        this.sfxLvlUp = null;
        this.sfxHit = null;
    }
    
    init() { 
        if (!this.ctx) {
            try { 
                this.ctx = new (window.AudioContext || window.webkitAudioContext)(); 
            } catch(e) {} 
        }
        
        // Load background music
        if (!this.bgm) {
            this.bgm = new window.Audio('assets/New Music & SFX/Bedye theme.mp3');
            this.bgm.loop = true;
            this.bgm.volume = this.musicVolume;
        }
        
        // Load boss music
        if (!this.bossBgm) {
            this.bossBgm = new window.Audio('assets/New Music & SFX/Boss Theme Abo hleza.mp3');
            this.bossBgm.loop = true;
            this.bossBgm.volume = this.musicVolume;
        }
        
        // Load SFX
        this.sfxItemDrop = new window.Audio('assets/New Music & SFX/Item Drop.mp3');
        this.sfxItemTaken = new window.Audio('assets/New Music & SFX/Item Taken.mp3');
        this.sfxLvlUp = new window.Audio('assets/New Music & SFX/Lvl up.mp3');
        this.sfxHit = new window.Audio('assets/New Music & SFX/charecter getting hit.mp3');
    }
    
    setMusicVolume(vol) {
        this.musicVolume = vol;
        if (this.bgm && !this.bossBgmPlaying) this.bgm.volume = vol;
        if (this.bossBgm && this.bossBgmPlaying) this.bossBgm.volume = vol;
    }
    
    setSfxVolume(vol) {
        this.sfxVolume = vol;
    }
    
    tone(f, d, t='square', v=0.12) {
        if (!this.ctx) return;
        const actualVol = v * this.sfxVolume;
        if (actualVol < 0.01) return;
        
        const o = this.ctx.createOscillator(), g = this.ctx.createGain();
        o.type = t; o.frequency.value = f; o.connect(g); g.connect(this.ctx.destination);
        g.gain.setValueAtTime(actualVol, this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + d);
        o.start(); o.stop(this.ctx.currentTime + d);
    }
    
    startBGM() {
        if (this.bgmPlaying || !this.bgm) return;
        this.bgm.currentTime = 0;
        this.bgm.volume = this.musicVolume;
        this.bgm.play().catch(e => console.log('BGM autoplay blocked'));
        this.bgmPlaying = true;
    }
    
    stopBGM() {
        if (this.bgm) {
            this.bgm.pause();
            this.bgm.currentTime = 0;
        }
        this.bgmPlaying = false;
    }
    
    // Fade out BGM and start boss music
    startBossMusic() {
        if (this.bossBgmPlaying) return;
        
        // Fade out main BGM
        if (this.bgm && this.bgmPlaying) {
            let vol = this.bgm.volume;
            this.fadeInterval = setInterval(() => {
                vol -= 0.05;
                if (vol <= 0) {
                    this.bgm.pause();
                    this.bgm.volume = this.musicVolume;
                    clearInterval(this.fadeInterval);
                } else {
                    this.bgm.volume = vol;
                }
            }, 100);
        }
        
        // Start boss music
        this.bossBgm.currentTime = 0;
        this.bossBgm.volume = this.musicVolume;
        this.bossBgm.play().catch(e => {});
        this.bossBgmPlaying = true;
    }
    
    stopBossMusic() {
        if (this.bossBgm) {
            this.bossBgm.pause();
            this.bossBgm.currentTime = 0;
        }
        this.bossBgmPlaying = false;
    }
    
    pauseBGM() {
        if (this.bgm && this.bgmPlaying) {
            this.bgm.pause();
        }
        if (this.bossBgm && this.bossBgmPlaying) {
            this.bossBgm.pause();
        }
    }
    
    resumeBGM() {
        if (this.bossBgmPlaying && this.bossBgm) {
            this.bossBgm.play().catch(e => {});
        } else if (this.bgmPlaying && this.bgm) {
            this.bgm.play().catch(e => {});
        }
    }
    
    hit() { 
        if (this.sfxHit) {
            this.sfxHit.volume = this.sfxVolume;
            this.sfxHit.currentTime = 0;
            this.sfxHit.play().catch(e => {});
        } else {
            this.tone(150, 0.1, 'sawtooth', 0.15); 
        }
    }
    shoot() { this.tone(320, 0.03); }
    pickup() { 
        if (this.sfxItemTaken) {
            this.sfxItemTaken.volume = this.sfxVolume;
            this.sfxItemTaken.currentTime = 0;
            this.sfxItemTaken.play().catch(e => {});
        } else {
            this.tone(520, 0.04, 'sine'); 
        }
    }
    levelUp() { 
        if (this.sfxLvlUp) {
            this.sfxLvlUp.volume = this.sfxVolume;
            this.sfxLvlUp.currentTime = 0;
            this.sfxLvlUp.play().catch(e => {});
        } else {
            [523,659,784,1047].forEach((f,i) => setTimeout(() => this.tone(f,0.1,'sine',0.15), i*60)); 
        }
    }
    victory() { [523,659,784,880,1047].forEach((f,i) => setTimeout(() => this.tone(f,0.18,'sine',0.2), i*100)); }
    death() { this.tone(160, 0.2, 'sawtooth'); this.tone(80, 0.25, 'sawtooth'); }
    bossWarn() { this.tone(80, 0.35, 'sawtooth', 0.25); setTimeout(() => this.tone(60, 0.35, 'sawtooth', 0.25), 400); }
    itemDrop() { 
        if (this.sfxItemDrop) {
            this.sfxItemDrop.volume = this.sfxVolume;
            this.sfxItemDrop.currentTime = 0;
            this.sfxItemDrop.play().catch(e => {});
        } else {
            this.tone(700, 0.08, 'sine', 0.2); this.tone(900, 0.12, 'sine', 0.15); 
        }
    }
}

// ==================== PARTICLES ====================
class Particles {
    constructor() { this.list = []; this.stains = []; }
    
    emit(x, y, n, opt = {}) {
        for (let i = 0; i < n; i++) {
            const a = Math.random() * Math.PI * 2, s = (opt.minS || 35) + Math.random() * ((opt.maxS || 100) - (opt.minS || 35));
            this.list.push({ 
                x, y, 
                vx: Math.cos(a) * s, vy: Math.sin(a) * s, 
                color: opt.color || '#fff', 
                size: opt.size || (2 + Math.random() * 2.5), 
                life: opt.life || 0.6, 
                maxLife: opt.life || 0.6, 
                gravity: opt.gravity || 0,
                type: opt.type || 'circle',
                shrink: opt.shrink !== false
            });
        }
    }
    
    blood(x, y) { 
        // Just particles, no permanent stains
        this.emit(x, y, 6, { color: '#8b0000', minS: 30, maxS: 80, gravity: 120, life: 0.4 }); 
    }
    
    spark(x, y, color = '#ffff00') {
        this.emit(x, y, 5, { color, minS: 80, maxS: 180, size: 3, life: 0.25, type: 'spark' });
    }
    
    dust(x, y) {
        this.emit(x, y, 6, { color: '#a08060', minS: 20, maxS: 60, size: 4, life: 0.5, gravity: -30, shrink: true });
    }
    
    heal(x, y) {
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            this.list.push({ 
                x: x + Math.cos(angle) * 20, 
                y: y + Math.sin(angle) * 20, 
                vx: Math.cos(angle) * -30, vy: -50 + Math.random() * 20, 
                color: '#44ff44', size: 4, life: 0.6, maxLife: 0.6, gravity: -50, type: 'circle', shrink: true
            });
        }
    }
    
    gold(x, y) {
        for (let i = 0; i < 6; i++) {
            const angle = Math.random() * Math.PI * 2;
            this.list.push({ 
                x, y, 
                vx: Math.cos(angle) * 60, vy: -80 + Math.random() * 40, 
                color: '#ffd700', size: 3, life: 0.5, maxLife: 0.5, gravity: 100, type: 'star', shrink: false
            });
        }
    }
    
    update(dt) { 
        this.list = this.list.filter(p => { 
            p.x += p.vx * dt; 
            p.y += p.vy * dt; 
            p.vy += p.gravity * dt; 
            p.life -= dt; 
            return p.life > 0; 
        }); 
    }
    
    draw(ctx, cam) {
        // Draw particles (no permanent stains)
        for (const p of this.list) { 
            const alpha = p.life / p.maxLife;
            ctx.globalAlpha = alpha;
            ctx.fillStyle = p.color;
            
            const sx = p.x - cam.x, sy = p.y - cam.y;
            const size = p.shrink ? p.size * alpha : p.size;
            
            if (p.type === 'spark') {
                // Draw spark as line
                ctx.strokeStyle = p.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(sx - p.vx * 0.02, sy - p.vy * 0.02);
                ctx.lineTo(sx, sy);
                ctx.stroke();
            } else if (p.type === 'star') {
                // Draw small star shape
                ctx.beginPath();
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2;
                    ctx.moveTo(sx, sy);
                    ctx.lineTo(sx + Math.cos(angle) * size * 2, sy + Math.sin(angle) * size * 2);
                }
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(sx, sy, size, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // Default circle
                ctx.beginPath(); 
                ctx.arc(sx, sy, size, 0, Math.PI * 2); 
                ctx.fill();
            }
        }
        ctx.globalAlpha = 1;
    }
}

// ==================== FLOAT TEXT ====================
class FloatText {
    constructor(x, y, text, color = '#fff', size = 14) { this.x = x; this.y = y; this.text = text; this.color = color; this.size = size; this.life = 0.7; this.vy = -45; }
    update(dt) { this.y += this.vy * dt; this.life -= dt; }
    draw(ctx, cam) { ctx.globalAlpha = this.life / 0.7; ctx.fillStyle = this.color; ctx.font = `bold ${this.size}px PixelAE, Cairo`; ctx.textAlign = 'center'; ctx.fillText(this.text, this.x - cam.x, this.y - cam.y); ctx.globalAlpha = 1; }
}

// ==================== SPRITE EFFECTS ====================
class SpriteEffect {
    constructor(x, y, spriteKey, frameWidth, frameHeight, totalFrames, duration, scale = 1) {
        this.x = x; 
        this.y = y;
        this.spriteKey = spriteKey;
        this.frameWidth = frameWidth;
        this.frameHeight = frameHeight;
        this.totalFrames = totalFrames;
        this.duration = duration;
        this.scale = scale;
        this.time = 0;
        this.done = false;
    }
    
    update(dt) {
        this.time += dt;
        if (this.time >= this.duration) this.done = true;
    }
    
    draw(ctx, cam, assets) {
        if (this.done) return;
        const sprite = assets && assets.get(this.spriteKey);
        if (!sprite) return;
        
        const progress = this.time / this.duration;
        const frame = Math.min(Math.floor(progress * this.totalFrames), this.totalFrames - 1);
        const sx = this.x - cam.x, sy = this.y - cam.y;
        
        ctx.imageSmoothingEnabled = false;
        ctx.globalAlpha = 1 - progress * 0.3;
        
        const drawW = this.frameWidth * this.scale;
        const drawH = this.frameHeight * this.scale;
        
        // Calculate frame position (assuming horizontal strip)
        const frameX = frame * this.frameWidth;
        
        ctx.drawImage(
            sprite,
            frameX, 0, this.frameWidth, this.frameHeight,
            sx - drawW / 2, sy - drawH / 2, drawW, drawH
        );
        
        ctx.globalAlpha = 1;
    }
}

// ==================== PLAYER ====================
class Player {
    constructor(x, y, charId) {
        this.x = x; this.y = y; this.charId = charId;
        const c = CHARACTERS[charId];
        this.maxHp = c.stats.hp || 100; this.hp = this.maxHp;
        this.speed = c.stats.speed || 200;
        this.dmgMult = c.stats.dmgMult || 1; this.atkSpd = c.stats.atkSpd || 1;
        this.pickupRange = 40 * (c.stats.pickup || 1);
        this.xpMult = c.stats.xpMult || 1;
        this.goldMult = c.stats.gold || 1;
        this.dmgReduce = c.stats.dmgReduce || 0;
        this.luck = c.stats.luck || 1;
        this.crit = 0.05 + (c.stats.crit || 0); // Base 5% crit + character bonus
        this.enemyBuff = c.stats.enemyBuff || 0;
        this.extraEnemySpawn = 0;
        this.armor = 0; this.regen = 0; this.curse = 0;
        // New passives
        this.chestDiscount = c.stats.chestDiscount || 0; // % discount on chest prices
        this.poison = c.stats.poison || 0; // % chance to poison enemies
        this.dodge = c.stats.dodge || 0; // % chance to dodge attacks
        this.range = c.stats.range || 1;
        this.cdMult = c.stats.cooldown || 1;
        
        this.weapons = [{ id: c.weapon, level: 1, upgrades: [] }];
        this.books = [];
        this.xp = 0; this.level = 1; this.gold = 0; this.kills = 0;
        this.invuln = 0; this.facing = 1; this.vx = 0; this.vy = 0; this.anim = 0;
        this.shield = 0; this.hasRevive = false; this.tempBuffs = [];
        this.wTimers = {};
        this.width = 32; this.height = 45;
    }
    
    getDmg(w) {
        // Base damage + EXPONENTIAL level scaling (each level = +20% more damage)
        // Level 1: 5, Level 5: 10.4, Level 10: 25.9, Level 20: 134
        let d = CONFIG.WEAPON_BASE_DMG * Math.pow(1.18, w.level - 1);
        // Damage upgrades add bonus damage based on rarity
        w.upgrades.forEach(u => {
            if (u.type === 'damage' || !u.type) d *= (1 + u.rarity.bonus * 0.15);
        });
        d *= this.dmgMult;
        this.tempBuffs.filter(b => b.type === 'dmg').forEach(b => d *= (1 + b.val));
        // Rage buff: +50% damage and +30% attack speed
        if (this.hasRage) d *= 1.5;
        return d;
    }
    
    // Apply crit to damage - returns {dmg, isCrit}
    applyCrit(baseDmg) {
        const isCrit = this.crit > 0 && Math.random() < this.crit;
        return { dmg: isCrit ? baseDmg * 2 : baseDmg, isCrit };
    }
    
    getProjectileCount(w) {
        // Count upgrades add extra projectiles (BALANCED: +1 per upgrade, max 5 total)
        // This makes count upgrades valuable but not game-breaking
        let count = 1;
        w.upgrades.forEach(u => {
            if (u.type === 'count') count += 1; // Always +1, rarity affects other aspects
        });
        return Math.min(count, 5); // Max 5 projectiles (was 8)
    }
    
    getCD(w) { 
        let m = this.cdMult / this.atkSpd; 
        this.tempBuffs.filter(b => b.type === 'atkSpd').forEach(b => m /= (1 + b.val)); 
        // Cooldown upgrades reduce cooldown
        let cdBonus = 0;
        w.upgrades.forEach(u => { if (u.type === 'cooldown') cdBonus += u.rarity.bonus * 0.025; });
        return Math.max(0.08, WEAPONS[w.id].cd * m * (1 - (w.level - 1) * 0.015) * (1 - cdBonus)); 
    }
    
    getRange(w) { return WEAPONS[w.id].range * this.range * (1 + (w.level - 1) * 0.025); }
    
    findNearest(game, maxD = 450) {
        let near = null, minD = maxD;
        for (const e of game.enemies) { const d = Math.hypot(e.x - this.x, e.y - this.y); if (d < minD) { minD = d; near = e; } }
        if (game.boss) { const d = Math.hypot(game.boss.x - this.x, game.boss.y - this.y); if (d < minD) near = game.boss; }
        return near;
    }
    
    update(dt, input, game) {
        let dx = 0, dy = 0;
        if (input.left) dx -= 1; if (input.right) dx += 1; if (input.up) dy -= 1; if (input.down) dy += 1;
        if (input.joy) { dx += input.joy.x; dy += input.joy.y; }
        const mag = Math.hypot(dx, dy);
        if (mag > 0) {
            dx /= mag; dy /= mag;
            let spd = this.speed; this.tempBuffs.filter(b => b.type === 'speed').forEach(b => spd *= (1 + b.val));
            this.vx = dx * spd; this.vy = dy * spd;
            if (dx !== 0) this.facing = dx > 0 ? 1 : -1;
        } else { this.vx = 0; this.vy = 0; }
        
        // Try to move, check collision with map obstacles
        const newX = this.x + this.vx * dt;
        const newY = this.y + this.vy * dt;
        
        // Check X movement
        if (!game.map.checkCollision(newX, this.y, this.width, this.height)) {
            this.x = newX;
        }
        // Check Y movement
        if (!game.map.checkCollision(this.x, newY, this.width, this.height)) {
            this.y = newY;
        }
        
        // Keep within world bounds
        this.x = Math.max(-CONFIG.WORLD_SIZE/2, Math.min(CONFIG.WORLD_SIZE/2, this.x));
        this.y = Math.max(-CONFIG.WORLD_SIZE/2, Math.min(CONFIG.WORLD_SIZE/2, this.y));
        if (this.invuln > 0) this.invuln -= dt;
        this.anim += dt;
        if (this.regen > 0) this.hp = Math.min(this.maxHp, this.hp + this.regen * dt);
        this.tempBuffs = this.tempBuffs.filter(b => { b.dur -= dt; return b.dur > 0; });
        
        const target = this.findNearest(game);
        this.weapons.forEach(w => {
            if (!this.wTimers[w.id]) this.wTimers[w.id] = 0;
            this.wTimers[w.id] -= dt;
            if (this.wTimers[w.id] <= 0) { this.fire(w, game, target); this.wTimers[w.id] = this.getCD(w); }
        });
        
        // Update orbit positions for hitbox detection
        // Attack speed affects rotation speed
        let atkSpdMult = this.atkSpd;
        this.tempBuffs.filter(b => b.type === 'atkSpd').forEach(b => atkSpdMult *= (1 + b.val));
        
        this.weapons.forEach(w => {
            const data = WEAPONS[w.id];
            if (data.type === 'orbit') {
                // Orbit count: base 1 + count upgrades only (no level bonus)
                // This makes count upgrades the way to get more orbs
                const n = this.getProjectileCount(w);
                const range = this.getRange(w);
                const rotationSpeed = 2 * atkSpdMult;
                
                if (!this.orbitPositions) this.orbitPositions = {};
                this.orbitPositions[w.id] = [];
                
                for (let i = 0; i < n; i++) {
                    const a = this.anim * rotationSpeed + (i / n) * Math.PI * 2;
                    this.orbitPositions[w.id][i] = { 
                        x: this.x + Math.cos(a) * range, 
                        y: this.y + Math.sin(a) * range 
                    };
                }
            }
        });
    }
    
    fire(w, game, target) {
        const data = WEAPONS[w.id], dmg = this.getDmg(w), range = this.getRange(w);
        const projCount = this.getProjectileCount(w);
        switch(data.type) {
            case 'projectile':
                if (target && Math.hypot(target.x - this.x, target.y - this.y) < range) {
                    const baseAngle = Math.atan2(target.y - this.y, target.x - this.x);
                    const isMgma = w.id === 'mgma';
                    const isFlame = w.id === 'flame';
                    const isBlueFlame = this.charId === 'layla' && isFlame;
                    const isRock = w.id === 'rock';
                    const isSpear = w.id === 'spear';
                    
                    let projType = 'normal';
                    if (isMgma) projType = 'mgma';
                    else if (isBlueFlame) projType = 'blue_fire';
                    else if (isFlame) projType = 'fire';
                    else if (isRock) projType = 'rock';
                    else if (isSpear) projType = 'spear';
                    
                    // Mgma fires like shotgun (starts with 1, +1 every 2 levels)
                    const baseCount = isMgma ? 1 + Math.floor(w.level / 2) : projCount;
                    const spreadAngle = isMgma ? Math.PI / 5 : Math.PI / 8;
                    
                    const muzzleOffset = data.offset || 20;
                    for (let i = 0; i < baseCount; i++) {
                        const angleOffset = baseCount > 1 
                            ? (i - (baseCount - 1) / 2) * (spreadAngle / Math.max(baseCount - 1, 1))
                            : 0;
                        const a = baseAngle + angleOffset + (isMgma ? (Math.random() - 0.5) * 0.1 : 0);
                        const speed = isMgma ? 280 + Math.random() * 60 : 360;
                        
                        // Calculate spawn position with offset in firing direction
                        const spawnX = this.x + Math.cos(a) * muzzleOffset;
                        const spawnY = this.y + Math.sin(a) * muzzleOffset;
                        
                        // Projectile life determines range (shorter life = shorter range)
                        // Screen is roughly 800-1000px, speed is 300-400, so life 1.2-1.5 = screen range
                        const projLife = isMgma ? 0.8 : 1.3; // Limited to roughly screen size
                        
                        game.proj.push({ 
                            x: spawnX, y: spawnY, 
                            vx: Math.cos(a) * speed, vy: Math.sin(a) * speed, 
                            dmg: isMgma ? dmg * 0.6 : dmg, 
                            life: projLife, 
                            size: isMgma ? 5 : (isFlame ? 10 : (isSpear ? 8 : 6)), 
                            color: isMgma ? '#f80' : (isBlueFlame ? '#00aaff' : (isFlame ? '#ff4500' : '#8b4513')), 
                            pierce: w.level > 10 ? 2 : 1,
                            type: projType,
                            iconPos: data.projectileIcon,
                            weaponId: w.id
                        });
                        
                        // Muzzle flash effect for EACH projectile
                        if (data.effectSprite && data.frameW) {
                            game.spriteEffects.push(new SpriteEffect(spawnX, spawnY, data.effectSprite, data.frameW, data.frameH, data.frames, 0.25, 0.8));
                        } else if (isFlame) {
                            game.spriteEffects.push(new SpriteEffect(spawnX, spawnY, 'fx_fire_small', 24, 24, 6, 0.2, 1.0));
                        }
                    }
                    game.audio.shoot();
                }
                break;
            case 'radial': {
                const baseN = 4 + Math.floor(w.level / 4);
                const n = baseN + (projCount - 1); // Add count upgrades
                for (let i = 0; i < n; i++) { 
                    const a = (i / n) * Math.PI * 2; 
                    game.proj.push({ 
                        x: this.x, y: this.y, 
                        vx: Math.cos(a) * 300, vy: Math.sin(a) * 300, 
                        dmg: dmg * 0.65, life: 1.8, size: 6, 
                        color: '#8B4513', type: 'arrow',
                        iconPos: data.projectileIcon
                    }); 
                }
                game.audio.shoot();
                break;
            }
            case 'lightning': {
                const ts = game.enemies.filter(e => Math.hypot(e.x - this.x, e.y - this.y) < range);
                if (ts.length > 0) { 
                    // Hit multiple targets based on projCount
                    const targetsToHit = Math.min(projCount, ts.length);
                    const shuffled = ts.sort(() => Math.random() - 0.5).slice(0, targetsToHit);
                    for (const t of shuffled) {
                        game.fx.push({ type: 'lightning', x: t.x, y: t.y, life: 0.25 }); 
                        // Use weapon effect sprite if available
                        if (data.effectSprite && data.frameW) {
                            game.spriteEffects.push(new SpriteEffect(t.x, t.y, data.effectSprite, data.frameW, data.frameH, data.frames, 0.4, 1.8));
                        } else {
                            game.spriteEffects.push(new SpriteEffect(t.x, t.y, 'fx_spark', 24, 24, 5, 0.3, 1.5));
                        }
                        game.particles.spark(t.x, t.y, '#ffff88');
                        game.particles.spark(t.x, t.y, '#ffffff');
                        const hit = this.applyCrit(dmg);
                        if (t.takeDmg(hit.dmg, game, hit.isCrit)) game.killEnemy(t); 
                    }
                    game.audio.tone(650, 0.06, 'sawtooth'); 
                }
                break;
            }
            case 'meteor': {
                const baseN = 1 + Math.floor(w.level / 4);
                const n = baseN + (projCount - 1); // Add count upgrades
                for (let i = 0; i < n; i++) {
                    const mx = this.x + (Math.random() - 0.5) * range * 2;
                    const my = this.y + (Math.random() - 0.5) * range * 2;
                    game.fx.push({ type: 'meteor', x: mx, y: my, dmg, radius: 55, life: 0.75, delay: i * 0.12, hit: false });
                }
                game.audio.tone(200, 0.1, 'sawtooth');
                break;
            }
            case 'tornado':
                game.fx.push({ type: 'tornado', x: this.x + this.facing * 35, y: this.y, vx: this.facing * 85, vy: 0, dmg: dmg * 0.35, slow: 0.5, life: 3.2 + w.level * 0.12, radius: 35 });
                game.spriteEffects.push(new SpriteEffect(this.x + this.facing * 35, this.y, 'fx_dust', 24, 24, 5, 0.4, 1.2));
                break;
            case 'chain': {
                // Brain weapon - bounces between enemies
                const ts = game.enemies.filter(e => Math.hypot(e.x - this.x, e.y - this.y) < range);
                if (ts.length > 0) {
                    const bounces = 2 + Math.floor(w.level / 3) + (projCount - 1);
                    let current = ts[Math.floor(Math.random() * ts.length)];
                    let hit = new Set();
                    for (let i = 0; i < bounces && current; i++) {
                        game.fx.push({ type: 'chain', x: current.x, y: current.y, life: 0.2 });
                        game.spriteEffects.push(new SpriteEffect(current.x, current.y, data.effectSprite || 'fx_magic', data.frameW || 24, data.frameH || 24, data.frames || 5, 0.25, 1.2));
                        const crit = this.applyCrit(dmg * (1 - i * 0.15));
                        if (current.takeDmg(crit.dmg, game, crit.isCrit)) game.killEnemy(current);
                        hit.add(current);
                        // Find next target
                        const next = game.enemies.filter(e => !hit.has(e) && Math.hypot(e.x - current.x, e.y - current.y) < 150);
                        current = next.length > 0 ? next[Math.floor(Math.random() * next.length)] : null;
                    }
                    game.audio.tone(500, 0.08, 'sine');
                }
                break;
            }
            case 'bounce': {
                // Shuriken weapon - projectile that bounces between enemies
                const ts = game.enemies.filter(e => Math.hypot(e.x - this.x, e.y - this.y) < range);
                if (ts.length > 0) {
                    const target = ts.reduce((a, b) => 
                        Math.hypot(a.x - this.x, a.y - this.y) < Math.hypot(b.x - this.x, b.y - this.y) ? a : b
                    );
                    const a = Math.atan2(target.y - this.y, target.x - this.x);
                    const bounceCount = (data.bounces || 2) + Math.floor(w.level / 3);
                    const dmgReduce = data.bounceDmgReduce || 0.3;
                    
                    for (let i = 0; i < projCount; i++) {
                        const spread = projCount > 1 ? (i - (projCount - 1) / 2) * 0.2 : 0;
                        game.proj.push({
                            x: this.x, y: this.y,
                            vx: Math.cos(a + spread) * 350, vy: Math.sin(a + spread) * 350,
                            dmg, life: 3, size: 12,
                            color: '#aaf', type: 'bounce',
                            bounces: bounceCount,
                            dmgReduce: dmgReduce,
                            hitEnemies: new Set(),
                            weaponId: w.id,
                            effectSprite: data.effectSprite,
                            frameW: data.frameW, frameH: data.frameH,
                            frames: data.frames, fps: data.fps || 8,
                            frameTime: 0, currentFrame: 0
                        });
                    }
                    game.audio.tone(600, 0.06, 'triangle');
                }
                break;
            }
            case 'dot': {
                // Onion weapon - long range DOT with animated projectile
                // DOT: 2 damage per second for duration
                if (target && Math.hypot(target.x - this.x, target.y - this.y) < range) {
                    const a = Math.atan2(target.y - this.y, target.x - this.x);
                    for (let i = 0; i < projCount; i++) {
                        const spread = projCount > 1 ? (i - (projCount - 1) / 2) * 0.15 : 0;
                        game.proj.push({
                            x: this.x, y: this.y,
                            vx: Math.cos(a + spread) * 280, vy: Math.sin(a + spread) * 280,
                            dmg, life: 1.5, size: 8, // Limited range (roughly screen size)
                            color: '#9f9', type: 'dot',
                            dotDmg: 2, dotDur: 3 + w.level * 0.5, // 2 damage per second
                            weaponId: w.id,
                            // Store effect info for hit animation
                            hitEffect: data.effectSprite,
                            hitFrameW: data.frameW,
                            hitFrameH: data.frameH,
                            hitFrames: data.frames
                        });
                    }
                    game.audio.shoot();
                }
                break;
            }
        }
    }
    
    takeDmg(amt, game) {
        if (this.invuln > 0) return;
        
        // Dodge check
        if (this.dodge > 0 && Math.random() < this.dodge) {
            game.texts.push(new FloatText(this.x, this.y - 20, 'ØªÙØ§Ø¯ÙŠ!', '#00ffff', 14));
            game.particles.emit(this.x, this.y, 8, { color: '#00ffff', minS: 60, maxS: 120, size: 2, life: 0.3 });
            this.invuln = 0.15; // Short invuln after dodge
            return;
        }
        
        if (this.shield > 0) { const ab = Math.min(this.shield, amt); this.shield -= ab; amt -= ab; if (amt <= 0) return; }
        const actual = amt * (1 - this.dmgReduce) * (1 - Math.min(0.65, this.armor * 0.025));
        this.hp -= actual; this.invuln = 0.35;
        game.audio.hit(); game.shake = 0.12;
        game.texts.push(new FloatText(this.x, this.y - 20, `-${Math.round(actual)}`, '#f00'));
        if (this.hp <= 0) {
            if (this.hasRevive) { this.hasRevive = false; this.hp = this.maxHp * 0.5; this.invuln = 1.2; game.texts.push(new FloatText(this.x, this.y - 35, 'Ø¥Ø­ÙŠØ§Ø¡!', '#ffd700', 18)); }
            else game.over(false);
        }
    }
    
    draw(ctx, cam, assets) {
        const sx = this.x - cam.x, sy = this.y - cam.y;
        
        // Draw shadow under player
        ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
        ctx.beginPath();
        ctx.ellipse(sx, sy + 20, 18, 8, 0, 0, Math.PI * 2);
        ctx.fill();
        
        if (this.invuln > 0 && Math.floor(this.invuln * 12) % 2 === 0) ctx.globalAlpha = 0.35;
        
        // Draw character sprite
        const c = CHARACTERS[this.charId].colors;
        ctx.save();
        
        // Try to draw sprite if available
        const spriteInfo = CHAR_SPRITES[this.charId];
        const isMoving = Math.abs(this.vx) > 10 || Math.abs(this.vy) > 10;
        
        // Determine facing direction for flip
        let facingRight = this.facing > 0;
        if (isMoving && Math.abs(this.vx) > 5) {
            facingRight = this.vx > 0;
        }
        
        let sprite = null;
        
        // Check sprite type
        if (spriteInfo.type === 'walk_idle') {
            // Walk/Idle sprite system - idle when still, walk when moving
            let spriteKey;
            let frameW = spriteInfo.frameWidth;
            let frameH = spriteInfo.frameHeight;
            let currentFrame = 0;
            let totalFrames = 1;
            let fps = spriteInfo.fps || 6;
            
            if (isMoving && spriteInfo.walkSprites) {
                // Check if it's a spritesheet (frameWidth defined) or separate images
                if (frameW && spriteInfo.walkFrames) {
                    // Spritesheet animation
                    spriteKey = spriteInfo.walkSprites[0];
                    totalFrames = spriteInfo.walkFrames;
                    fps = spriteInfo.walkFps || fps;
                    currentFrame = Math.floor(this.anim * fps) % totalFrames;
                } else {
                    // Separate image files
                    const frameTime = 1 / fps;
                    const walkFrame = Math.floor(this.anim / frameTime) % spriteInfo.walkSprites.length;
                    spriteKey = spriteInfo.walkSprites[walkFrame];
                }
            } else {
                // Use idle sprite
                spriteKey = spriteInfo.idleSprite;
                if (frameW && spriteInfo.idleFrames) {
                    totalFrames = spriteInfo.idleFrames;
                    fps = spriteInfo.idleFps || fps;
                    currentFrame = Math.floor(this.anim * fps) % totalFrames;
                }
            }
            sprite = assets && assets.get(spriteKey);
            
            if (sprite) {
                ctx.imageSmoothingEnabled = false;
                
                // Check if using spritesheet or full image
                if (frameW && (spriteInfo.idleFrames || spriteInfo.walkFrames)) {
                    // Spritesheet - calculate frame position
                    const frameX = currentFrame * frameW;
                    const customScale = spriteInfo.scale || 0.4;
                    const drawW = frameW * customScale;
                    const drawH = frameH * customScale;
                    const yOffset = spriteInfo.yOffset || 0;
                    
                    ctx.save();
                    ctx.translate(sx, sy + yOffset);
                    // Mr Bassla sprite faces LEFT by default, flip when facing right
                    if (!facingRight) ctx.scale(-1, 1);
                    ctx.drawImage(sprite, frameX, 0, frameW, frameH, -drawW / 2, -drawH / 2, drawW, drawH);
                    ctx.restore();
                } else {
                    // Full image per frame
                    const targetHeight = 70;
                    const scale = targetHeight / sprite.height;
                    const drawW = sprite.width * scale;
                    const drawH = sprite.height * scale;
                    
                    ctx.save();
                    ctx.translate(sx, sy);
                    if (facingRight) ctx.scale(-1, 1);
                    ctx.drawImage(sprite, -drawW / 2, -drawH / 2, drawW, drawH);
                    ctx.restore();
                }
            }
        } else if (spriteInfo.type === 'single' && spriteInfo.sprite) {
            // Single large image sprite
            sprite = assets && assets.get(spriteInfo.sprite);
            if (sprite) {
                ctx.imageSmoothingEnabled = false;
                // Scale down large sprites to fit
                const targetHeight = 70;
                const scale = targetHeight / sprite.height;
                const drawW = sprite.width * scale;
                const drawH = sprite.height * scale;
                
                ctx.save();
                ctx.translate(sx, sy);
                if (!facingRight) ctx.scale(-1, 1);
                ctx.drawImage(sprite, -drawW / 2, -drawH / 2, drawW, drawH);
                ctx.restore();
            }
        } else if (spriteInfo.type === 'multiframe' && spriteInfo.frames) {
            // Multi-frame animation (separate images as frames)
            const fps = spriteInfo.fps || 6;
            const frameTime = 1 / fps;
            const totalFrames = spriteInfo.frames.length;
            const currentFrame = Math.floor(this.anim / frameTime) % totalFrames;
            const spriteKey = spriteInfo.frames[currentFrame];
            sprite = assets && assets.get(spriteKey);
            
            if (sprite) {
                ctx.imageSmoothingEnabled = false;
                const scale = 2.5;
                const drawW = spriteInfo.frameWidth * scale;
                const drawH = spriteInfo.frameHeight * scale;
                
                // Flip horizontally based on facing direction
                ctx.save();
                ctx.translate(sx, sy);
                if (!facingRight) {
                    ctx.scale(-1, 1); // Flip horizontally
                }
                ctx.drawImage(sprite, -drawW / 2, -drawH / 2, drawW, drawH);
                ctx.restore();
            }
        } else {
            // Standard sprite sheet
            const spriteKey = isMoving ? spriteInfo.sprite : spriteInfo.idle;
            sprite = assets && assets.get(spriteKey);
            
            if (sprite && spriteInfo) {
                ctx.imageSmoothingEnabled = false;
                
                // Standard sprite sheet animation
                const frameTime = 0.15;
                const totalFrames = spriteInfo.frames || 4;
                const currentFrame = Math.floor(this.anim / frameTime) % totalFrames;
                const maxRows = spriteInfo.rows || 4;
                
                // Determine direction row
                let row = 0;
                if (isMoving) {
                    if (Math.abs(this.vx) > Math.abs(this.vy)) {
                        row = this.vx > 0 ? 2 : 1;
                    } else {
                        row = this.vy > 0 ? 0 : 3;
                    }
                } else {
                    row = facingRight ? 2 : 1;
                }
                row = Math.min(row, maxRows - 1);
                
                const frameX = currentFrame * spriteInfo.frameWidth;
                const frameY = row * spriteInfo.frameHeight;
                
                const baseScale = spriteInfo.frameWidth <= 40 ? 2.2 : 1.8;
                const drawW = spriteInfo.frameWidth * baseScale;
                const drawH = spriteInfo.frameHeight * baseScale;
                
                ctx.drawImage(
                    sprite,
                    frameX, frameY, spriteInfo.frameWidth, spriteInfo.frameHeight,
                    sx - drawW / 2, sy - drawH / 2, drawW, drawH
                );
            }
        }
        
        if (!sprite) {
            // Fallback to simple rendering
            const c = CHARACTERS[this.charId].colors;
            if (this.facing < 0) { ctx.translate(sx, sy); ctx.scale(-1, 1); ctx.translate(-sx, sy); }
            
            ctx.fillStyle = c.body;
            ctx.fillRect(sx - 10, sy - 8, 20, 26);
            ctx.fillStyle = c.head;
            ctx.fillRect(sx - 8, sy - 24, 16, 8);
            ctx.fillStyle = c.skin;
            ctx.fillRect(sx - 7, sy - 16, 14, 10);
            ctx.fillStyle = '#000';
            ctx.fillRect(sx - 4, sy - 13, 2, 2);
            ctx.fillRect(sx + 2, sy - 13, 2, 2);
            ctx.fillStyle = c.legs;
            ctx.fillRect(sx - 6, sy + 18, 5, 8);
            ctx.fillRect(sx + 1, sy + 18, 5, 8);
        }
        
        ctx.restore();
        ctx.globalAlpha = 1;
        
        // Weapon visuals with sprite animations
        // Attack speed affects animation speed
        const atkSpdMultiplier = this.atkSpd;
        this.tempBuffs.filter(b => b.type === 'atkSpd').forEach(b => atkSpdMultiplier * (1 + b.val));
        
        this.weapons.forEach(w => {
            const data = WEAPONS[w.id], range = this.getRange(w);
            const effectSprite = data.effectSprite && assets && assets.get(data.effectSprite);
            const baseFps = data.fps || 8;
            const weaponFps = baseFps * atkSpdMultiplier; // Animation speed scales with attack speed
            const weaponOffset = data.offset || 0;
            
            if (data.type === 'orbit') {
                // Orbit count: base 1 + count upgrades only
                const n = this.getProjectileCount(w);
                const frameTime = 1 / weaponFps;
                const totalFrames = data.frames || 10;
                const currentFrame = Math.floor(this.anim / frameTime) % totalFrames;
                // Rotation speed also scales with attack speed
                const rotationSpeed = 2 * atkSpdMultiplier;
                
                // Clear and rebuild orbit positions
                if (!this.orbitPositions) this.orbitPositions = {};
                this.orbitPositions[w.id] = [];
                
                for (let i = 0; i < n; i++) {
                    const a = this.anim * rotationSpeed + (i / n) * Math.PI * 2;
                    const ox = sx + Math.cos(a) * range;
                    const oy = sy + Math.sin(a) * range;
                    
                    // Store orbit positions for hitbox detection
                    this.orbitPositions[w.id][i] = { x: this.x + Math.cos(a) * range, y: this.y + Math.sin(a) * range };
                    
                    if (effectSprite && data.frameW) {
                        ctx.imageSmoothingEnabled = false;
                        const frameX = currentFrame * data.frameW;
                        const scale = 0.8;
                        ctx.drawImage(effectSprite, frameX, 0, data.frameW, data.frameH,
                            ox - data.frameW * scale / 2, oy - data.frameH * scale / 2,
                            data.frameW * scale, data.frameH * scale);
                    } else {
                        ctx.fillStyle = '#333';
                        ctx.beginPath();
                        ctx.arc(ox, oy, 8, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            } else if (data.type === 'melee') {
                const timer = this.wTimers[w.id] || 0, cd = this.getCD(w);
                if (timer > cd * 0.75) {
                    // Show melee effect animation with offset - FLIPS with player direction
                    if (effectSprite && data.frameW) {
                        const progress = (cd - timer) / (cd * 0.25);
                        const frame = Math.min(Math.floor(progress * data.frames), data.frames - 1);
                        const frameX = frame * data.frameW;
                        const scale = 1.5;
                        const offset = weaponOffset > 0 ? weaponOffset : 30;
                        
                        ctx.save();
                        ctx.imageSmoothingEnabled = false;
                        // Translate to player position
                        ctx.translate(sx, sy);
                        // Flip horizontally based on facing direction
                        if (this.facing < 0) {
                            ctx.scale(-1, 1);
                        }
                        // Draw at offset from center
                        ctx.drawImage(effectSprite, frameX, 0, data.frameW, data.frameH,
                            offset - data.frameW * scale / 2, -data.frameH * scale / 2,
                            data.frameW * scale, data.frameH * scale);
                        ctx.restore();
                    } else {
                        ctx.strokeStyle = 'rgba(150, 150, 150, 0.4)';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        const startAngle = this.facing > 0 ? -Math.PI / 2 : Math.PI / 2;
                        const endAngle = this.facing > 0 ? Math.PI / 2 : -Math.PI / 2;
                        ctx.arc(sx, sy, range, startAngle, endAngle);
                        ctx.stroke();
                    }
                }
            }
            // Aura is drawn separately (under player) via drawAuraUnder()
            if (data.type === 'aura') {
                // Just update aura state for damage timing
                const frameTime = 1 / weaponFps;
                const totalFrames = data.frames || 10;
                const currentFrame = Math.floor(this.anim / frameTime) % totalFrames;
                
                if (!this.auraState) this.auraState = {};
                const prevFrame = this.auraState[w.id] || 0;
                this.auraState[w.id] = currentFrame;
                this.auraDamageFrame = this.auraDamageFrame || {};
                this.auraDamageFrame[w.id] = (currentFrame === 0 && prevFrame !== 0);
            }
            
            // Cone AOE (like vape) - continuous damage in front
            if (data.type === 'cone_aoe') {
                const frameTime = 1 / weaponFps;
                const totalFrames = data.frames || 15;
                const currentFrame = Math.floor(this.anim / frameTime) % totalFrames;
                
                if (!this.coneState) this.coneState = {};
                this.coneState[w.id] = currentFrame;
                // Continuous damage flag - always true while active
                this.coneDamageActive = this.coneDamageActive || {};
                this.coneDamageActive[w.id] = true;
            }
        });
    }
    
    // Draw aura effect UNDER the player sprite
    drawAuraUnder(ctx, cam, assets) {
        const sx = this.x - cam.x, sy = this.y - cam.y;
        
        // Attack speed affects animation speed
        let atkSpdMult = this.atkSpd;
        this.tempBuffs.filter(b => b.type === 'atkSpd').forEach(b => atkSpdMult *= (1 + b.val));
        
        this.weapons.forEach(w => {
            const data = WEAPONS[w.id];
            if (data.type === 'aura') {
                const range = this.getRange(w);
                const effectSprite = data.effectSprite && assets && assets.get(data.effectSprite);
                const baseFps = data.fps || 8;
                const weaponFps = baseFps * atkSpdMult;
                
                const frameTime = 1 / weaponFps;
                const totalFrames = data.frames || 10;
                const currentFrame = Math.floor(this.anim / frameTime) % totalFrames;
                
                if (effectSprite && data.frameW) {
                    const frameX = currentFrame * data.frameW;
                    // 50% bigger scale
                    const scale = (range / 35) * 1.5;
                    
                    ctx.imageSmoothingEnabled = false;
                    ctx.globalAlpha = 0.7;
                    ctx.drawImage(effectSprite, frameX, 0, data.frameW, data.frameH,
                        sx - data.frameW * scale / 2, sy - data.frameH * scale / 2,
                        data.frameW * scale, data.frameH * scale);
                    ctx.globalAlpha = 1;
                } else {
                    ctx.strokeStyle = 'rgba(100, 50, 150, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([4, 6]);
                    ctx.beginPath();
                    ctx.arc(sx, sy, range * 1.5, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
            
            // Cone AOE (vape smoke) - auto-targets nearest enemy
            if (data.type === 'cone_aoe') {
                const range = this.getRange(w);
                const effectSprite = data.effectSprite && assets && assets.get(data.effectSprite);
                const baseFps = data.fps || 8;
                const weaponFps = baseFps * atkSpdMult;
                
                const frameTime = 1 / weaponFps;
                const totalFrames = data.frames || 15;
                // Reverse animation - start from end
                const currentFrame = (totalFrames - 1) - (Math.floor(this.anim / frameTime) % totalFrames);
                const frameY = currentFrame * data.frameH;
                
                // Find nearest enemy for auto-targeting (use window.gameInstance)
                let nearestEnemy = null;
                let nearestDist = range + 100;
                const gameRef = window.gameInstance;
                if (gameRef && gameRef.enemies) {
                    for (const e of gameRef.enemies) {
                        const dist = Math.hypot(e.x - this.x, e.y - this.y);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestEnemy = e;
                        }
                    }
                }
                // Also check boss
                if (gameRef && gameRef.boss && gameRef.boss.hp > 0) {
                    const bossDist = Math.hypot(gameRef.boss.x - this.x, gameRef.boss.y - this.y);
                    if (bossDist < nearestDist) {
                        nearestDist = bossDist;
                        nearestEnemy = gameRef.boss;
                    }
                }
                
                // Store target direction for damage calculation
                if (nearestEnemy) {
                    this.coneTargetAngle = Math.atan2(nearestEnemy.y - this.y, nearestEnemy.x - this.x);
                } else {
                    this.coneTargetAngle = this.facing > 0 ? 0 : Math.PI;
                }
                
                if (effectSprite && data.frameW) {
                    const scale = 1.2; // Smaller size
                    const offset = data.offset || 40;
                    const spreadCount = 3; // Number of duplicates
                    const spreadAngle = Math.PI / 6; // Spread angle between duplicates
                    
                    ctx.save();
                    ctx.imageSmoothingEnabled = false;
                    ctx.globalAlpha = 0.7;
                    
                    // Draw multiple copies spread out
                    for (let i = 0; i < spreadCount; i++) {
                        const angleOffset = (i - (spreadCount - 1) / 2) * spreadAngle;
                        const targetAngle = this.coneTargetAngle + angleOffset;
                        
                        const drawX = sx + Math.cos(targetAngle) * offset;
                        const drawY = sy + Math.sin(targetAngle) * offset;
                        
                        ctx.save();
                        ctx.translate(drawX, drawY);
                        ctx.rotate(targetAngle + Math.PI / 2); // Rotate to face target
                        
                        ctx.drawImage(effectSprite, 0, frameY, data.frameW, data.frameH,
                            -data.frameW * scale / 2, -data.frameH * scale / 2,
                            data.frameW * scale, data.frameH * scale);
                        
                        ctx.restore();
                    }
                    
                    ctx.restore();
                }
            }
        });
        
        // Shield indicator
        if (this.shield > 0) {
            ctx.strokeStyle = 'rgba(80, 160, 255, 0.5)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(sx, sy, 30, 0, Math.PI * 2);
            ctx.stroke();
        }
    }
}

// ==================== ENEMY ====================
class Enemy {
    constructor(x, y, type, gameTime, buff = 0, isElite = false) {
        this.x = x; this.y = y; this.type = type;
        this.isElite = isElite;
        const e = ENEMIES[type];
        const scale = 1 + (gameTime / 60) * CONFIG.SCALING_PER_MIN;
        const buffScale = 1 + buff;
        
        // Elite enemies: 3x HP, 1.5x damage, 1.2x speed, 4x XP
        const eliteMultHP = isElite ? 3 : 1;
        const eliteMultATK = isElite ? 1.5 : 1;
        const eliteMultSPD = isElite ? 1.2 : 1;
        const eliteMultXP = isElite ? 4 : 1;
        
        this.maxHp = Math.round(CONFIG.ENEMY_BASE_HP * e.hpM * scale * buffScale * eliteMultHP);
        this.hp = this.maxHp;
        this.atk = CONFIG.ENEMY_BASE_ATK * e.atkM * scale * buffScale * eliteMultATK;
        this.spd = CONFIG.ENEMY_BASE_SPEED * e.spdM * eliteMultSPD;
        this.xp = Math.round(e.xp * eliteMultXP);
        this.color = e.color;
        this.vx = 0; this.vy = 0; this.hitFlash = 0; this.slow = 1; this.slowT = 0;
        this.zigT = 0; this.zigD = 1; this.tpT = 0; this.atkT = 0;
        // Elite enemies are 40% bigger
        this.width = isElite ? 40 : 28;
        this.height = isElite ? 40 : 28;
        this.zig = e.zig; this.ranged = e.ranged; this.tp = e.tp;
        this.animTime = Math.random() * 2; // Random start for animation variety
        this.glowPhase = 0; // For elite glow animation
    }
    
    update(dt, player, enemies, game) {
        const dx = player.x - this.x, dy = player.y - this.y, dist = Math.hypot(dx, dy);
        if (this.slowT > 0) { this.slowT -= dt; if (this.slowT <= 0) this.slow = 1; }
        if (dist > 0) {
            let mx = dx / dist, my = dy / dist;
            if (this.zig) { this.zigT += dt; if (this.zigT > 0.35) { this.zigT = 0; this.zigD *= -1; } mx = mx * 0.7 + (-my * this.zigD) * 0.3; my = my * 0.7 + (mx * this.zigD) * 0.3; }
            if (this.tp) { this.tpT += dt; if (this.tpT > 1.5 && dist > 70) { this.tpT = 0; const a = Math.random() * Math.PI * 2; this.x = player.x + Math.cos(a) * 100; this.y = player.y + Math.sin(a) * 100; game.particles.emit(this.x, this.y, 6, { color: '#4a0080' }); } }
            if (this.ranged && dist < 220 && dist > 50) { this.atkT -= dt; if (this.atkT <= 0) { this.atkT = 1.2; const a = Math.atan2(dy, dx); game.eProj.push({ x: this.x, y: this.y, vx: Math.cos(a) * 160, vy: Math.sin(a) * 160, dmg: this.atk * 0.4, life: 2.2, size: 3, color: this.color }); } }
            let sepX = 0, sepY = 0;
            for (const o of enemies) { if (o === this) continue; const ox = this.x - o.x, oy = this.y - o.y, od = Math.hypot(ox, oy); if (od < 25 && od > 0) { sepX += ox / od * (25 - od) / 25; sepY += oy / od * (25 - od) / 25; } }
            mx += sepX * 0.35; my += sepY * 0.35;
            const m = Math.hypot(mx, my); if (m > 0) { this.vx = (mx / m) * this.spd * this.slow; this.vy = (my / m) * this.spd * this.slow; }
        }
        this.x += this.vx * dt; this.y += this.vy * dt;
        if (this.hitFlash > 0) this.hitFlash -= dt;
        this.animTime += dt; // Update animation
    }
    
    takeDmg(amt, game, isCrit = false) { 
        this.hp -= amt; 
        this.hitFlash = 0.06; 
        const color = isCrit ? '#ff4444' : '#ff0';
        const size = isCrit ? 22 : 18; // Bigger damage numbers
        const text = isCrit ? 'ğŸ’¥' + Math.round(amt) : Math.round(amt).toString();
        game.texts.push(new FloatText(this.x + (Math.random() - 0.5) * 12, this.y - 12, text, color, size)); 
        return this.hp <= 0; 
    }
    
    draw(ctx, cam, assets) {
        const sx = this.x - cam.x, sy = this.y - cam.y;
        
        // Elite glow effect - pulsing orange/red aura
        if (this.isElite) {
            this.glowPhase += 0.1;
            const glowIntensity = 0.4 + Math.sin(this.glowPhase) * 0.2;
            const glowSize = 25 + Math.sin(this.glowPhase * 2) * 5;
            
            // Outer glow
            ctx.save();
            ctx.shadowColor = '#ff4400';
            ctx.shadowBlur = glowSize;
            ctx.fillStyle = `rgba(255, 68, 0, ${glowIntensity * 0.3})`;
            ctx.beginPath();
            ctx.arc(sx, sy, this.width / 2 + 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            // Elite crown/indicator above
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ğŸ‘‘', sx, sy - this.height / 2 - 12);
        }
        
        if (this.hitFlash > 0) ctx.globalAlpha = 0.55;
        
        // Try to draw sprite if available
        const spriteInfo = ENEMY_SPRITES[this.type];
        const sprite = assets && spriteInfo && assets.get(spriteInfo.sprite);
        
        // Elite enemies are 40% bigger
        const eliteScale = this.isElite ? 1.4 : 1.0;
        
        if (sprite) {
            ctx.save();
            ctx.imageSmoothingEnabled = false;
            
            // Check if this is an animated sprite
            if (spriteInfo.animated && spriteInfo.frames) {
                const frameW = spriteInfo.width;
                const frameH = spriteInfo.height;
                const fps = spriteInfo.fps || 8;
                const totalFrames = spriteInfo.frames;
                const currentFrame = Math.floor(this.animTime * fps) % totalFrames;
                const frameX = currentFrame * frameW;
                
                const scale = 0.95 * eliteScale;
                const drawW = frameW * scale;
                const drawH = frameH * scale;
                
                // Flip based on movement direction
                if (this.vx < 0) {
                    ctx.translate(sx, sy);
                    ctx.scale(-1, 1);
                    ctx.drawImage(sprite, frameX, 0, frameW, frameH, -drawW / 2, -drawH / 2, drawW, drawH);
                } else {
                    ctx.drawImage(sprite, frameX, 0, frameW, frameH, sx - drawW / 2, sy - drawH / 2, drawW, drawH);
                }
            } else {
                // Static sprite
                const scale = 0.75 * eliteScale;
                const drawW = spriteInfo.width * scale;
                const drawH = spriteInfo.height * scale;
                
                // Flip based on movement direction
                if (this.vx < 0) {
                    ctx.translate(sx, sy);
                    ctx.scale(-1, 1);
                    ctx.drawImage(sprite, -drawW / 2, -drawH / 2, drawW, drawH);
                } else {
                    ctx.drawImage(sprite, sx - drawW / 2, sy - drawH / 2, drawW, drawH);
                }
            }
            
            ctx.restore();
        } else {
            // Fallback to colored circle (bigger for elite)
            const radius = this.isElite ? 20 : 14;
            ctx.fillStyle = this.isElite ? '#ff4400' : this.color;
            ctx.beginPath(); 
            ctx.arc(sx, sy, radius, 0, Math.PI * 2); 
            ctx.fill();
            // Eyes
            ctx.fillStyle = '#ff0';
            ctx.fillRect(sx - 4, sy - 3, 3, 3); 
            ctx.fillRect(sx + 1, sy - 3, 3, 3);
        }
        
        ctx.globalAlpha = 1;
        
        // Health bar with better styling (wider for elite)
        if (this.hp < this.maxHp) { 
            const barWidth = 36;
            const barHeight = 5;
            const barX = sx - barWidth / 2;
            const barY = sy - 30;
            const hpPercent = this.hp / this.maxHp;
            
            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; 
            ctx.fillRect(barX - 1, barY - 1, barWidth + 2, barHeight + 2); 
            
            // Health color based on percentage
            let hpColor;
            if (hpPercent > 0.5) hpColor = '#00ff00';
            else if (hpPercent > 0.25) hpColor = '#ffff00';
            else hpColor = '#ff0000';
            
            ctx.fillStyle = hpColor; 
            ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);
            
            // Border
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.strokeRect(barX - 1, barY - 1, barWidth + 2, barHeight + 2);
        }
        
        // Shadow under enemy
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.beginPath();
        ctx.ellipse(sx, sy + 18, 16, 6, 0, 0, Math.PI * 2);
        ctx.fill();
    }
}

// ==================== BOSS ====================
class Boss {
    constructor(x, y, buff = 0) {
        this.x = x; this.y = y;
        this.maxHp = BOSS.hp * (1 + buff); this.hp = this.maxHp;
        this.atk = BOSS.atk * (1 + buff); this.spd = BOSS.spd;
        this.phase = 1; this.atkT = 0; this.specT = 0; this.hitFlash = 0;
        this.gasT = 0; // Gas attack timer
        this.width = 100; this.height = 120;
        this.facing = 1;
    }
    update(dt, player, game) {
        const pct = this.hp / this.maxHp; this.phase = pct < 0.33 ? 3 : pct < 0.66 ? 2 : 1;
        const dx = player.x - this.x, dy = player.y - this.y, dist = Math.hypot(dx, dy);
        
        // Update facing direction
        if (dx !== 0) this.facing = dx > 0 ? 1 : -1;
        
        if (dist > 0) { const s = this.spd * (1 + (3 - this.phase) * 0.12); this.x += (dx / dist) * s * dt; this.y += (dy / dist) * s * dt; }
        
        // Green gas attack
        this.atkT -= dt;
        if (this.atkT <= 0) { 
            this.atkT = 1.8 / this.phase; 
            const a = Math.atan2(dy, dx); 
            // Shoot green gas projectiles
            for (let i = -3; i <= 3; i++) {
                game.eProj.push({ 
                    x: this.x, y: this.y, 
                    vx: Math.cos(a + i * 0.15) * 180, 
                    vy: Math.sin(a + i * 0.15) * 180, 
                    dmg: this.atk * 0.7, life: 2.5, size: 12, 
                    color: '#44ff44', type: 'gas'
                }); 
            }
            game.audio.tone(150, 0.15, 'sawtooth');
        }
        
        // Poison cloud special attack
        this.gasT -= dt;
        if (this.gasT <= 0 && this.phase >= 2) {
            this.gasT = 4 / this.phase;
            // Create poison cloud around boss
            for (let i = 0; i < 8; i++) {
                const a = (i / 8) * Math.PI * 2;
                game.eProj.push({
                    x: this.x + Math.cos(a) * 50, y: this.y + Math.sin(a) * 50,
                    vx: Math.cos(a) * 60, vy: Math.sin(a) * 60,
                    dmg: this.atk * 0.4, life: 3, size: 18,
                    color: '#22aa22', type: 'gas'
                });
            }
        }
        
        // Summon minions - use new enemy types
        if (this.phase >= 2) { 
            this.specT -= dt; 
            if (this.specT <= 0) { 
                this.specT = 4; 
                const types = ['flyingEye', 'goblin', 'skeleton']; 
                for (let i = 0; i < this.phase * 2; i++) { 
                    const a = Math.random() * Math.PI * 2; 
                    game.enemies.push(new Enemy(this.x + Math.cos(a) * 80, this.y + Math.sin(a) * 80, types[Math.floor(Math.random() * types.length)], game.time, player.enemyBuff)); 
                } 
            } 
        }
        if (this.hitFlash > 0) this.hitFlash -= dt;
    }
    takeDmg(amt, game, isCrit = false) { 
        this.hp -= amt; 
        this.hitFlash = 0.06; 
        const color = isCrit ? '#ff4444' : '#ff0';
        const size = isCrit ? 26 : 20; // Bigger damage numbers for boss
        const text = isCrit ? 'ğŸ’¥' + Math.round(amt) : Math.round(amt).toString();
        game.texts.push(new FloatText(this.x + (Math.random() - 0.5) * 25, this.y - 25, text, color, size)); 
        return this.hp <= 0; 
    }
    draw(ctx, cam, assets) {
        const sx = this.x - cam.x, sy = this.y - cam.y;
        
        // Draw shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.beginPath();
        ctx.ellipse(sx, sy + 55, 45, 15, 0, 0, Math.PI * 2);
        ctx.fill();
        
        if (this.hitFlash > 0) ctx.globalAlpha = 0.55;
        
        // Try to draw boss sprite
        const sprite = assets && assets.get('boss_halza');
        if (sprite) {
            ctx.save();
            ctx.imageSmoothingEnabled = false;
            
            // Flip based on facing direction
            if (this.facing < 0) {
                ctx.translate(sx, sy);
                ctx.scale(-1, 1);
                ctx.drawImage(sprite, -60, -70, 120, 140);
            } else {
                ctx.drawImage(sprite, sx - 60, sy - 70, 120, 140);
            }
            ctx.restore();
        } else {
            // Fallback to simple drawing
            ctx.fillStyle = '#6a0dad';
            ctx.beginPath(); ctx.ellipse(sx, sy, 40, 35, 0, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(sx, sy - 35, 25, 18, 0, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#ff0';
            ctx.fillRect(sx - 12, sy - 40, 6, 6); ctx.fillRect(sx + 6, sy - 40, 6, 6);
        }
        
        ctx.globalAlpha = 1;
        
        // Phase indicator glow
        if (this.phase >= 2) {
            ctx.strokeStyle = this.phase === 3 ? 'rgba(255, 0, 0, 0.5)' : 'rgba(255, 165, 0, 0.5)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(sx, sy, 65, 0, Math.PI * 2);
            ctx.stroke();
        }
    }
}

// ==================== PICKUPS ====================
// Pickup system with auto-collect and consolidation for performance
const PICKUP_CONFIG = {
    MAX_PICKUPS: 120,           // Max pickups on screen
    AUTO_COLLECT_AGE: 4,        // Seconds before auto-pull starts
    AUTO_COLLECT_RANGE: 600,    // Range for auto-collect
    CONSOLIDATE_RANGE: 60,      // Range to merge pickups
    BIG_THRESHOLD: 30,          // Value threshold for "big" pickup
    MEGA_THRESHOLD: 100         // Value threshold for "mega" pickup
};

class Pickup {
    constructor(x, y, type, val) { 
        this.x = x; this.y = y; this.type = type; this.val = val; 
        this.bob = Math.random() * Math.PI * 2; 
        this.anim = Math.random() * 10;
        this.age = 0; // Track how long pickup has existed
        this.autoCollecting = false; // Flag for auto-collection
    }
    
    update(dt) { 
        this.bob += dt * 3.5; 
        this.anim += dt; 
        this.age += dt;
    }
    
    // Get size based on value
    getSize() {
        if (this.val >= PICKUP_CONFIG.MEGA_THRESHOLD) return 'mega';
        if (this.val >= PICKUP_CONFIG.BIG_THRESHOLD) return 'big';
        return 'normal';
    }
    
    draw(ctx, cam, assets) {
        const sx = this.x - cam.x, sy = this.y - cam.y + Math.sin(this.bob) * 3;
        const isXP = this.type === 'xp';
        const sprite = isXP ? assets && assets.get('pickup_xp') : assets && assets.get('pickup_coin');
        
        // Size multiplier based on value
        const sizeType = this.getSize();
        const sizeMult = sizeType === 'mega' ? 2.2 : sizeType === 'big' ? 1.5 : 1;
        
        // Glow effect for big/mega pickups
        if (sizeType !== 'normal') {
            const glowColor = isXP ? 'rgba(68, 255, 68, 0.4)' : 'rgba(255, 215, 0, 0.4)';
            const glowSize = (sizeType === 'mega' ? 20 : 14) + Math.sin(this.anim * 4) * 3;
            ctx.fillStyle = glowColor;
            ctx.beginPath();
            ctx.arc(sx, sy, glowSize, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Auto-collect indicator (subtle pulse)
        if (this.autoCollecting) {
            ctx.strokeStyle = isXP ? 'rgba(68, 255, 68, 0.6)' : 'rgba(255, 215, 0, 0.6)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(sx, sy, 8 + Math.sin(this.age * 8) * 3, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        if (sprite) {
            ctx.imageSmoothingEnabled = false;
            const frameW = 16, frameH = 16;
            const fps = isXP ? 5 : 8;
            const totalFrames = isXP ? 4 : 5;
            const currentFrame = Math.floor(this.anim * fps) % totalFrames;
            const frameX = currentFrame * frameW;
            
            const baseSize = isXP ? 10 : 9;
            const size = baseSize * sizeMult;
            ctx.drawImage(sprite, frameX, 0, frameW, frameH, sx - size / 2, sy - size / 2, size, size);
        } else {
            const oldSprite = isXP ? assets && assets.get('xp_gem') : assets && assets.get('gold_coin');
            if (oldSprite) {
                const baseSize = isXP ? 9 : 8;
                const size = baseSize * sizeMult;
                ctx.drawImage(oldSprite, sx - size / 2, sy - size / 2, size, size);
            } else {
                const baseRadius = isXP ? 6 : 5;
                const radius = baseRadius * sizeMult;
                if (isXP) { 
                    ctx.fillStyle = sizeType === 'mega' ? '#00ff88' : sizeType === 'big' ? '#22ff22' : '#0f0'; 
                    ctx.beginPath(); 
                    ctx.moveTo(sx, sy - radius); 
                    ctx.lineTo(sx + radius, sy); 
                    ctx.lineTo(sx, sy + radius); 
                    ctx.lineTo(sx - radius, sy); 
                    ctx.fill(); 
                } else { 
                    ctx.fillStyle = sizeType === 'mega' ? '#ffee00' : sizeType === 'big' ? '#ffe066' : '#ffd700'; 
                    ctx.beginPath(); 
                    ctx.arc(sx, sy, radius, 0, Math.PI * 2); 
                    ctx.fill(); 
                }
            }
        }
    }
}

class ItemDrop {
    constructor(x, y, id) { this.x = x; this.y = y; this.id = id; this.bob = Math.random() * Math.PI * 2; this.glow = 0; }
    update(dt) { this.bob += dt * 3.5; this.glow += dt * 4; }
    draw(ctx, cam, assets) {
        const sx = this.x - cam.x, sy = this.y - cam.y + Math.sin(this.bob) * 4;
        const item = ITEMS[this.id];
        const rarityColor = RARITY[item.rarity].color;
        
        // Glow intensity based on rarity
        const rarityGlow = { 'COMMON': 8, 'UNCOMMON': 12, 'RARE': 16, 'EPIC': 22, 'LEGENDARY': 30 };
        const baseGlow = rarityGlow[item.rarity] || 10;
        const glowIntensity = baseGlow + Math.sin(this.glow) * (baseGlow * 0.4);
        
        // Try to draw sprite if available
        const sprite = item.sprite && assets && assets.get(item.sprite);
        const iconset = assets && assets.get('iconset');
        
        ctx.imageSmoothingEnabled = false;
        
        if (sprite) {
            // Get original dimensions and preserve aspect ratio
            const origW = sprite.width || 32;
            const origH = sprite.height || 32;
            const maxSize = 32;
            const scale = Math.min(maxSize / origW, maxSize / origH);
            const drawW = origW * scale;
            const drawH = origH * scale;
            
            // Glow effect based on rarity
            ctx.shadowColor = rarityColor;
            ctx.shadowBlur = glowIntensity;
            
            ctx.drawImage(sprite, sx - drawW/2, sy - drawH/2, drawW, drawH);
            
            ctx.shadowBlur = 0;
        } else if (item.iconPos && iconset) {
            // Draw from IconSet sprite sheet - 24x24 icons, preserve aspect ratio
            const iconSize = 24;
            const drawSize = 28;
            
            // Glow effect based on rarity
            ctx.shadowColor = rarityColor;
            ctx.shadowBlur = glowIntensity;
            
            ctx.drawImage(
                iconset,
                item.iconPos.col * iconSize, item.iconPos.row * iconSize,
                iconSize, iconSize,
                sx - drawSize/2, sy - drawSize/2, drawSize, drawSize
            );
            
            ctx.shadowBlur = 0;
        } else {
            // Fallback to emoji icon with glow
            ctx.shadowColor = rarityColor;
            ctx.shadowBlur = glowIntensity;
            
            ctx.font = 'bold 24px Arial'; 
            ctx.textAlign = 'center'; 
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#fff';
            ctx.fillText(item.icon, sx, sy);
            
            ctx.shadowBlur = 0;
        }
        
        // Small rarity indicator dot below item (larger for higher rarity)
        const dotSize = item.rarity === 'LEGENDARY' ? 4 : (item.rarity === 'EPIC' ? 3.5 : (item.rarity === 'RARE' ? 3 : 2.5));
        ctx.fillStyle = rarityColor;
        ctx.beginPath();
        ctx.arc(sx, sy + 20, dotSize, 0, Math.PI * 2);
        ctx.fill();
    }
}

// ==================== CHEST SYSTEM ====================
class Chest {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.bob = Math.random() * Math.PI * 2;
        this.glow = Math.random() * Math.PI * 2;
        this.opened = false;
        this.openAnim = 0;
    }
    
    update(dt) {
        this.bob += dt * 2;
        this.glow += dt * 3;
        if (this.opened) {
            this.openAnim += dt * 4;
        }
    }
    
    draw(ctx, cam, assets) {
        if (this.opened && this.openAnim > 1) return; // Fully opened and faded
        
        const sx = this.x - cam.x;
        const sy = this.y - cam.y + Math.sin(this.bob) * 2;
        
        // Glow effect
        const glowSize = 25 + Math.sin(this.glow) * 8;
        ctx.shadowColor = '#ffd700';
        ctx.shadowBlur = glowSize;
        
        // Draw chest using pixel art style
        const size = 32;
        
        if (this.opened) {
            // Opening animation - fade out
            ctx.globalAlpha = 1 - this.openAnim;
        }
        
        // Chest body (brown)
        ctx.fillStyle = '#8B4513';
        ctx.fillRect(sx - size/2, sy - size/2 + 4, size, size - 8);
        
        // Chest lid (darker brown)
        ctx.fillStyle = '#654321';
        ctx.fillRect(sx - size/2, sy - size/2, size, 10);
        
        // Gold trim
        ctx.fillStyle = '#ffd700';
        ctx.fillRect(sx - size/2, sy - size/2 + 9, size, 3);
        
        // Lock/keyhole
        ctx.fillStyle = '#ffd700';
        ctx.beginPath();
        ctx.arc(sx, sy + 2, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#000';
        ctx.fillRect(sx - 2, sy + 2, 4, 8);
        
        // Highlight
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.fillRect(sx - size/2 + 2, sy - size/2 + 2, size/3, 6);
        
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
    }
    
    isNearPlayer(px, py, range = 40) {
        return Math.hypot(this.x - px, this.y - py) < range;
    }
}

// ==================== GROUND BUFFS SYSTEM ====================
const BUFF_TYPES = {
    shield: {
        name: 'Ø¯Ø±Ø¹',
        icon: 'ğŸ›¡ï¸',
        color: '#4a9eff',
        effect: 'invincible',
        duration: 4,
        dropChance: 0.008
    },
    clock: {
        name: 'ØªØ¬Ù…ÙŠØ¯ Ø§Ù„ÙˆÙ‚Øª',
        icon: 'â°',
        color: '#9b59b6',
        effect: 'freezeTime',
        duration: 3,
        dropChance: 0.006
    },
    goldBonus: {
        name: 'Ø°Ù‡Ø¨ Ù…Ø¶Ø§Ø¹Ù',
        icon: 'ğŸ’°',
        color: '#ffd700',
        effect: 'doubleGold',
        duration: 10,
        dropChance: 0.01
    },
    rage: {
        name: 'ØºØ¶Ø¨',
        icon: 'ğŸ˜¡',
        color: '#ff4444',
        effect: 'rage',
        duration: 6,
        dropChance: 0.008
    },
    magnet: {
        name: 'Ù…ØºÙ†Ø§Ø·ÙŠØ³',
        icon: 'ğŸ§²',
        color: '#00ff88',
        effect: 'magnetPull',
        duration: 0, // Instant
        dropChance: 0.012
    },
    nuke: {
        name: 'Ù‚Ù†Ø¨Ù„Ø©',
        icon: 'ğŸ’¥',
        color: '#ff6600',
        effect: 'nuke',
        duration: 0, // Instant
        dropChance: 0.004
    }
};

class GroundBuff {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.data = BUFF_TYPES[type];
        this.bob = Math.random() * Math.PI * 2;
        this.glow = Math.random() * Math.PI * 2;
        this.life = 15; // Disappears after 15 seconds
        this.collected = false;
    }
    
    update(dt) {
        this.bob += dt * 4;
        this.glow += dt * 5;
        this.life -= dt;
    }
    
    draw(ctx, cam) {
        if (this.collected) return;
        
        const sx = this.x - cam.x;
        const sy = this.y - cam.y + Math.sin(this.bob) * 4;
        
        // Pulsing glow
        const glowSize = 20 + Math.sin(this.glow) * 8;
        ctx.shadowColor = this.data.color;
        ctx.shadowBlur = glowSize;
        
        // Background circle
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.beginPath();
        ctx.arc(sx, sy, 16, 0, Math.PI * 2);
        ctx.fill();
        
        // Colored ring
        ctx.strokeStyle = this.data.color;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(sx, sy, 16, 0, Math.PI * 2);
        ctx.stroke();
        
        // Icon
        ctx.shadowBlur = 0;
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.data.icon, sx, sy);
        
        // Life indicator (fading border)
        if (this.life < 5) {
            ctx.globalAlpha = 0.3 + Math.sin(this.glow * 2) * 0.3;
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(sx, sy, 20, 0, Math.PI * 2 * (this.life / 5));
            ctx.stroke();
            ctx.globalAlpha = 1;
        }
    }
    
    isNearPlayer(px, py, range = 25) {
        return Math.hypot(this.x - px, this.y - py) < range;
    }
}

// ==================== BREAKABLE POTS SYSTEM ====================
const POT_TYPES = {
    small: {
        name: 'Ø¬Ø±Ø© ØµØºÙŠØ±Ø©',
        hp: 1,
        size: 20,
        color: '#8B4513',
        xpDrop: [3, 8],
        goldDrop: [2, 5],
        goldChance: 0.3,
        buffChance: 0.02
    },
    large: {
        name: 'Ø¬Ø±Ø© ÙƒØ¨ÙŠØ±Ø©',
        hp: 2,
        size: 28,
        color: '#A0522D',
        xpDrop: [10, 25],
        goldDrop: [8, 15],
        goldChance: 0.5,
        buffChance: 0.08
    },
    silver: {
        name: 'Ø¬Ø±Ø© ÙØ¶ÙŠØ©',
        hp: 2,
        size: 24,
        color: '#C0C0C0',
        xpDrop: [20, 50],
        goldDrop: [0, 0],
        goldChance: 0,
        buffChance: 0.1
    },
    gold: {
        name: 'Ø¬Ø±Ø© Ø°Ù‡Ø¨ÙŠØ©',
        hp: 3,
        size: 26,
        color: '#FFD700',
        xpDrop: [5, 10],
        goldDrop: [30, 80],
        goldChance: 1,
        buffChance: 0.15
    }
};

class BreakablePot {
    constructor(x, y, type = 'small') {
        this.x = x;
        this.y = y;
        this.type = type;
        this.data = POT_TYPES[type];
        this.hp = this.data.hp;
        this.broken = false;
        this.breakAnim = 0;
        this.shake = 0;
    }
    
    update(dt) {
        if (this.shake > 0) this.shake -= dt * 10;
        if (this.broken) {
            this.breakAnim += dt * 5;
        }
    }
    
    takeDamage(dmg, game) {
        if (this.broken) return;
        this.hp -= dmg;
        this.shake = 1;
        
        if (this.hp <= 0) {
            this.broken = true;
            this.onBreak(game);
        }
    }
    
    onBreak(game) {
        // Spawn particles
        game.particles.emit(this.x, this.y, 8, { 
            color: this.data.color, 
            minS: 40, maxS: 100, 
            life: 0.4 
        });
        game.particles.dust(this.x, this.y);
        
        // Drop XP - single consolidated pickup
        const xpAmount = this.data.xpDrop[0] + Math.floor(Math.random() * (this.data.xpDrop[1] - this.data.xpDrop[0]));
        game.spawnPickupSmart(this.x, this.y, 'xp', xpAmount);
        
        // Drop gold
        if (Math.random() < this.data.goldChance) {
            const goldAmount = this.data.goldDrop[0] + Math.floor(Math.random() * (this.data.goldDrop[1] - this.data.goldDrop[0]));
            if (goldAmount > 0) {
                game.spawnPickupSmart(this.x + (Math.random() - 0.5) * 15, this.y + (Math.random() - 0.5) * 15, 'gold', goldAmount);
                game.particles.gold(this.x, this.y);
            }
        }
        
        // Chance to drop buff
        if (Math.random() < this.data.buffChance) {
            const buffTypes = Object.keys(BUFF_TYPES);
            const randomBuff = buffTypes[Math.floor(Math.random() * buffTypes.length)];
            game.groundBuffs.push(new GroundBuff(this.x, this.y, randomBuff));
        }
    }
    
    draw(ctx, cam) {
        if (this.broken && this.breakAnim > 1) return;
        
        const shakeX = this.shake > 0 ? (Math.random() - 0.5) * 3 : 0;
        const sx = this.x - cam.x + shakeX;
        const sy = this.y - cam.y;
        const size = this.data.size;
        
        if (this.broken) {
            ctx.globalAlpha = 1 - this.breakAnim;
        }
        
        // Draw pot body (ellipse)
        ctx.fillStyle = this.data.color;
        ctx.beginPath();
        ctx.ellipse(sx, sy, size/2, size/2 * 0.7, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Pot neck
        ctx.fillStyle = this.data.color;
        ctx.fillRect(sx - size/4, sy - size/2 * 0.7 - 6, size/2, 8);
        
        // Pot rim
        ctx.fillStyle = this.type === 'gold' ? '#FFA500' : (this.type === 'silver' ? '#888' : '#654321');
        ctx.fillRect(sx - size/3, sy - size/2 * 0.7 - 8, size/1.5, 3);
        
        // Highlight
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.beginPath();
        ctx.ellipse(sx - size/6, sy - size/6, size/6, size/8, -0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.beginPath();
        ctx.ellipse(sx, sy + size/2 * 0.5, size/2 * 0.8, size/6, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.globalAlpha = 1;
    }
    
    isInRange(x, y, range) {
        return Math.hypot(this.x - x, this.y - y) < range + this.data.size/2;
    }
}

// Pot Manager - spawns pots on map
const PotManager = {
    potsPerGame: 40,
    
    spawnPots(worldSize) {
        const pots = [];
        const margin = 200;
        const safeZone = 300;
        
        for (let i = 0; i < this.potsPerGame; i++) {
            let x, y, attempts = 0;
            do {
                x = (Math.random() - 0.5) * (worldSize - margin * 2);
                y = (Math.random() - 0.5) * (worldSize - margin * 2);
                attempts++;
            } while (Math.hypot(x, y) < safeZone && attempts < 30);
            
            // Random pot type with weighted distribution
            const roll = Math.random();
            let type;
            if (roll < 0.5) type = 'small';
            else if (roll < 0.8) type = 'large';
            else if (roll < 0.95) type = 'silver';
            else type = 'gold';
            
            pots.push(new BreakablePot(x, y, type));
        }
        return pots;
    }
};

// Chest Manager - handles spawning and pricing
const ChestManager = {
    basePrice: 30,
    priceMultiplier: 1.5,
    currentPrice: 30,
    chestsPerGame: 8,
    
    reset() {
        this.currentPrice = this.basePrice;
    },
    
    getPrice(discount = 0) {
        return Math.floor(this.currentPrice * (1 - discount));
    },
    
    buyChest() {
        const price = this.getPrice();
        this.currentPrice = Math.floor(this.currentPrice * this.priceMultiplier);
        return price;
    },
    
    spawnChests(worldSize) {
        const chests = [];
        const margin = 300; // Keep away from center spawn
        const safeZone = 500; // Safe zone around player spawn (0,0)
        
        for (let i = 0; i < this.chestsPerGame; i++) {
            let x, y, attempts = 0;
            do {
                x = (Math.random() - 0.5) * (worldSize - margin * 2);
                y = (Math.random() - 0.5) * (worldSize - margin * 2);
                attempts++;
            } while (Math.hypot(x, y) < safeZone && attempts < 50);
            
            chests.push(new Chest(x, y));
        }
        return chests;
    }
};

// ==================== GAME ====================
// ==================== MAP SYSTEM ====================
class MapSystem {
    constructor() {
        this.obstacles = []; // {x, y, w, h} - collision boxes
        this.decorations = []; // {x, y, tile} - visual only
        this.generated = false;
    }
    
    generate(worldSize) {
        this.obstacles = [];
        this.decorations = [];
        this.walls = [];
        
        // No building collision - player can walk freely except map borders
        // Buildings are visual only from map.png
        
        this.generated = true;
    }
    
    checkCollision(x, y, w, h) {
        // Check obstacles (buildings, palms, etc.)
        for (const obs of this.obstacles) {
            if (x + w/2 > obs.x - obs.w/2 && 
                x - w/2 < obs.x + obs.w/2 &&
                y + h/2 > obs.y - obs.h/2 && 
                y - h/2 < obs.y + obs.h/2) {
                return true;
            }
        }
        // Check border walls
        for (const wall of this.walls) {
            if (x + w/2 > wall.x - wall.w/2 && 
                x - w/2 < wall.x + wall.w/2 &&
                y + h/2 > wall.y - wall.h/2 && 
                y - h/2 < wall.y + wall.h/2) {
                return true;
            }
        }
        return false;
    }
    
    draw(ctx, cam, assets) {
        const tileset = assets.get('arabtown');
        if (!tileset) return;
        
        ctx.imageSmoothingEnabled = false;
        
        // Draw border walls first
        for (const wall of this.walls) {
            const sx = wall.x - cam.x, sy = wall.y - cam.y;
            if (sx < -200 || sx > ctx.canvas.width + 200 || sy < -200 || sy > ctx.canvas.height + 200) continue;
            
            const tile = ARABTOWN_TILES[wall.tile];
            if (tile) {
                const scale = 2;
                ctx.save();
                if (wall.vertical) {
                    // Rotate for vertical walls
                    ctx.translate(sx, sy);
                    ctx.rotate(Math.PI / 2);
                    ctx.drawImage(tileset, tile.x, tile.y, tile.w, tile.h,
                        -tile.w * scale / 2, -tile.h * scale / 2, tile.w * scale, tile.h * scale);
                } else {
                    ctx.drawImage(tileset, tile.x, tile.y, tile.w, tile.h,
                        sx - tile.w * scale / 2, sy - tile.h * scale / 2, tile.w * scale, tile.h * scale);
                }
                ctx.restore();
            }
        }
        
        // Draw decorations (rocks)
        for (const dec of this.decorations) {
            const sx = dec.x - cam.x, sy = dec.y - cam.y;
            if (sx < -50 || sx > ctx.canvas.width + 50 || sy < -50 || sy > ctx.canvas.height + 50) continue;
            
            const tile = ARABTOWN_TILES[dec.tile];
            if (tile) {
                const scale = 2;
                ctx.drawImage(tileset, tile.x, tile.y, tile.w, tile.h, 
                    sx - tile.w * scale / 2, sy - tile.h * scale / 2, tile.w * scale, tile.h * scale);
            }
        }
        
        // Draw obstacles (buildings, palms, fences) sorted by y for proper layering
        const sortedObs = [...this.obstacles].sort((a, b) => a.y - b.y);
        
        for (const obs of sortedObs) {
            const sx = obs.x - cam.x, sy = obs.y - cam.y;
            if (sx < -200 || sx > ctx.canvas.width + 200 || sy < -200 || sy > ctx.canvas.height + 200) continue;
            
            const tile = ARABTOWN_TILES[obs.tile];
            if (tile) {
                const scale = 2;
                const drawW = tile.w * scale;
                const drawH = tile.h * scale;
                // Draw with bottom center at (sx, sy)
                // Source: full tile from tileset
                // Destination: scaled, positioned so bottom-center is at (sx, sy)
                ctx.drawImage(
                    tileset, 
                    tile.x, tile.y, tile.w, tile.h,
                    sx - drawW / 2, sy - drawH, 
                    drawW, drawH
                );
            }
        }
    }
    
    drawBorders(ctx, cam, worldSize) {
        // Draw visible map borders
        const half = worldSize / 2;
        const borderWidth = 20;
        
        // Calculate screen positions of borders
        const leftX = -half - cam.x;
        const rightX = half - cam.x;
        const topY = -half - cam.y;
        const bottomY = half - cam.y;
        
        // Border style - thick red/orange warning stripe
        const gradient1 = ctx.createLinearGradient(0, 0, borderWidth, 0);
        gradient1.addColorStop(0, '#8B0000');
        gradient1.addColorStop(0.5, '#FF4500');
        gradient1.addColorStop(1, '#8B0000');
        
        ctx.save();
        
        // Left border
        if (leftX > -borderWidth && leftX < ctx.canvas.width) {
            ctx.fillStyle = '#1a0a00';
            ctx.fillRect(leftX - borderWidth, topY, borderWidth, worldSize);
            // Warning stripes
            for (let y = topY; y < bottomY; y += 40) {
                ctx.fillStyle = (Math.floor(y / 40) % 2 === 0) ? '#8B0000' : '#FF6600';
                ctx.fillRect(leftX - borderWidth, y, borderWidth, 20);
            }
            // Glow effect
            const glowGrad = ctx.createLinearGradient(leftX - borderWidth, 0, leftX + 30, 0);
            glowGrad.addColorStop(0, 'rgba(255, 50, 0, 0.5)');
            glowGrad.addColorStop(1, 'rgba(255, 50, 0, 0)');
            ctx.fillStyle = glowGrad;
            ctx.fillRect(leftX - borderWidth, topY, 50, worldSize);
        }
        
        // Right border
        if (rightX > 0 && rightX < ctx.canvas.width + borderWidth) {
            ctx.fillStyle = '#1a0a00';
            ctx.fillRect(rightX, topY, borderWidth, worldSize);
            for (let y = topY; y < bottomY; y += 40) {
                ctx.fillStyle = (Math.floor(y / 40) % 2 === 0) ? '#8B0000' : '#FF6600';
                ctx.fillRect(rightX, y, borderWidth, 20);
            }
            const glowGrad = ctx.createLinearGradient(rightX - 30, 0, rightX + borderWidth, 0);
            glowGrad.addColorStop(0, 'rgba(255, 50, 0, 0)');
            glowGrad.addColorStop(1, 'rgba(255, 50, 0, 0.5)');
            ctx.fillStyle = glowGrad;
            ctx.fillRect(rightX - 30, topY, 50, worldSize);
        }
        
        // Top border
        if (topY > -borderWidth && topY < ctx.canvas.height) {
            ctx.fillStyle = '#1a0a00';
            ctx.fillRect(leftX - borderWidth, topY - borderWidth, worldSize + borderWidth * 2, borderWidth);
            for (let x = leftX; x < rightX; x += 40) {
                ctx.fillStyle = (Math.floor(x / 40) % 2 === 0) ? '#8B0000' : '#FF6600';
                ctx.fillRect(x, topY - borderWidth, 20, borderWidth);
            }
            const glowGrad = ctx.createLinearGradient(0, topY - borderWidth, 0, topY + 30);
            glowGrad.addColorStop(0, 'rgba(255, 50, 0, 0.5)');
            glowGrad.addColorStop(1, 'rgba(255, 50, 0, 0)');
            ctx.fillStyle = glowGrad;
            ctx.fillRect(leftX - borderWidth, topY - borderWidth, worldSize + borderWidth * 2, 50);
        }
        
        // Bottom border
        if (bottomY > 0 && bottomY < ctx.canvas.height + borderWidth) {
            ctx.fillStyle = '#1a0a00';
            ctx.fillRect(leftX - borderWidth, bottomY, worldSize + borderWidth * 2, borderWidth);
            for (let x = leftX; x < rightX; x += 40) {
                ctx.fillStyle = (Math.floor(x / 40) % 2 === 0) ? '#8B0000' : '#FF6600';
                ctx.fillRect(x, bottomY, 20, borderWidth);
            }
            const glowGrad = ctx.createLinearGradient(0, bottomY - 30, 0, bottomY + borderWidth);
            glowGrad.addColorStop(0, 'rgba(255, 50, 0, 0)');
            glowGrad.addColorStop(1, 'rgba(255, 50, 0, 0.5)');
            ctx.fillStyle = glowGrad;
            ctx.fillRect(leftX - borderWidth, bottomY - 30, worldSize + borderWidth * 2, 50);
        }
        
        // Corner warning signs
        const corners = [
            { x: leftX, y: topY },
            { x: rightX, y: topY },
            { x: leftX, y: bottomY },
            { x: rightX, y: bottomY }
        ];
        
        for (const corner of corners) {
            if (corner.x > -50 && corner.x < ctx.canvas.width + 50 &&
                corner.y > -50 && corner.y < ctx.canvas.height + 50) {
                ctx.fillStyle = '#FF4500';
                ctx.beginPath();
                ctx.arc(corner.x, corner.y, 15, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 16px PixelAE, Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('âš ', corner.x, corner.y);
            }
        }
        
        ctx.restore();
    }
}

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.audio = new Audio();
        this.particles = new Particles();
        this.assets = new AssetLoader();
        this.map = new MapSystem();
        
        this.state = 'loading';
        this.charIdx = 0;
        this.charIds = Object.keys(CHARACTERS);
        this.city = 'badaya';
        this.endlessMode = false;
        this.endlessScaling = 1.25; // Enemy power multiplier for endless mode
        
        this.player = null;
        this.enemies = [];
        this.boss = null;
        this.proj = [];
        this.eProj = [];
        this.pickups = [];
        this.items = [];
        this.chests = []; // New chest system
        this.groundBuffs = []; // Ground buff drops
        this.activeBuffs = {}; // Active buff timers
        this.pots = []; // Breakable pots
        this.texts = [];
        this.fx = [];
        this.spriteEffects = [];
        
        this.cam = { x: 0, y: 0 };
        this.shake = 0;
        this.input = { up: false, down: false, left: false, right: false, joy: null };
        
        this.spawnT = 0; this.time = 0;
        this.bossSpawned = false; this.bossWarnShown = false;
        this.globalSlow = 0;
        this.rerollCount = 0;
        
        this.pendingItem = null;
        
        this.highScore = parseInt(localStorage.getItem('goldBloodHighScore') || '0');
        this.baghdadUnlocked = localStorage.getItem('baghdadUnlocked') === 'true';
        
        // Cached tile image
        this.sandTilePattern = null;
        
        this.lastTime = 0;
        this.init();
    }
    
    async init() {
        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.setupInput();
        
        // Show loading screen
        this.drawLoading();
        
        // Load assets
        await this.assets.loadAll();
        
        // Create sand tile pattern if loaded
        if (this.assets.get('sand_tile')) {
            this.sandTilePattern = this.ctx.createPattern(this.assets.get('sand_tile'), 'repeat');
        }
        
        this.state = 'menu';
        this.setupMenu();
        requestAnimationFrame(t => this.loop(t));
    }
    
    drawLoading() {
        const ctx = this.ctx;
        const cx = this.canvas.width / 2, cy = this.canvas.height / 2;
        const time = Date.now() / 1000;
        
        // Dark gradient background
        const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, Math.max(this.canvas.width, this.canvas.height));
        gradient.addColorStop(0, '#1a1a2e');
        gradient.addColorStop(1, '#0a0a0f');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Animated particles in background
        for (let i = 0; i < 20; i++) {
            const angle = (time * 0.5 + i * 0.3) % (Math.PI * 2);
            const dist = 80 + Math.sin(time * 2 + i) * 20;
            const x = cx + Math.cos(angle) * dist;
            const y = cy + Math.sin(angle) * dist;
            ctx.fillStyle = `rgba(255, 215, 0, ${0.3 + Math.sin(time * 3 + i) * 0.2})`;
            ctx.beginPath();
            ctx.arc(x, y, 3, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Game title
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 32px PixelAE, Cairo';
        ctx.textAlign = 'center';
        ctx.fillText('Ø°Ù‡Ø¨ Ø£ØµÙØ± Ø£Ùˆ Ø¯Ù… Ø£Ø­Ù…Ø±', cx, cy - 60);
        
        // Loading text with animation
        const dots = '.'.repeat(Math.floor(time * 2) % 4);
        ctx.fillStyle = '#ffffff';
        ctx.font = '20px PixelAE, Cairo';
        ctx.fillText('Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù„Ø¹Ø¨Ø©' + dots, cx, cy);
        
        // Loading bar
        const barWidth = 200, barHeight = 8;
        const progress = (Math.sin(time * 3) + 1) / 2; // Animated progress
        
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(cx - barWidth / 2, cy + 30, barWidth, barHeight);
        
        const loadGradient = ctx.createLinearGradient(cx - barWidth / 2, 0, cx + barWidth / 2, 0);
        loadGradient.addColorStop(0, '#ff8c00');
        loadGradient.addColorStop(0.5, '#ffd700');
        loadGradient.addColorStop(1, '#ff8c00');
        ctx.fillStyle = loadGradient;
        ctx.fillRect(cx - barWidth / 2, cy + 30, barWidth * progress, barHeight);
        
        ctx.strokeStyle = 'rgba(255, 215, 0, 0.5)';
        ctx.lineWidth = 1;
        ctx.strokeRect(cx - barWidth / 2, cy + 30, barWidth, barHeight);
        
        // Sub text
        ctx.fillStyle = '#666';
        ctx.font = '14px PixelAE, Cairo';
        ctx.fillText('Loading game assets...', cx, cy + 60);
    }
    
    resize() { this.canvas.width = window.innerWidth; this.canvas.height = window.innerHeight; }
    
    setupMenu() {
        document.getElementById('highScore').textContent = this.highScore;
        if (this.baghdadUnlocked) { document.getElementById('cityBaghdad').classList.remove('locked'); document.getElementById('cityBaghdad').querySelector('.city-locked').style.display = 'none'; }
        this.updateCharDisplay();
        document.getElementById('charPrev').onclick = () => { this.charIdx = (this.charIdx - 1 + this.charIds.length) % this.charIds.length; this.updateCharDisplay(); };
        document.getElementById('charNext').onclick = () => { this.charIdx = (this.charIdx + 1) % this.charIds.length; this.updateCharDisplay(); };
        document.querySelectorAll('.city-card').forEach(card => { card.onclick = () => { if (card.classList.contains('locked')) return; document.querySelectorAll('.city-card').forEach(c => c.classList.remove('selected')); card.classList.add('selected'); this.city = card.dataset.city; }; });
        document.getElementById('startBtn').onclick = () => this.start();
        document.getElementById('restartBtn').onclick = () => this.restart();
        document.getElementById('itemContinueBtn').onclick = () => this.continueFromItem();
        
        // Pause button
        document.getElementById('pauseBtn').onclick = () => this.pause();
        document.getElementById('resumeBtn').onclick = () => this.pause();
        document.getElementById('quitBtn').onclick = () => this.quitToMenu();
        
        // Volume controls
        document.getElementById('musicVolume').oninput = (e) => {
            const vol = e.target.value / 100;
            this.audio.setMusicVolume(vol);
            document.getElementById('musicVolText').textContent = e.target.value + '%';
        };
        document.getElementById('sfxVolume').oninput = (e) => {
            const vol = e.target.value / 100;
            this.audio.setSfxVolume(vol);
            document.getElementById('sfxVolText').textContent = e.target.value + '%';
        };
        
        // Leaderboard buttons
        document.getElementById('leaderboardBtn').onclick = () => this.showLeaderboard();
        document.getElementById('closeLeaderboardBtn').onclick = () => { document.getElementById('leaderboardModal').style.display = 'none'; };
        document.getElementById('submitScoreBtn').onclick = () => this.submitScore();
        document.getElementById('shareScoreBtn').onclick = () => this.shareScore();
    }
    
    shareScore() {
        // Share game link
        const text = `ğŸ† Ø¬Ø±Ø¨ Ù„Ø¹Ø¨Ø© Gold Blood!\n\nhttps://donsinhat.github.io/Game/`;
        if (navigator.share) {
            navigator.share({ title: 'Gold Blood', text, url: 'https://donsinhat.github.io/Game/' }).catch(() => {});
        } else if (navigator.clipboard) {
            navigator.clipboard.writeText(text).then(() => alert('ØªÙ… Ù†Ø³Ø® Ø§Ù„Ø±Ø§Ø¨Ø·!'));
        }
    }
    
    // Supabase Online Leaderboard - Automatic & Global!
    SUPABASE_URL = 'https://kiffjsdbobwiubgdesmr.supabase.co';
    SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtpZmZqc2Rib2J3aXViZ2Rlc21yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjkyNTc2MzMsImV4cCI6MjA4NDgzMzYzM30.KW1LvUorzfy1CMq2N7K4nWo8tlc3eA6-5g4SQYHqrmY';
    
    async fetchLeaderboard() {
        try {
            const response = await fetch(
                `${this.SUPABASE_URL}/rest/v1/leaderboard?select=*&order=kills.desc&limit=100`,
                { headers: { 'apikey': this.SUPABASE_KEY, 'Authorization': `Bearer ${this.SUPABASE_KEY}` } }
            );
            if (response.ok) return await response.json();
        } catch (e) { console.log('Leaderboard fetch error:', e); }
        return [];
    }
    
    async submitScoreOnline(entry) {
        try {
            const response = await fetch(`${this.SUPABASE_URL}/rest/v1/leaderboard`, {
                method: 'POST',
                headers: {
                    'apikey': this.SUPABASE_KEY,
                    'Authorization': `Bearer ${this.SUPABASE_KEY}`,
                    'Content-Type': 'application/json',
                    'Prefer': 'return=representation'
                },
                body: JSON.stringify(entry)
            });
            return response.ok;
        } catch (e) { console.log('Submit error:', e); return false; }
    }
    
    async showLeaderboard() {
        const listEl = document.getElementById('leaderboardList');
        listEl.innerHTML = '<p style="text-align:center;color:#ffd700">â³ Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...</p>';
        document.getElementById('leaderboardModal').style.display = 'flex';
        
        const leaderboard = await this.fetchLeaderboard();
        
        if (leaderboard.length === 0) {
            listEl.innerHTML = '<p style="text-align:center;color:#888">Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø£Ø¨Ø·Ø§Ù„ Ø¨Ø¹Ø¯! ÙƒÙ† Ø£ÙˆÙ„ Ø¨Ø·Ù„! ğŸ†</p>';
        } else {
            listEl.innerHTML = leaderboard.slice(0, 20).map((entry, i) => {
                const medal = i === 0 ? 'ğŸ¥‡' : i === 1 ? 'ğŸ¥ˆ' : i === 2 ? 'ğŸ¥‰' : `${i + 1}.`;
                const bg = i === 0 ? '#ffd70030' : i === 1 ? '#c0c0c030' : i === 2 ? '#cd7f3230' : '#ffffff10';
                const mode = entry.mode === 'endless' ? 'â™¾ï¸' : 'ğŸœï¸';
                // Get character sprite
                const charSprite = this.getCharacterSpriteHTML(entry.character);
                return `<div style="display:flex;align-items:center;padding:8px 12px;background:${bg};border-radius:8px;border:1px solid #333;gap:8px">
                    <span style="color:#ffd700;font-weight:bold;min-width:28px;text-align:center">${medal}</span>
                    ${charSprite}
                    <span style="color:#fff;flex:1;text-align:right;font-size:0.85rem;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">${entry.name}</span>
                    <span style="color:#ff8800;font-weight:bold;font-size:0.85rem;min-width:50px;text-align:right">ğŸ’€${entry.kills}</span>
                    <span style="font-size:0.75rem">${mode}</span>
                </div>`;
            }).join('');
        }
    }
    
    getCharacterSpriteHTML(charName) {
        // Map character names to their sprite asset paths (same as used in game)
        const charSprites = {
            'Ø£Ø¨Ùˆ Ø³Ù„ÙŠÙ…Ø§Ù†': 'assets/characters/elder/elder_1.png',
            'Ø¬ÙŠØ²Ù†': 'assets/characters/Jayzan/idle.png',
            'Ù†ÙˆØ±Ø©': 'assets/characters/water_priestess/water_priestess_1.png',
            'Ø§Ù„Ø§Ø¹Ø±Ø§Ø¨ÙŠ': 'assets/characters/wind_hashashin/wind_hashashin_1.png',
            'Ø§Ù„Ø­ÙˆØ´Ø¨ÙŠ': 'assets/characters/adventurer_01/adventurer_01_00.png',
            'Ù„ÙŠÙ„Ù‰': 'assets/characters/Char_001_Idle.png',
            'Ø³ÙŠØ¯ Ø¨ØµÙ„Ù‡': 'assets/characters/Mr Bassla/Idle.png',
            'Ø³Ø§Ù…ÙˆØ±Ø§ÙŠ Ø§Ù„Ù…Ø¹': 'assets/characters/Samurai/IDLE(1).png'
        };
        
        const spritePath = charSprites[charName];
        if (spritePath) {
            return `<div style="width:32px;height:32px;background:#1a1a2e;border:2px solid #555;border-radius:6px;overflow:hidden;display:flex;align-items:center;justify-content:center;flex-shrink:0">
                <img src="${spritePath}" style="max-width:28px;max-height:28px;object-fit:contain;image-rendering:pixelated;" title="${charName}" onerror="this.style.display='none';this.parentElement.innerHTML='<span style=color:#ffd700;font-size:16px;font-weight:bold>${(charName || '?')[0]}</span>'">
            </div>`;
        }
        // Fallback to first letter
        return `<div style="width:32px;height:32px;background:#1a1a2e;border:2px solid #555;border-radius:6px;display:flex;align-items:center;justify-content:center;color:#ffd700;font-size:16px;font-weight:bold;flex-shrink:0" title="${charName || 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'}">${(charName || '?')[0]}</div>`;
    }
    
    async submitScore() {
        const nameInput = document.getElementById('playerNameInput');
        const name = nameInput.value.trim() || 'Ù…Ø¬Ù‡ÙˆÙ„';
        localStorage.setItem('goldblood_playerName', name);
        
        const nameSection = document.getElementById('nameInputSection');
        nameSection.innerHTML = '<p style="color:#ffd700;text-align:center;font-size:1.1rem">â³ Ø¬Ø§Ø±ÙŠ Ø±ÙØ¹ Ø§Ù„Ù†ØªÙŠØ¬Ø©...</p>';
        
        const entry = {
            name,
            kills: this.player.kills,
            mode: this.endlessMode ? 'endless' : 'normal',
            level: this.player.level,
            character: CHARACTERS[this.player.charId].name
        };
        
        const success = await this.submitScoreOnline(entry);
        
        if (success) {
            const leaderboard = await this.fetchLeaderboard();
            const rank = leaderboard.findIndex(e => e.name === name && e.kills === entry.kills) + 1;
            
            nameSection.innerHTML = `
                <div style="background:#1a3320;padding:20px;border-radius:10px;border:2px solid #4f4;text-align:center">
                    <p style="color:#4f4;font-size:1.3rem;margin-bottom:8px">âœ… ØªÙ… Ø±ÙØ¹ Ù†ØªÙŠØ¬ØªÙƒ!</p>
                    <p style="color:#ffd700;font-size:1.1rem">ğŸ† ØªØ±ØªÙŠØ¨Ùƒ Ø§Ù„Ø¹Ø§Ù„Ù…ÙŠ: #${rank || '?'}</p>
                </div>
            `;
        } else {
            nameSection.innerHTML = `
                <div style="background:#331a1a;padding:20px;border-radius:10px;border:2px solid #f44;text-align:center">
                    <p style="color:#f44;font-size:1.1rem">âŒ ÙØ´Ù„ Ø§Ù„Ø±ÙØ¹</p>
                    <p style="color:#888;font-size:0.9rem">ØªØ­Ù‚Ù‚ Ù…Ù† Ø§ØªØµØ§Ù„Ùƒ Ø¨Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª</p>
                </div>
            `;
        }
    }
    
    updateCharDisplay() {
        const id = this.charIds[this.charIdx], c = CHARACTERS[id];
        document.getElementById('charName').textContent = c.name;
        document.getElementById('charTitle').textContent = c.title;
        document.getElementById('charDesc').textContent = c.desc;
        document.getElementById('charWeapon').innerHTML = `ğŸ—¡ï¸ ${WEAPONS[c.weapon].name}`;
        let html = '';
        c.passiveText.forEach(p => { const neg = p.includes('Ù‚ÙˆØ© Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡'); html += `<div class="char-stat"><span class="char-stat-label">â€¢</span><span class="${neg ? 'char-stat-negative' : 'char-stat-value'}">${p}</span></div>`; });
        document.getElementById('charStats').innerHTML = html;
        
        const canvas = document.getElementById('charPreview'), ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, 120, 120);
        
        // Try to draw sprite
        const spriteInfo = CHAR_SPRITES[id];
        let sprite = null;
        let drawAsFullImage = false;
        
        // Check for sprite type
        if (spriteInfo.type === 'walk_idle') {
            // Use previewSprite for menu if available, otherwise idleSprite
            const spriteKey = spriteInfo.previewSprite || spriteInfo.idleSprite;
            sprite = this.assets && this.assets.get(spriteKey);
            if (sprite) {
                ctx.imageSmoothingEnabled = false;
                // Check if it's a full image (previewSprite) or spritesheet
                if (spriteInfo.previewSprite) {
                    // Full static image for preview
                    const previewScale = spriteInfo.previewScale || 1;
                    const drawW = sprite.width * previewScale;
                    const drawH = sprite.height * previewScale;
                    ctx.drawImage(sprite, (120 - drawW) / 2, (120 - drawH) / 2, drawW, drawH);
                } else if (spriteInfo.frameWidth && spriteInfo.idleFrames) {
                    const frameW = spriteInfo.frameWidth;
                    const frameH = spriteInfo.frameHeight;
                    // Use previewScale if defined, otherwise calculate from target height
                    const previewScale = spriteInfo.previewScale || (100 / frameH);
                    const drawW = frameW * previewScale;
                    const drawH = frameH * previewScale;
                    // Draw first frame
                    ctx.drawImage(sprite, 0, 0, frameW, frameH, (120 - drawW) / 2, (120 - drawH) / 2, drawW, drawH);
                } else {
                    const targetH = 100;
                    const scale = targetH / sprite.height;
                    const drawW = sprite.width * scale;
                    const drawH = sprite.height * scale;
                    ctx.drawImage(sprite, (120 - drawW) / 2, (120 - drawH) / 2, drawW, drawH);
                }
            }
        } else if (spriteInfo.type === 'single' && spriteInfo.sprite) {
            sprite = this.assets && this.assets.get(spriteInfo.sprite);
            if (sprite) {
                ctx.imageSmoothingEnabled = false;
                const targetH = 100;
                const scale = targetH / sprite.height;
                const drawW = sprite.width * scale;
                const drawH = sprite.height * scale;
                ctx.drawImage(sprite, (120 - drawW) / 2, (120 - drawH) / 2, drawW, drawH);
            }
        } else if (spriteInfo.type === 'multiframe' && spriteInfo.frames) {
            sprite = this.assets && this.assets.get(spriteInfo.frames[0]);
            if (sprite) {
                ctx.imageSmoothingEnabled = false;
                const scale = 3;
                const drawW = spriteInfo.frameWidth * scale;
                const drawH = spriteInfo.frameHeight * scale;
                ctx.drawImage(sprite, (120 - drawW) / 2, (120 - drawH) / 2, drawW, drawH);
            }
        } else {
            sprite = this.assets && this.assets.get(spriteInfo.idle);
            if (sprite) {
                ctx.imageSmoothingEnabled = false;
                const scale = 2;
                const drawW = spriteInfo.frameWidth * scale;
                const drawH = spriteInfo.frameHeight * scale;
                ctx.drawImage(
                    sprite,
                    0, 0, spriteInfo.frameWidth, spriteInfo.frameHeight,
                    (120 - drawW) / 2, (120 - drawH) / 2, drawW, drawH
                );
            }
        }
        
        if (!sprite) {
            // Fallback to simple drawing
            const col = c.colors;
            ctx.fillStyle = col.body; ctx.fillRect(42, 42, 36, 45);
            ctx.fillStyle = col.head; ctx.fillRect(45, 18, 30, 14);
            ctx.fillStyle = col.skin; ctx.fillRect(48, 32, 24, 16);
            ctx.fillStyle = '#000'; ctx.fillRect(52, 38, 4, 4); ctx.fillRect(64, 38, 4, 4);
            ctx.fillStyle = col.legs; ctx.fillRect(45, 87, 10, 15); ctx.fillRect(65, 87, 10, 15);
        }
    }
    
    setupInput() {
        window.addEventListener('keydown', e => {
            if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') this.input.up = true;
            if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') this.input.down = true;
            if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') this.input.left = true;
            if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') this.input.right = true;
            if ((e.key === 'Escape' || e.key === 'p') && this.state === 'playing') this.pause();
        });
        window.addEventListener('keyup', e => {
            if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') this.input.up = false;
            if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') this.input.down = false;
            if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') this.input.left = false;
            if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') this.input.right = false;
        });
        let touchStart = null;
        this.canvas.addEventListener('touchstart', e => { 
            if (this.state !== 'playing') return; 
            e.preventDefault(); 
            touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY }; 
            this.input.joy = { x: 0, y: 0 };
        }, { passive: false });
        this.canvas.addEventListener('touchmove', e => { if (this.state !== 'playing' || !touchStart) return; e.preventDefault(); const dx = e.touches[0].clientX - touchStart.x, dy = e.touches[0].clientY - touchStart.y; const d = Math.min(Math.hypot(dx, dy), 60), a = Math.atan2(dy, dx); this.input.joy = { x: Math.cos(a) * d / 60, y: Math.sin(a) * d / 60 }; }, { passive: false });
        this.canvas.addEventListener('touchend', () => { touchStart = null; this.input.joy = null; });
    }
    
    setupSlots() {
        const ws = document.getElementById('weaponSlots'), bs = document.getElementById('bookSlots');
        ws.innerHTML = ''; bs.innerHTML = '';
        for (let i = 0; i < CONFIG.MAX_WEAPONS; i++) ws.innerHTML += `<div class="equipment-slot" id="ws${i}"></div>`;
        for (let i = 0; i < CONFIG.MAX_BOOKS; i++) bs.innerHTML += `<div class="equipment-slot" id="bs${i}"></div>`;
    }
    
    updateSlots() {
        for (let i = 0; i < CONFIG.MAX_WEAPONS; i++) {
            const slot = document.getElementById(`ws${i}`);
            if (this.player.weapons[i]) { 
                const w = this.player.weapons[i];
                const data = WEAPONS[w.id];
                let iconHtml = `<span style="font-size:1.1rem">${data.icon}</span>`;
                // Use icon sprite if available
                if (data.iconSprite) {
                    const iconImg = this.assets.get(data.iconSprite);
                    if (iconImg) {
                        iconHtml = `<img src="${iconImg.src}" style="width:24px;height:24px;object-fit:contain;image-rendering:pixelated;">`;
                    }
                }
                slot.innerHTML = `${iconHtml}<span class="slot-level">${w.level}</span>`; 
                slot.style.borderColor = w.upgrades.length > 0 ? w.upgrades[w.upgrades.length - 1].rarity.color : '#444'; 
            }
            else slot.innerHTML = '';
        }
        for (let i = 0; i < CONFIG.MAX_BOOKS; i++) {
            const slot = document.getElementById(`bs${i}`);
            if (this.player.books[i]) { const b = this.player.books[i]; slot.innerHTML = `<span style="font-size:1.1rem">${BOOKS[b.id].icon}</span><span class="slot-level">${b.level}</span>`; slot.style.borderColor = b.upgrades.length > 0 ? b.upgrades[b.upgrades.length - 1].rarity.color : '#444'; }
            else slot.innerHTML = '';
        }
    }
    
    start() {
        this.audio.init();
        this.audio.startBGM(); // Start background music
        this.state = 'playing';
        document.getElementById('mainMenu').style.display = 'none';
        document.getElementById('hud').style.display = 'flex';
        document.getElementById('equipmentSlots').style.display = 'flex';
        document.getElementById('miniMap').style.display = 'block';
        document.getElementById('pauseBtn').style.display = 'block';
        document.getElementById('pauseBtn').textContent = 'â¸ï¸';
        
        // Check if endless mode
        this.endlessMode = (this.city === 'endless');
        if (this.endlessMode) {
            this.city = 'badaya'; // Use badaya map for endless
            document.getElementById('endlessIndicator').style.display = 'flex';
        } else {
            document.getElementById('endlessIndicator').style.display = 'none';
        }
        
        // Generate map with buildings and obstacles
        this.map.generate(CONFIG.WORLD_SIZE);
        
        this.player = new Player(0, 0, this.charIds[this.charIdx]);
        this.enemies = []; this.boss = null; this.proj = []; this.eProj = []; this.pickups = []; this.items = []; this.texts = []; this.fx = []; this.spriteEffects = [];
        this.particles.list = []; this.particles.stains = [];
        this.groundBuffs = []; this.activeBuffs = {};
        this.time = 0; this.spawnT = 0; this.bossSpawned = false; this.bossWarnShown = false;
        
        // Endless mode boss tracking
        this.endlessBossPhase = 0; // 0 = no boss yet, 1 = phase 1 killed, 2 = phase 2 killed, 3 = phase 3 killed
        this.endlessBossActive = false;
        
        // Spawn chests randomly on map
        ChestManager.reset();
        this.chests = ChestManager.spawnChests(CONFIG.WORLD_SIZE);
        
        // Spawn breakable pots on map
        this.pots = PotManager.spawnPots(CONFIG.WORLD_SIZE);
        
        // Set character avatar in HUD - draw actual sprite
        this.drawHudAvatar();
        
        this.setupSlots(); this.updateSlots();
    }
    
    restart() {
        document.getElementById('gameOverScreen').style.display = 'none';
        document.getElementById('mainMenu').style.display = 'flex';
        document.getElementById('hud').style.display = 'none';
        document.getElementById('equipmentSlots').style.display = 'none';
        document.getElementById('pauseBtn').style.display = 'none';
        this.state = 'menu';
        if (this.baghdadUnlocked) { document.getElementById('cityBaghdad').classList.remove('locked'); document.getElementById('cityBaghdad').querySelector('.city-locked').style.display = 'none'; }
    }
    
    pause() {
        if (this.state === 'playing') { 
            this.state = 'paused'; 
            document.getElementById('pauseMenu').style.display = 'flex';
            document.getElementById('pauseBtn').textContent = 'â–¶ï¸';
            this.audio.pauseBGM();
            this.updatePauseStats();
        }
        else if (this.state === 'paused') { 
            this.state = 'playing'; 
            document.getElementById('pauseMenu').style.display = 'none';
            document.getElementById('pauseBtn').textContent = 'â¸ï¸';
            this.audio.resumeBGM();
        }
    }
    
    updatePauseStats() {
        if (!this.player) return;
        const p = this.player;
        const c = CHARACTERS[p.charId];
        
        // Update character name
        document.getElementById('pauseCharName').textContent = c.name;
        
        // Update stats
        document.getElementById('pauseStatHP').textContent = `${Math.round(p.hp)}/${Math.round(p.maxHp)}`;
        document.getElementById('pauseStatDMG').textContent = `${Math.round(p.dmgMult * 100)}%`;
        document.getElementById('pauseStatDEF').textContent = `${Math.round(p.armor)}`;
        document.getElementById('pauseStatLUCK').textContent = `${p.luck.toFixed(1)}`;
        document.getElementById('pauseStatCRIT').textContent = `${Math.round(p.crit * 100)}%`;
        document.getElementById('pauseStatSPD').textContent = `${Math.round(p.speed)}`;
        document.getElementById('pauseStatATKSPD').textContent = `${Math.round(p.atkSpd * 100)}%`;
        document.getElementById('pauseStatGold').textContent = p.gold || 0;
        document.getElementById('pauseStatKills').textContent = p.kills || 0;
        
        // Draw character preview
        const canvas = document.getElementById('pauseCharCanvas');
        if (canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 48, 48);
            ctx.imageSmoothingEnabled = false;
            
            const spriteInfo = CHAR_SPRITES[p.charId];
            if (spriteInfo.type === 'walk_idle' && spriteInfo.idleSprite) {
                const sprite = this.assets.get(spriteInfo.idleSprite);
                if (sprite) {
                    const targetH = 40;
                    const scale = targetH / sprite.height;
                    const drawW = sprite.width * scale;
                    ctx.drawImage(sprite, 4, 4, drawW, 40);
                }
            } else if (spriteInfo.type === 'single' && spriteInfo.sprite) {
                const sprite = this.assets.get(spriteInfo.sprite);
                if (sprite) {
                    const targetH = 40;
                    const scale = targetH / sprite.height;
                    const drawW = sprite.width * scale;
                    ctx.drawImage(sprite, 4, 4, drawW, 40);
                }
            } else if (spriteInfo.type === 'multiframe' && spriteInfo.frames) {
                const sprite = this.assets.get(spriteInfo.frames[0]);
                if (sprite) {
                    ctx.drawImage(sprite, 0, 0, 32, 32, 4, 4, 40, 40);
                }
            } else if (spriteInfo.idle) {
                const sprite = this.assets.get(spriteInfo.idle);
                if (sprite) {
                    ctx.drawImage(sprite, 0, 0, spriteInfo.frameWidth, spriteInfo.frameHeight, 4, 4, 40, 40);
                }
            }
        }
    }
    
    quitToMenu() {
        this.state = 'menu';
        this.audio.stopBGM();
        document.getElementById('pauseMenu').style.display = 'none';
        document.getElementById('pauseBtn').style.display = 'none';
        document.getElementById('hud').style.display = 'none';
        document.getElementById('equipmentSlots').style.display = 'none';
        document.getElementById('miniMap').style.display = 'none';
        document.getElementById('mainMenu').style.display = 'flex';
        if (this.baghdadUnlocked) { 
            document.getElementById('cityBaghdad').classList.remove('locked'); 
            document.getElementById('cityBaghdad').querySelector('.city-locked').style.display = 'none'; 
        }
    }
    
    tryBuyChest() {
        if (!this.nearbyChest || this.nearbyChest.opened) return;
        
        const price = ChestManager.getPrice(this.player.chestDiscount);
        if (this.player.gold >= price) {
            this.player.gold -= price;
            ChestManager.buyChest(); // Increase price for next chest
            this.nearbyChest.opened = true;
            
            // Spawn random item from chest
            this.spawnChestReward(this.nearbyChest.x, this.nearbyChest.y);
            
            // Effects
            this.audio.pickup();
            this.particles.spark(this.nearbyChest.x, this.nearbyChest.y, '#ffd700');
            this.texts.push(new FloatText(this.nearbyChest.x, this.nearbyChest.y - 20, `-${price}ğŸ’°`, '#ff4444'));
            
            this.updateHUD();
        } else {
            // Not enough gold
            this.texts.push(new FloatText(this.player.x, this.player.y - 30, 'Ù…Ø§ Ø¹Ù†Ø¯Ùƒ ÙÙ„ÙˆØ³!', '#ff4444'));
        }
    }
    
    collectBuff(buff) {
        const data = buff.data;
        this.audio.pickup();
        this.particles.spark(buff.x, buff.y, data.color);
        this.texts.push(new FloatText(buff.x, buff.y - 20, data.name, data.color));
        
        // Apply buff effect
        switch (data.effect) {
            case 'invincible':
                this.activeBuffs.shield = data.duration;
                this.player.invuln = Math.max(this.player.invuln, data.duration);
                break;
                
            case 'freezeTime':
                this.activeBuffs.clock = data.duration;
                this.globalSlow = data.duration;
                // Freeze all enemies
                for (const e of this.enemies) {
                    e.slow = 0.1;
                    e.slowT = data.duration;
                }
                break;
                
            case 'doubleGold':
                this.activeBuffs.goldBonus = data.duration;
                break;
                
            case 'rage':
                this.activeBuffs.rage = data.duration;
                this.player.hasRage = true;
                this.player.atkSpd *= 1.3; // +30% attack speed during rage
                break;
                
            case 'magnetPull':
                // Gradual pull: set magnet effect on all pickups
                for (const p of this.pickups) {
                    p.magnetPull = true; // Flag for gradual pull
                    p.magnetSpeed = 800 + Math.random() * 400; // Fast pull speed
                }
                // Also pull items
                for (const item of this.items) {
                    item.magnetPull = true;
                    item.magnetSpeed = 600 + Math.random() * 300;
                }
                this.texts.push(new FloatText(this.player.x, this.player.y - 40, 'ğŸ§² Ù…ØºÙ†Ø§Ø·ÙŠØ³!', '#00ff88'));
                break;
                
            case 'nuke':
                // Instant: kill nearby enemies
                const nukeRadius = 300;
                let nukeKills = 0;
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const e = this.enemies[i];
                    if (Math.hypot(e.x - this.player.x, e.y - this.player.y) < nukeRadius) {
                        this.killEnemy(e);
                        this.enemies.splice(i, 1);
                        nukeKills++;
                    }
                }
                // Big explosion effect
                this.particles.emit(this.player.x, this.player.y, 30, { color: '#ff6600', minS: 100, maxS: 300, life: 0.8 });
                this.shake = 0.5;
                this.texts.push(new FloatText(this.player.x, this.player.y - 40, `ğŸ’¥ ${nukeKills} Ù‚ØªÙŠÙ„!`, '#ff6600'));
                break;
        }
    }
    
    removeBuff(buffType) {
        // Buff expired - remove effects if needed
        switch (buffType) {
            case 'rage':
                if (this.player) {
                    this.player.hasRage = false;
                    this.player.atkSpd /= 1.3; // Remove attack speed bonus
                }
                break;
            case 'goldBonus':
                // Double gold ends - no cleanup needed
                break;
        }
    }
    
    // Check if player has active rage buff
    hasRageBuff() {
        return this.activeBuffs.rage && this.activeBuffs.rage > 0;
    }
    
    // Check if player has gold bonus
    hasGoldBuff() {
        return this.activeBuffs.goldBonus && this.activeBuffs.goldBonus > 0;
    }
    
    onEndlessBossKilled() {
        const bossX = this.boss.x;
        const bossY = this.boss.y;
        const phase = this.boss.endlessPhase || 1;
        
        // Big celebration effects
        this.particles.emit(bossX, bossY, 30, { color: '#ffd700', minS: 80, maxS: 200, life: 1 });
        this.particles.emit(bossX, bossY, 20, { color: '#ff6600', minS: 60, maxS: 150, life: 0.8 });
        this.shake = 0.8;
        this.audio.victory();
        
        // Drop rewards based on phase
        const xpReward = 100 * phase;
        const goldReward = 50 * phase;
        
        // Drop XP - fewer but bigger pickups
        const xpPerPickup = Math.ceil(xpReward / 4);
        for (let i = 0; i < 4; i++) {
            this.spawnPickupSmart(
                bossX + (Math.random() - 0.5) * 80,
                bossY + (Math.random() - 0.5) * 80,
                'xp',
                xpPerPickup
            );
        }
        
        // Drop gold
        this.player.gold += goldReward;
        this.texts.push(new FloatText(bossX, bossY - 60, `+${goldReward} ğŸª™`, '#ffd700', 20));
        
        // Spawn a chest at boss location
        this.chests.push(new Chest(bossX, bossY));
        
        // Show victory message
        const phaseNames = ['', 'Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰!', 'Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ©!', 'Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø£Ø®ÙŠØ±Ø©!'];
        this.texts.push(new FloatText(bossX, bossY - 90, `ğŸ‰ ${phaseNames[phase]}`, '#00ff00', 24));
        
        // Clear boss and prepare for next
        this.boss = null;
        this.endlessBossActive = false;
        this.endlessBossPhase++;
        
        // Stop boss music, resume normal
        this.audio.stopBossMusic();
        this.audio.startBGM();
        
        // If all 3 phases complete, show special message
        if (this.endlessBossPhase >= 3) {
            this.texts.push(new FloatText(this.player.x, this.player.y - 50, 'ğŸ‘‘ Ø£Ù†Øª Ø§Ù„Ø¨Ø·Ù„!', '#ffd700', 28));
        }
    }
    
    spawnChestReward(x, y) {
        // Always drop a random item - rarity based on luck
        const itemIds = Object.keys(ITEMS);
        const luck = this.player.luck || 1;
        
        // Calculate rarity chances based on luck
        // Higher luck = better chance for rare items
        const roll = Math.random() * 100;
        let targetRarity;
        
        if (roll < 5 * luck * luck) { // Legendary: 5% * luck^2
            targetRarity = 'LEGENDARY';
        } else if (roll < 20 * luck) { // Rare: 20% * luck
            targetRarity = 'RARE';
        } else {
            targetRarity = 'COMMON';
        }
        
        // Find items of target rarity, fallback to any if none found
        let possibleItems = itemIds.filter(id => ITEMS[id].rarity === targetRarity);
        if (possibleItems.length === 0) {
            possibleItems = itemIds;
        }
        
        const randomItem = possibleItems[Math.floor(Math.random() * possibleItems.length)];
        this.items.push(new ItemDrop(x, y, randomItem));
        this.texts.push(new FloatText(x, y - 30, `${ITEMS[randomItem].name}!`, RARITY[ITEMS[randomItem].rarity].color));
        
        // Always drop gold (guaranteed)
        const goldAmount = 15 + Math.floor(Math.random() * 25);
        this.player.gold += goldAmount;
        this.texts.push(new FloatText(x, y - 50, `+${goldAmount} ğŸª™`, '#ffd700'));
        
        // Drop XP - single consolidated pickup
        const xpAmount = 30 + Math.floor(Math.random() * 30);
        this.spawnPickupSmart(x, y, 'xp', xpAmount);
    }
    
    loop(t) {
        const dt = Math.min((t - this.lastTime) / 1000, 0.07);
        this.lastTime = t;
        if (this.state === 'loading') {
            this.drawLoading();
        } else {
            if (this.state === 'playing') this.update(dt);
            this.draw();
        }
        requestAnimationFrame(t => this.loop(t));
    }
    
    update(dt) {
        this.time += dt;
        
        // Level up cooldown
        if (this.levelUpCooldown && this.levelUpCooldown > 0) {
            this.levelUpCooldown -= dt;
        }
        
        // Boss spawning
        if (this.endlessMode) {
            // Endless mode: Boss spawns at 5min (phase1), 10min (phase2), 15min (phase3)
            const bossSchedule = [
                { time: 300, phase: 1, hp: 1500, atk: 12, name: 'Ø§Ø¨Ùˆ Ø­Ù„Ø²Ù‡ Ø§Ù„ØµØºÙŠØ±' },   // 5 min - challenging
                { time: 600, phase: 2, hp: 4000, atk: 20, name: 'Ø§Ø¨Ùˆ Ø­Ù„Ø²Ù‡' },          // 10 min - hard
                { time: 900, phase: 3, hp: 10000, atk: 35, name: 'Ø§Ø¨Ùˆ Ø­Ù„Ø²Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…' }   // 15 min - very hard
            ];
            
            const nextBoss = bossSchedule[this.endlessBossPhase];
            
            if (nextBoss && !this.endlessBossActive && !this.boss) {
                // Show warning 30 seconds before
                if (this.time >= nextBoss.time - 30 && !this.bossWarnShown) {
                    this.bossWarnShown = true;
                    document.getElementById('bossWarning').style.display = 'block';
                    this.audio.bossWarn();
                    setTimeout(() => document.getElementById('bossWarning').style.display = 'none', 2500);
                }
                
                // Spawn boss
                if (this.time >= nextBoss.time) {
                    this.endlessBossActive = true;
                    this.bossWarnShown = false;
                    const a = Math.random() * Math.PI * 2;
                    this.boss = new Boss(this.player.x + Math.cos(a) * 320, this.player.y + Math.sin(a) * 320, this.player.enemyBuff);
                    // Override boss stats for endless mode
                    this.boss.hp = nextBoss.hp;
                    this.boss.maxHp = nextBoss.hp;
                    this.boss.atk = nextBoss.atk;
                    this.boss.phase = nextBoss.phase;
                    this.boss.endlessPhase = nextBoss.phase;
                    this.boss.name = nextBoss.name;
                    this.audio.startBossMusic();
                }
            }
        } else {
            // Normal mode: Single boss at BOSS_TIME
            if (this.time >= CONFIG.BOSS_TIME - 30 && !this.bossWarnShown) {
                this.bossWarnShown = true;
                document.getElementById('bossWarning').style.display = 'block';
                this.audio.bossWarn();
                setTimeout(() => document.getElementById('bossWarning').style.display = 'none', 2500);
            }
            
            if (this.time >= CONFIG.BOSS_TIME && !this.bossSpawned) {
                this.bossSpawned = true;
                const a = Math.random() * Math.PI * 2;
                this.boss = new Boss(this.player.x + Math.cos(a) * 320, this.player.y + Math.sin(a) * 320, this.player.enemyBuff);
                // Start boss music
                this.audio.startBossMusic();
            }
        }
        
        if (this.globalSlow > 0) this.globalSlow -= dt;
        this.player.update(dt, this.input, this);
        
        this.cam.x = this.player.x - this.canvas.width / 2;
        this.cam.y = this.player.y - this.canvas.height / 2;
        if (this.shake > 0) { this.shake -= dt; this.cam.x += (Math.random() - 0.5) * 6; this.cam.y += (Math.random() - 0.5) * 6; }
        
        // ===== "Ø§Ù„Ù‚Ù„Ù‡ÙŠ" WAVE SYSTEM - Hard waves every 3 minutes =====
        if (this.lastGalhiWave === undefined) this.lastGalhiWave = 0;
        if (this.galhiWaveTimer === undefined) this.galhiWaveTimer = 0;
        if (this.galhiWarningShown === undefined) this.galhiWarningShown = false;
        
        const waveInterval = 180; // Every 3 minutes
        const currentWaveNum = Math.floor(this.time / waveInterval);
        
        // Check if we should trigger a new wave
        if (currentWaveNum > this.lastGalhiWave && this.time >= waveInterval) {
            // Show warning
            if (!this.galhiWarningShown) {
                this.galhiWarningShown = true;
                this.galhiWaveTimer = 2.0; // 2 second delay before spawning
                this.showGalhiWarning(currentWaveNum);
            }
            
            // Countdown and spawn
            if (this.galhiWaveTimer > 0) {
                this.galhiWaveTimer -= dt;
                if (this.galhiWaveTimer <= 0) {
                    this.spawnGalhiWave(currentWaveNum);
                    this.lastGalhiWave = currentWaveNum;
                    this.galhiWarningShown = false;
                    this.hideGalhiWarning();
                }
            }
        }
        
        // Spawn enemies
        // In endless mode, spawn continuously. In normal mode, stop when boss spawns
        // Don't spawn during boss fight in endless mode
        const canSpawnEnemies = this.endlessMode ? !this.endlessBossActive : !this.bossSpawned;
        
        if (canSpawnEnemies || this.endlessMode) {
            this.spawnT -= dt;
            
            // Base spawn multiplier from curse (more enemies with curse)
            let spawnMult = 1 + this.player.curse * 0.5 + this.player.extraEnemySpawn;
            
            // Time-based scaling: more enemies over time
            const timeScale = 1 + (this.time / 60) * 0.08; // +8% per minute
            spawnMult *= timeScale;
            
            // Endless mode: additional scaling
            if (this.endlessMode) {
                const endlessMult = 1 + (this.player.level * 0.03) + (this.time / 300 * 0.15); // +3% per level, +15% per 5min
                spawnMult *= Math.min(endlessMult, 3.0); // Cap at 3x
            }
            
            let rate = 1.2 / spawnMult;
            
            // Reduce spawn rate by 60% after 480s (only in normal mode)
            if (this.time >= 480 && !this.endlessMode) {
                rate *= 2.5;
            }
            
            const maxE = Math.floor((55 + this.player.curse * 12) * spawnMult);
            if (this.spawnT <= 0 && this.enemies.length < maxE) { this.spawnEnemy(); this.spawnT = rate / (1 + this.time / 100); }
        }
        
        const eDt = this.globalSlow > 0 ? dt * 0.5 : dt;
        for (const e of this.enemies) {
            e.update(eDt, this.player, this.enemies, this);
            if (Math.hypot(e.x - this.player.x, e.y - this.player.y) < (e.width + this.player.width) / 2) this.player.takeDmg(e.atk, this);
            
            // Aura/orbit/melee dmg
            for (const w of this.player.weapons) {
                const data = WEAPONS[w.id], range = this.player.getRange(w);
                if (data.type === 'orbit') {
                    // Orbit damage: only hits if enemy touches an actual orbiting object
                    const orbitPositions = this.player.orbitPositions && this.player.orbitPositions[w.id];
                    if (orbitPositions) {
                        const orbitHitRadius = 20; // Size of each orbiting object hitbox
                        for (const pos of orbitPositions) {
                            if (pos && Math.hypot(e.x - pos.x, e.y - pos.y) < orbitHitRadius + e.width / 2) {
                                const dmg = this.player.getDmg(w) * 1.3;
                                const hit = this.player.applyCrit(dmg);
                                if (e.takeDmg(hit.dmg, this, hit.isCrit)) this.killEnemy(e);
                                break; // Only hit once per frame
                            }
                        }
                    }
                } else if (data.type === 'aura') {
                    // Aura damage: only when animation cycles (frame 0)
                    if (this.player.auraDamageFrame && this.player.auraDamageFrame[w.id]) {
                        if (Math.hypot(e.x - this.player.x, e.y - this.player.y) < range + e.width / 2) {
                            const dmg = this.player.getDmg(w);
                            const hit = this.player.applyCrit(dmg);
                            if (e.takeDmg(hit.dmg, this, hit.isCrit)) this.killEnemy(e);
                        }
                    }
                } else if (data.type === 'melee') {
                    const dist = Math.hypot(e.x - this.player.x, e.y - this.player.y);
                    const ang = Math.atan2(e.y - this.player.y, e.x - this.player.x);
                    const pAng = this.player.facing > 0 ? 0 : Math.PI;
                    const weaponOffset = data.offset || 0;
                    // Hitbox: from offset distance to range, in front arc
                    const minDist = weaponOffset > 0 ? weaponOffset * 0.5 : 0;
                    if (dist >= minDist && dist < range + e.width / 2 && Math.abs(ang - pAng) < Math.PI / 2) {
                        const timer = this.player.wTimers[w.id] || 0, cd = this.player.getCD(w);
                        if (timer > cd * 0.82 && timer < cd * 0.95) { 
                            const hit = this.player.applyCrit(this.player.getDmg(w));
                            if (e.takeDmg(hit.dmg, this, hit.isCrit)) this.killEnemy(e); 
                        }
                    }
                } else if (data.type === 'cone_aoe') {
                    // Cone AOE: continuous damage toward nearest enemy with spread
                    const dist = Math.hypot(e.x - this.player.x, e.y - this.player.y);
                    const ang = Math.atan2(e.y - this.player.y, e.x - this.player.x);
                    const targetAng = this.player.coneTargetAngle || 0;
                    const offset = data.offset || 40;
                    const spreadAngle = Math.PI / 3; // Total spread coverage
                    
                    // Check if enemy is in spread cone area
                    let angleDiff = Math.abs(ang - targetAng);
                    if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
                    
                    if (dist < range + offset + e.width / 2 && angleDiff < spreadAngle) {
                        // Continuous damage per second (scaled by dt)
                        const dotDmg = (data.dotDmg || 10) * dt;
                        const hit = this.player.applyCrit(dotDmg * this.player.dmgMult);
                        if (e.takeDmg(hit.dmg, this, hit.isCrit)) this.killEnemy(e);
                    }
                }
            }
        }
        this.enemies = this.enemies.filter(e => e.hp > 0);
        
        // Weapon damage to pots (orbit, aura, melee)
        for (const pot of this.pots) {
            if (pot.broken) continue;
            
            for (const w of this.player.weapons) {
                const data = WEAPONS[w.id];
                const range = this.player.getRange(w);
                
                if (data.type === 'orbit') {
                    const orbitPositions = this.player.orbitPositions && this.player.orbitPositions[w.id];
                    if (orbitPositions) {
                        for (const pos of orbitPositions) {
                            if (pos && pot.isInRange(pos.x, pos.y, 20)) {
                                pot.takeDamage(1, this);
                                break;
                            }
                        }
                    }
                } else if (data.type === 'aura') {
                    if (this.player.auraDamageFrame && this.player.auraDamageFrame[w.id]) {
                        if (pot.isInRange(this.player.x, this.player.y, range)) {
                            pot.takeDamage(1, this);
                        }
                    }
                } else if (data.type === 'melee') {
                    const dist = Math.hypot(pot.x - this.player.x, pot.y - this.player.y);
                    const ang = Math.atan2(pot.y - this.player.y, pot.x - this.player.x);
                    const pAng = this.player.facing > 0 ? 0 : Math.PI;
                    const weaponOffset = data.offset || 0;
                    const minDist = weaponOffset > 0 ? weaponOffset * 0.5 : 0;
                    if (dist >= minDist && dist < range && Math.abs(ang - pAng) < Math.PI / 2) {
                        const timer = this.player.wTimers[w.id] || 0, cd = this.player.getCD(w);
                        if (timer > cd * 0.82 && timer < cd * 0.95) {
                            pot.takeDamage(1, this);
                        }
                    }
                }
            }
        }
        
        // Boss
        if (this.boss) {
            this.boss.update(dt, this.player, this);
            if (Math.hypot(this.boss.x - this.player.x, this.boss.y - this.player.y) < (this.boss.width + this.player.width) / 2) this.player.takeDmg(this.boss.atk, this);
            for (const w of this.player.weapons) {
                const data = WEAPONS[w.id];
                if (data.type === 'orbit') {
                    // Orbit damage: only hits if boss touches an actual orbiting object
                    const orbitPositions = this.player.orbitPositions && this.player.orbitPositions[w.id];
                    if (orbitPositions) {
                        const orbitHitRadius = 20;
                        for (const pos of orbitPositions) {
                            if (pos && Math.hypot(this.boss.x - pos.x, this.boss.y - pos.y) < orbitHitRadius + this.boss.width / 2) {
                                const dmg = this.player.getDmg(w);
                                const hit = this.player.applyCrit(dmg);
                                this.boss.takeDmg(hit.dmg, this, hit.isCrit);
                                break;
                            }
                        }
                    }
                } else if (data.type === 'aura') {
                    // Aura damage: only when animation cycles
                    if (this.player.auraDamageFrame && this.player.auraDamageFrame[w.id]) {
                        if (Math.hypot(this.boss.x - this.player.x, this.boss.y - this.player.y) < this.player.getRange(w) + this.boss.width / 2) {
                            const dmg = this.player.getDmg(w);
                            const hit = this.player.applyCrit(dmg);
                            this.boss.takeDmg(hit.dmg, this, hit.isCrit);
                        }
                    }
                } else if (data.type === 'cone_aoe') {
                    // Cone AOE damage to boss
                    const dist = Math.hypot(this.boss.x - this.player.x, this.boss.y - this.player.y);
                    const ang = Math.atan2(this.boss.y - this.player.y, this.boss.x - this.player.x);
                    const targetAng = this.player.coneTargetAngle || 0;
                    const range = this.player.getRange(w);
                    const offset = data.offset || 40;
                    const spreadAngle = Math.PI / 3;
                    
                    let angleDiff = Math.abs(ang - targetAng);
                    if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
                    
                    if (dist < range + offset + this.boss.width / 2 && angleDiff < spreadAngle) {
                        const dotDmg = (data.dotDmg || 10) * dt;
                        const hit = this.player.applyCrit(dotDmg * this.player.dmgMult);
                        this.boss.takeDmg(hit.dmg, this, hit.isCrit);
                    }
                }
            }
            if (this.boss.hp <= 0) {
                if (this.endlessMode) {
                    // Endless mode: Drop rewards and prepare for next boss
                    this.onEndlessBossKilled();
                } else {
                    // Normal mode: Game over (victory)
                    this.over(true);
                }
            }
        }
        
        // Projectiles
        for (let i = this.proj.length - 1; i >= 0; i--) {
            const p = this.proj[i];
            p.x += p.vx * dt; p.y += p.vy * dt; p.life -= dt;
            
            // Update animation frame for bounce projectiles
            if (p.type === 'bounce' && p.frames) {
                p.frameTime = (p.frameTime || 0) + dt;
                if (p.frameTime > 1 / (p.fps || 8)) {
                    p.frameTime = 0;
                    p.currentFrame = ((p.currentFrame || 0) + 1) % p.frames;
                }
            }
            
            if (p.life <= 0) { this.proj.splice(i, 1); continue; }
            for (const e of this.enemies) {
                if (Math.hypot(p.x - e.x, p.y - e.y) < p.size + e.width / 2) {
                    // Handle bounce projectiles (shuriken)
                    if (p.type === 'bounce' && p.hitEnemies) {
                        if (p.hitEnemies.has(e)) continue; // Already hit this enemy
                        p.hitEnemies.add(e);
                        
                        const hit = this.player.applyCrit(p.dmg);
                        if (e.takeDmg(hit.dmg, this, hit.isCrit)) this.killEnemy(e);
                        
                        // Show small hit particles only (no large sprite effect)
                        this.particles.emit(e.x, e.y, 8, { color: '#aaf', minS: 20, maxS: 50 });
                        this.particles.spark(e.x, e.y, '#88f');
                        
                        // Bounce to next enemy
                        if (p.bounces > 0) {
                            p.bounces--;
                            p.dmg *= (1 - p.dmgReduce); // Reduce damage
                            
                            // Find next nearest enemy not yet hit
                            const nextTargets = this.enemies.filter(en => 
                                !p.hitEnemies.has(en) && en.hp > 0 && Math.hypot(en.x - e.x, en.y - e.y) < 200
                            );
                            if (nextTargets.length > 0) {
                                const next = nextTargets.reduce((a, b) => 
                                    Math.hypot(a.x - e.x, a.y - e.y) < Math.hypot(b.x - e.x, b.y - e.y) ? a : b
                                );
                                const a = Math.atan2(next.y - p.y, next.x - p.x);
                                p.vx = Math.cos(a) * 350;
                                p.vy = Math.sin(a) * 350;
                                p.life = 2; // Reset life for next bounce
                            } else {
                                this.proj.splice(i, 1);
                            }
                        } else {
                            this.proj.splice(i, 1);
                        }
                        break;
                    }
                    
                    // Normal projectile handling
                    const hit = this.player.applyCrit(p.dmg);
                    if (e.takeDmg(hit.dmg, this, hit.isCrit)) this.killEnemy(e);
                    
                    // Apply poison from player passive
                    if (this.player.poison > 0 && Math.random() < this.player.poison) {
                        if (!e.dots) e.dots = [];
                        e.dots.push({ dmg: 3, dur: 3, type: 'poison' }); // 3 damage/sec for 3 sec
                        this.texts.push(new FloatText(e.x, e.y - 25, 'ğŸ¤¢', '#00ff00', 12));
                    }
                    
                    // Apply DOT if projectile has it
                    if (p.dotDmg && p.dotDur && !e.dots) e.dots = [];
                    if (p.dotDmg && p.dotDur && e.dots) {
                        e.dots.push({ dmg: p.dotDmg, dur: p.dotDur });
                        // Show hit effect animation (50% smaller for onion)
                        if (p.hitEffect && p.hitFrameW) {
                            this.spriteEffects.push(new SpriteEffect(e.x, e.y, p.hitEffect, p.hitFrameW, p.hitFrameH, p.hitFrames, 0.4, 0.75));
                        } else {
                            this.particles.emit(e.x, e.y, 3, { color: '#9f9', minS: 20, maxS: 40 });
                        }
                    }
                    p.pierce = (p.pierce || 1) - 1;
                    if (p.pierce <= 0) this.proj.splice(i, 1);
                    break;
                }
            }
            if (this.boss && Math.hypot(p.x - this.boss.x, p.y - this.boss.y) < p.size + this.boss.width / 2) { 
                const hit = this.player.applyCrit(p.dmg);
                this.boss.takeDmg(hit.dmg, this, hit.isCrit); 
                this.proj.splice(i, 1); 
            }
            
            // Check projectile hitting pots
            for (const pot of this.pots) {
                if (!pot.broken && pot.isInRange(p.x, p.y, p.size)) {
                    pot.takeDamage(1, this);
                    p.pierce = (p.pierce || 1) - 1;
                    if (p.pierce <= 0) {
                        this.proj.splice(i, 1);
                        break;
                    }
                }
            }
        }
        
        // Process DOT effects on enemies
        for (const e of this.enemies) {
            if (e.dots && e.dots.length > 0) {
                for (let i = e.dots.length - 1; i >= 0; i--) {
                    const dot = e.dots[i];
                    if (e.takeDmg(dot.dmg * dt, this, false)) this.killEnemy(e);
                    dot.dur -= dt;
                    if (dot.dur <= 0) e.dots.splice(i, 1);
                }
            }
        }
        
        // Enemy projectiles
        for (let i = this.eProj.length - 1; i >= 0; i--) {
            const p = this.eProj[i];
            p.x += p.vx * dt; p.y += p.vy * dt; p.life -= dt;
            if (p.life <= 0) { this.eProj.splice(i, 1); continue; }
            if (Math.hypot(p.x - this.player.x, p.y - this.player.y) < p.size + this.player.width / 2) { this.player.takeDmg(p.dmg, this); this.eProj.splice(i, 1); }
        }
        
        // Effects
        for (let i = this.fx.length - 1; i >= 0; i--) {
            const f = this.fx[i];
            if (f.type === 'lightning' || f.type === 'chain') { f.life -= dt; if (f.life <= 0) this.fx.splice(i, 1); }
            else if (f.type === 'meteor') {
                if (f.delay > 0) { f.delay -= dt; continue; }
                f.life -= dt;
                if (f.life <= 0.35 && !f.hit) { 
                    f.hit = true; 
                    this.particles.emit(f.x, f.y, 10, { color: '#ff4500', minS: 50, maxS: 140 }); 
                    for (const e of this.enemies) { 
                        if (Math.hypot(f.x - e.x, f.y - e.y) < f.radius) { 
                            const hit = this.player.applyCrit(f.dmg);
                            if (e.takeDmg(hit.dmg, this, hit.isCrit)) this.killEnemy(e); 
                        } 
                    } 
                }
                if (f.life <= 0) this.fx.splice(i, 1);
            }
            else if (f.type === 'tornado') {
                f.x += f.vx * dt; f.y += f.vy * dt; f.life -= dt;
                for (const e of this.enemies) { 
                    if (Math.hypot(f.x - e.x, f.y - e.y) < f.radius + e.width / 2) { 
                        // Tornado DOT - rare crit
                        const hit = Math.random() < dt ? this.player.applyCrit(f.dmg * dt) : { dmg: f.dmg * dt, isCrit: false };
                        e.takeDmg(hit.dmg, this, hit.isCrit); 
                        e.slow = f.slow; 
                        e.slowT = 0.35; 
                    } 
                }
                if (f.life <= 0) this.fx.splice(i, 1);
            }
        }
        
        // Pickups with auto-collect system
        for (let i = this.pickups.length - 1; i >= 0; i--) {
            const p = this.pickups[i];
            p.update(dt);
            const d = Math.hypot(p.x - this.player.x, p.y - this.player.y);
            
            // Auto-collect: old pickups start moving toward player
            if (p.age > PICKUP_CONFIG.AUTO_COLLECT_AGE && d < PICKUP_CONFIG.AUTO_COLLECT_RANGE && !p.magnetPull) {
                p.autoCollecting = true;
                const a = Math.atan2(this.player.y - p.y, this.player.x - p.x);
                // Speed increases the older the pickup is
                const ageBonus = Math.min((p.age - PICKUP_CONFIG.AUTO_COLLECT_AGE) * 50, 200);
                const speed = 150 + ageBonus;
                p.x += Math.cos(a) * speed * dt;
                p.y += Math.sin(a) * speed * dt;
            }
            // Magnet pull - fast gradual movement toward player
            else if (p.magnetPull) {
                const a = Math.atan2(this.player.y - p.y, this.player.x - p.x);
                const speed = p.magnetSpeed || 600;
                p.x += Math.cos(a) * speed * dt;
                p.y += Math.sin(a) * speed * dt;
                // Trail effect
                if (Math.random() < 0.3) {
                    this.particles.emit(p.x, p.y, 1, { color: p.type === 'xp' ? '#44ff44' : '#ffd700', minS: 20, maxS: 40, size: 2, life: 0.2 });
                }
            }
            // Normal pickup range attraction
            else if (d < this.player.pickupRange * 1.8) { 
                const a = Math.atan2(this.player.y - p.y, this.player.x - p.x); 
                const s = 200 * (1 - d / (this.player.pickupRange * 1.8)); 
                p.x += Math.cos(a) * s * dt; 
                p.y += Math.sin(a) * s * dt; 
            }
            
            if (d < this.player.pickupRange) {
                if (p.type === 'xp') { 
                    this.player.xp += p.val * this.player.xpMult * (1 + this.player.curse * 0.4); 
                    // Only check level up if not already in level up screen
                    if (this.state !== 'levelup') this.checkLevelUp(); 
                    // XP pickup effect - no sound for XP/coins
                    this.particles.emit(p.x, p.y, 3, { color: '#44ff44', minS: 30, maxS: 60, size: 2, life: 0.3 });
                } else { 
                    const goldMultiplier = this.hasGoldBuff() ? 2 : 1;
                    this.player.gold += Math.round(p.val * this.player.goldMult * goldMultiplier); 
                    // Gold pickup effect - no sound for XP/coins
                    this.particles.gold(p.x, p.y);
                    if (goldMultiplier > 1) {
                        this.particles.spark(p.x, p.y, '#ffd700');
                    }
                }
                this.pickups.splice(i, 1);
            }
        }
        
        // Periodically consolidate pickups to prevent lag (every 3 seconds)
        if (!this.lastConsolidateTime) this.lastConsolidateTime = 0;
        this.lastConsolidateTime += dt;
        if (this.lastConsolidateTime > 3) {
            this.lastConsolidateTime = 0;
            this.consolidatePickups();
        }
        
        // Item drops - collect all nearby items
        const nearbyItems = [];
        for (let i = this.items.length - 1; i >= 0; i--) {
            const item = this.items[i];
            item.update(dt);
            
            // Magnet pull for items
            if (item.magnetPull) {
                const d = Math.hypot(item.x - this.player.x, item.y - this.player.y);
                const a = Math.atan2(this.player.y - item.y, this.player.x - item.x);
                const speed = item.magnetSpeed || 500;
                item.x += Math.cos(a) * speed * dt;
                item.y += Math.sin(a) * speed * dt;
                // Glow trail
                if (Math.random() < 0.4) {
                    this.particles.emit(item.x, item.y, 1, { color: '#ffd700', minS: 30, maxS: 60, size: 3, life: 0.25 });
                }
            }
            
            if (Math.hypot(item.x - this.player.x, item.y - this.player.y) < 22) {
                nearbyItems.push({ item, index: i });
            }
        }
        // Process all collected items
        if (nearbyItems.length > 0) {
            // Remove all collected items from array (in reverse order to maintain indices)
            nearbyItems.sort((a, b) => b.index - a.index);
            for (const { index } of nearbyItems) {
                this.items.splice(index, 1);
            }
            // Show pickup for first item, directly collect the rest
            this.showItemPickup(nearbyItems[0].item);
            for (let i = 1; i < nearbyItems.length; i++) {
                this.collectItem(nearbyItems[i].item);
            }
        }
        
        // Update chests
        this.nearbyChest = null;
        for (let i = this.chests.length - 1; i >= 0; i--) {
            const chest = this.chests[i];
            chest.update(dt);
            
            // Remove fully opened chests
            if (chest.opened && chest.openAnim > 1) {
                this.chests.splice(i, 1);
                continue;
            }
            
            // Check if player is near an unopened chest
            if (!chest.opened && chest.isNearPlayer(this.player.x, this.player.y, 50)) {
                this.nearbyChest = chest;
                // Auto-buy timer: stand for 1.5 seconds to buy
                chest.nearTimer = (chest.nearTimer || 0) + dt;
                if (chest.nearTimer >= 1.5) {
                    this.tryBuyChest();
                    chest.nearTimer = 0;
                }
            } else {
                chest.nearTimer = 0; // Reset timer when away
            }
        }
        
        // Update ground buffs
        for (let i = this.groundBuffs.length - 1; i >= 0; i--) {
            const buff = this.groundBuffs[i];
            buff.update(dt);
            
            // Remove expired buffs
            if (buff.life <= 0) {
                this.groundBuffs.splice(i, 1);
                continue;
            }
            
            // Collect buff
            if (buff.isNearPlayer(this.player.x, this.player.y)) {
                this.collectBuff(buff);
                this.groundBuffs.splice(i, 1);
            }
        }
        
        // Update active buff timers
        for (const [buffType, timer] of Object.entries(this.activeBuffs)) {
            this.activeBuffs[buffType] -= dt;
            if (this.activeBuffs[buffType] <= 0) {
                delete this.activeBuffs[buffType];
                // Remove buff effect
                this.removeBuff(buffType);
            }
        }
        
        // Update breakable pots
        for (let i = this.pots.length - 1; i >= 0; i--) {
            const pot = this.pots[i];
            pot.update(dt);
            
            // Remove broken pots after animation
            if (pot.broken && pot.breakAnim > 1) {
                this.pots.splice(i, 1);
                continue;
            }
            
            // Break pot by walking over it
            if (!pot.broken && pot.isInRange(this.player.x, this.player.y, this.player.width / 2)) {
                pot.takeDamage(10, this); // Instant break
            }
        }
        
        this.texts = this.texts.filter(t => { t.update(dt); return t.life > 0; });
        this.particles.update(dt);
        
        // Update sprite effects
        this.spriteEffects = this.spriteEffects.filter(e => { e.update(dt); return !e.done; });
        
        this.updateHUD();
        this.updateSlots();
        this.drawMiniMap();
    }
    
    spawnEnemy() {
        // Spawn enemies OUTSIDE the screen, not inside
        // Calculate screen bounds
        const screenW = this.canvas.width / 2 + 80;
        const screenH = this.canvas.height / 2 + 80;
        
        // Random position on the edge of the screen (outside view)
        const side = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
        let x, y;
        
        switch(side) {
            case 0: // Top
                x = this.player.x + (Math.random() - 0.5) * screenW * 2;
                y = this.player.y - screenH - Math.random() * 50;
                break;
            case 1: // Right
                x = this.player.x + screenW + Math.random() * 50;
                y = this.player.y + (Math.random() - 0.5) * screenH * 2;
                break;
            case 2: // Bottom
                x = this.player.x + (Math.random() - 0.5) * screenW * 2;
                y = this.player.y + screenH + Math.random() * 50;
                break;
            case 3: // Left
                x = this.player.x - screenW - Math.random() * 50;
                y = this.player.y + (Math.random() - 0.5) * screenH * 2;
                break;
        }
        
        const avail = Object.entries(ENEMIES).filter(([, e]) => this.time >= e.time);
        const weights = avail.map((_, i) => Math.pow(1.7, i)), total = weights.reduce((s, w) => s + w, 0);
        let r = Math.random() * total, type = avail[0][0];
        for (let i = 0; i < weights.length; i++) { r -= weights[i]; if (r <= 0) { type = avail[i][0]; break; } }
        
        // Enemy strength buff: base + curse effect + endless mode bonus
        // Curse makes enemies stronger (15% per curse level)
        const curseBuff = this.player.curse * 0.15;
        const endlessBuff = this.endlessMode ? 0.25 : 0;
        const buff = this.player.enemyBuff + curseBuff + endlessBuff;
        
        this.enemies.push(new Enemy(x, y, type, this.time, buff));
        
        // Pack enemies spawn together
        if (ENEMIES[type].pack) {
            const packSize = 2 + Math.floor(this.player.curse * 0.5); // More pack members with curse
            for (let i = 0; i < packSize; i++) {
                this.enemies.push(new Enemy(x + (Math.random() - 0.5) * 35, y + (Math.random() - 0.5) * 35, type, this.time, buff));
            }
        }
        
        // Chance to spawn ELITE enemy (increases over time)
        // 2% at minute 0, +1% per minute, max 15%
        const eliteChance = Math.min(0.02 + (this.time / 60) * 0.01, 0.15);
        if (Math.random() < eliteChance) {
            const eliteX = x + (Math.random() - 0.5) * 50;
            const eliteY = y + (Math.random() - 0.5) * 50;
            this.enemies.push(new Enemy(eliteX, eliteY, type, this.time, buff, true)); // true = elite
        }
    }
    
    // ===== Ø§Ù„Ù‚Ù„Ù‡ÙŠ WAVE SYSTEM =====
    showGalhiWarning(waveNum) {
        try {
            const waveNames = ['', 'Ø§Ù„Ù…ÙˆØ¬Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰', 'Ø§Ù„Ù…ÙˆØ¬Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ©', 'Ø§Ù„Ù…ÙˆØ¬Ø© Ø§Ù„Ø«Ø§Ù„Ø«Ø©', 'Ø§Ù„Ù…ÙˆØ¬Ø© Ø§Ù„Ø±Ø§Ø¨Ø¹Ø©', 'Ø§Ù„Ù…ÙˆØ¬Ø© Ø§Ù„Ø®Ø§Ù…Ø³Ø©'];
            const waveName = waveNames[Math.min(waveNum, 5)] || `Ù…ÙˆØ¬Ø© ${waveNum}`;
            
            // Use floating text instead of DOM element
            if (this.texts && this.player) {
                this.texts.push(new FloatText(this.player.x, this.player.y - 80, 'âš ï¸ Ø§Ù„Ù‚Ù„Ù‡ÙŠ Ø¬Ø§ÙŠÙƒ! âš ï¸', '#ff4400', 28));
                this.texts.push(new FloatText(this.player.x, this.player.y - 50, waveName, '#ffd700', 18));
            }
            
            // Screen shake
            this.shake = 1.5;
            
            // Warning sound
            if (this.audio) {
                this.audio.play(150, 0.3, 0.2, 'sawtooth');
            }
            
            // Red flash particles
            if (this.particles && this.player) {
                this.particles.emit(this.player.x, this.player.y, 30, { color: '#ff4400', minS: 100, maxS: 200, size: 5, life: 1.5 });
            }
        } catch (e) {
            console.log('Galhi warning error:', e);
        }
    }
    
    hideGalhiWarning() {
        // No DOM to hide anymore - using floating text
    }
    
    spawnGalhiWave(waveNum) {
        try {
            // Wave intensity scales with wave number (reduced for performance)
            const baseEnemies = 10 + waveNum * 5; // 15, 20, 25, 30...
            const eliteCount = Math.min(1 + Math.floor(waveNum / 2), 3); // 1, 1, 2, 2, 3 (max 3)
            
            const avail = Object.entries(ENEMIES).filter(([, e]) => this.time >= e.time);
            if (avail.length === 0) return;
            
            const screenW = this.canvas.width / 2 + 100;
            
            const curseBuff = this.player.curse * 0.15;
            const endlessBuff = this.endlessMode ? 0.25 : 0;
            const waveBuff = waveNum * 0.1;
            const buff = this.player.enemyBuff + curseBuff + endlessBuff + waveBuff;
            
            // Spawn regular enemies in a circle around player
            for (let i = 0; i < baseEnemies; i++) {
                const angle = (i / baseEnemies) * Math.PI * 2 + Math.random() * 0.5;
                const distance = screenW + Math.random() * 50;
                const x = this.player.x + Math.cos(angle) * distance;
                const y = this.player.y + Math.sin(angle) * distance;
                
                const typeIdx = Math.floor(Math.random() * avail.length);
                const type = avail[typeIdx][0];
                
                this.enemies.push(new Enemy(x, y, type, this.time, buff));
            }
            
            // Spawn elite enemies
            for (let i = 0; i < eliteCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = screenW + Math.random() * 30;
                const x = this.player.x + Math.cos(angle) * distance;
                const y = this.player.y + Math.sin(angle) * distance;
                
                const typeIdx = Math.floor(Math.random() * avail.length);
                const type = avail[typeIdx][0];
                
                this.enemies.push(new Enemy(x, y, type, this.time, buff, true));
            }
            
            // Floating text
            if (this.texts && this.player) {
                this.texts.push(new FloatText(this.player.x, this.player.y - 60, `+${baseEnemies + eliteCount} Ø¹Ø¯Ùˆ!`, '#ff4400', 20));
            }
            
            // Visual effect - particles around screen
            if (this.particles && this.player) {
                for (let i = 0; i < 20; i++) {
                    const angle = (i / 20) * Math.PI * 2;
                    const px = this.player.x + Math.cos(angle) * 300;
                    const py = this.player.y + Math.sin(angle) * 300;
                    this.particles.emit(px, py, 3, { color: '#ff4400', minS: 80, maxS: 150, size: 3, life: 0.8 });
                }
            }
        } catch (e) {
            console.log('Galhi spawn error:', e);
        }
    }
    
    killEnemy(enemy) {
        this.player.kills++;
        this.particles.blood(enemy.x, enemy.y);
        
        // Add death effect with sparks
        this.spriteEffects.push(new SpriteEffect(enemy.x, enemy.y, 'fx_explosion', 32, 32, 7, 0.4, 1.5));
        this.particles.spark(enemy.x, enemy.y, '#ff6600');
        
        // Calculate XP - bonus in endless mode based on time/level for balance
        let xpReward = enemy.xp;
        if (this.endlessMode) {
            const xpMult = 1 + (this.time / 300 * 0.3) + (this.player.level * 0.05); // +30% per 5min, +5% per level
            xpReward = Math.round(enemy.xp * xpMult);
        }
        
        // Add floating kill text
        this.texts.push(new FloatText(enemy.x, enemy.y - 10, '+' + xpReward + ' XP', '#44ff44', 12));
        
        // Clamp pickup positions to map bounds
        const halfWorld = CONFIG.WORLD_SIZE / 2;
        const margin = 30;
        const clampX = Math.max(-halfWorld + margin, Math.min(halfWorld - margin, enemy.x));
        const clampY = Math.max(-halfWorld + margin, Math.min(halfWorld - margin, enemy.y));
        
        // Use smart spawn that consolidates when over limit
        this.spawnPickupSmart(clampX, clampY, 'xp', xpReward);
        
        // Gold drop rate reduced (6% chance), fixed value of 5
        if (Math.random() < 0.06) {
            this.spawnPickupSmart(clampX + (Math.random() - 0.5) * 12, clampY + (Math.random() - 0.5) * 12, 'gold', 5);
            this.particles.gold(clampX, clampY);
        }
        // Item drop rate: 3.5% base (reduced 30% from 5%) * luck multiplier
        if (Math.random() < 0.035 * Math.pow(this.player.luck, 1.5)) this.dropItem(clampX, clampY);
        
        // Buff drop chance - check each buff type
        for (const [buffType, buffData] of Object.entries(BUFF_TYPES)) {
            if (Math.random() < buffData.dropChance * this.player.luck) {
                this.groundBuffs.push(new GroundBuff(clampX + (Math.random() - 0.5) * 20, clampY + (Math.random() - 0.5) * 20, buffType));
                break; // Only one buff per kill
            }
        }
    }
    
    dropItem(x, y) {
        // Clamp position to within world bounds (prevent items outside map)
        const halfWorld = CONFIG.WORLD_SIZE / 2 - 50; // 50px margin from edge
        const clampedX = Math.max(-halfWorld, Math.min(halfWorld, x));
        const clampedY = Math.max(-halfWorld, Math.min(halfWorld, y));
        
        const r = Math.random() * 100 / this.player.luck;
        let rarity = r < 5 ? 'LEGENDARY' : r < 16 ? 'RARE' : 'COMMON';
        const pool = Object.entries(ITEMS).filter(([, i]) => i.rarity === rarity);
        if (pool.length > 0) { 
            const [id] = pool[Math.floor(Math.random() * pool.length)]; 
            this.items.push(new ItemDrop(clampedX, clampedY, id)); 
            this.audio.itemDrop(); // Play item drop sound
        }
    }
    
    // Smart pickup spawning with consolidation to prevent lag
    spawnPickupSmart(x, y, type, val) {
        // If under limit, just spawn normally
        if (this.pickups.length < PICKUP_CONFIG.MAX_PICKUPS) {
            this.pickups.push(new Pickup(x, y, type, val));
            return;
        }
        
        // Over limit - try to consolidate with nearby pickup of same type
        let nearestDist = PICKUP_CONFIG.CONSOLIDATE_RANGE;
        let nearestPickup = null;
        
        for (const p of this.pickups) {
            if (p.type !== type) continue;
            const d = Math.hypot(p.x - x, p.y - y);
            if (d < nearestDist) {
                nearestDist = d;
                nearestPickup = p;
            }
        }
        
        if (nearestPickup) {
            // Merge with existing pickup
            nearestPickup.val += val;
            // Move it slightly toward the new position
            nearestPickup.x = (nearestPickup.x + x) / 2;
            nearestPickup.y = (nearestPickup.y + y) / 2;
        } else {
            // No nearby pickup to merge - find oldest pickup of same type and merge
            let oldestPickup = null;
            let oldestAge = 0;
            
            for (const p of this.pickups) {
                if (p.type === type && p.age > oldestAge) {
                    oldestAge = p.age;
                    oldestPickup = p;
                }
            }
            
            if (oldestPickup) {
                oldestPickup.val += val;
                oldestPickup.x = x;
                oldestPickup.y = y;
                oldestPickup.age = 0; // Reset age
            } else {
                // Fallback - just add it (shouldn't happen often)
                this.pickups.push(new Pickup(x, y, type, val));
            }
        }
    }
    
    // Consolidate distant pickups periodically (call in update)
    consolidatePickups() {
        if (this.pickups.length < PICKUP_CONFIG.MAX_PICKUPS * 0.7) return;
        
        // Find pickups far from player and merge them
        const playerX = this.player.x, playerY = this.player.y;
        const farPickups = { xp: [], gold: [] };
        
        for (const p of this.pickups) {
            const d = Math.hypot(p.x - playerX, p.y - playerY);
            if (d > 400) { // Far from player
                farPickups[p.type]?.push(p);
            }
        }
        
        // Merge far pickups into mega pickups
        for (const type of ['xp', 'gold']) {
            const pList = farPickups[type];
            if (pList.length < 5) continue;
            
            // Sum up values and remove all but one
            let totalVal = 0;
            let avgX = 0, avgY = 0;
            
            for (const p of pList) {
                totalVal += p.val;
                avgX += p.x;
                avgY += p.y;
            }
            avgX /= pList.length;
            avgY /= pList.length;
            
            // Remove all far pickups of this type
            this.pickups = this.pickups.filter(p => !pList.includes(p));
            
            // Add one mega pickup with total value
            this.pickups.push(new Pickup(avgX, avgY, type, totalVal));
        }
    }
    
    showItemPickup(drop) {
        this.state = 'itemPickup';
        this.pendingItem = drop;
        const item = ITEMS[drop.id];
        const rar = RARITY[item.rarity];
        
        // Show sprite image if available, otherwise show emoji
        const iconEl = document.getElementById('itemIcon');
        const sprite = item.sprite && this.assets.get(item.sprite);
        const iconset = this.assets.get('iconset');
        
        if (sprite) {
            iconEl.innerHTML = `<img src="${sprite.src}" style="width: 64px; height: 64px; image-rendering: pixelated;">`;
        } else if (item.iconPos && iconset) {
            // Create canvas to extract icon from sprite sheet
            const canvas = document.createElement('canvas');
            canvas.width = 24;
            canvas.height = 24;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(iconset, item.iconPos.col * 24, item.iconPos.row * 24, 24, 24, 0, 0, 24, 24);
            iconEl.innerHTML = `<img src="${canvas.toDataURL()}" style="width: 64px; height: 64px; image-rendering: pixelated;">`;
        } else {
            iconEl.textContent = item.icon;
        }
        
        document.getElementById('itemName').textContent = item.name;
        document.getElementById('itemName').style.color = rar.color;
        document.getElementById('itemRarity').textContent = rar.name;
        document.getElementById('itemRarity').style.background = rar.color + '30';
        document.getElementById('itemRarity').style.color = rar.color;
        document.getElementById('itemDesc').textContent = item.desc;
        
        document.getElementById('itemPickupModal').style.display = 'flex';
        this.audio.pickup(); // Play item taken sound
    }
    
    continueFromItem() {
        document.getElementById('itemPickupModal').style.display = 'none';
        if (this.pendingItem) {
            this.collectItem(this.pendingItem);
            this.pendingItem = null;
        }
        this.state = 'playing';
    }
    
    collectItem(drop) {
        const item = ITEMS[drop.id];
        switch (item.effect) {
            case 'heal': 
                this.player.hp = Math.min(this.player.maxHp, this.player.hp + item.val); 
                this.texts.push(new FloatText(this.player.x, this.player.y - 18, `+${item.val} HP`, '#0f0')); 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_heal', 24, 24, 6, 0.5, 2));
                this.particles.heal(this.player.x, this.player.y);
                break;
            case 'fullHeal': 
                this.player.maxHp += item.val; 
                this.player.hp = this.player.maxHp; 
                this.texts.push(new FloatText(this.player.x, this.player.y - 18, 'Ø´ÙØ§Ø¡ ÙƒØ§Ù…Ù„!', '#0f0', 16)); 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_heal', 24, 24, 6, 0.6, 2.5));
                this.particles.heal(this.player.x, this.player.y);
                this.particles.heal(this.player.x, this.player.y);
                break;
            case 'gold': 
                this.player.gold += Math.round(item.val * this.player.goldMult); 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_spark', 24, 24, 5, 0.3, 1.5));
                this.particles.gold(this.player.x, this.player.y);
                this.texts.push(new FloatText(this.player.x, this.player.y - 18, `+${item.val} Ø°Ù‡Ø¨`, '#ffd700'));
                break;
            case 'tempSpeed': 
                this.player.tempBuffs.push({ type: 'speed', val: item.val, dur: item.dur }); 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_magic', 24, 24, 5, 0.4, 1.8));
                break;
            case 'tempDmg': 
                this.player.tempBuffs.push({ type: 'dmg', val: item.val, dur: item.dur }); 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_fire_small', 24, 24, 6, 0.4, 1.8));
                break;
            case 'tempAtkSpd': 
                this.player.tempBuffs.push({ type: 'atkSpd', val: item.val, dur: item.dur }); 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_spark', 24, 24, 5, 0.4, 1.8));
                break;
            case 'shield': 
                this.player.shield += item.val; 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_circle', 24, 24, 5, 0.5, 2));
                break;
            case 'slow': 
                this.globalSlow = item.dur; 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_ice', 24, 24, 5, 0.5, 2));
                break;
            case 'revive': 
                this.player.hasRevive = true; 
                this.texts.push(new FloatText(this.player.x, this.player.y - 18, 'Ø¥Ø­ÙŠØ§Ø¡ Ù…Ø­ÙÙˆØ¸!', '#ffd700')); 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_magic', 24, 24, 5, 0.6, 2.5));
                break;
            case 'permGold': 
                this.player.goldMult += item.val; 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_spark', 24, 24, 5, 0.4, 2));
                break;
            case 'permArmor': 
                this.player.armor += item.val; 
                this.texts.push(new FloatText(this.player.x, this.player.y - 18, `+${item.val} Ø¯ÙØ§Ø¹`, '#88f')); 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_circle', 24, 24, 5, 0.4, 2));
                break;
            case 'permSpeed': 
                this.player.speed += this.player.speed * item.val; 
                this.texts.push(new FloatText(this.player.x, this.player.y - 18, `+${Math.round(item.val * 100)}% Ø³Ø±Ø¹Ø©`, '#8f8')); 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_spark', 24, 24, 5, 0.4, 2));
                break;
            case 'permHP': 
                this.player.maxHp += item.val; 
                this.player.hp = Math.min(this.player.hp + item.val, this.player.maxHp);
                this.texts.push(new FloatText(this.player.x, this.player.y - 18, `+${item.val} ØµØ­Ø©`, '#f88')); 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_heal', 24, 24, 6, 0.4, 2));
                break;
            case 'randomEquip': 
                this.giveRandomEquip(); 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_magic', 24, 24, 5, 0.5, 2.5));
                break;
            case 'moreEnemies': 
                this.player.extraEnemySpawn += item.val; 
                this.texts.push(new FloatText(this.player.x, this.player.y - 18, 'Ø£Ø¹Ø¯Ø§Ø¡ Ø£ÙƒØ«Ø±!', '#f44')); 
                break;
            case 'magnetPull':
                // Pull all existing pickups to player instantly
                let pulled = 0;
                for (const p of this.pickups) {
                    p.x = this.player.x + (Math.random() - 0.5) * 30;
                    p.y = this.player.y + (Math.random() - 0.5) * 30;
                    pulled++;
                }
                this.texts.push(new FloatText(this.player.x, this.player.y - 18, `Ø³Ø­Ø¨ ${pulled}!`, '#00ffff', 16)); 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_magic', 24, 24, 5, 0.6, 3));
                this.particles.emit(this.player.x, this.player.y, 15, { color: '#00ffff', minS: 50, maxS: 150, life: 0.5 });
                break;
        }
    }
    
    giveRandomEquip() {
        if (Math.random() < 0.5 && this.player.weapons.length < CONFIG.MAX_WEAPONS) {
            const avail = Object.keys(WEAPONS).filter(w => !this.player.weapons.find(pw => pw.id === w));
            if (avail.length > 0) { const id = avail[Math.floor(Math.random() * avail.length)]; this.player.weapons.push({ id, level: 1, upgrades: [] }); this.texts.push(new FloatText(this.player.x, this.player.y - 30, `${WEAPONS[id].name}!`, '#ffd700', 16)); }
        } else if (this.player.books.length < CONFIG.MAX_BOOKS) {
            const avail = Object.keys(BOOKS).filter(b => !this.player.books.find(pb => pb.id === b));
            if (avail.length > 0) { const id = avail[Math.floor(Math.random() * avail.length)]; this.player.books.push({ id, level: 1, upgrades: [] }); this.applyBook(id, 1, RARITY.COMMON); this.texts.push(new FloatText(this.player.x, this.player.y - 30, `${BOOKS[id].name}!`, '#ffd700', 16)); }
        }
    }
    
    checkLevelUp() {
        // Don't trigger level up if already in level up screen or on cooldown
        if (this.state === 'levelup') return;
        if (this.levelUpCooldown && this.levelUpCooldown > 0) return;
        
        // Easier scaling: lower growth rate, especially after level 10
        const level = this.player.level;
        let req;
        if (level <= 10) {
            req = Math.floor(10 * Math.pow(1.25, level - 1)); // 1.25 instead of 1.35
        } else {
            // After level 10, even slower growth
            req = Math.floor(10 * Math.pow(1.25, 9) * Math.pow(1.15, level - 10));
        }
        if (this.player.xp >= req) { this.player.xp -= req; this.player.level++; this.player.hp = Math.min(this.player.maxHp, this.player.hp + this.player.maxHp * 0.12); this.audio.levelUp(); this.showLevelUp(); }
    }
    
    showLevelUp() {
        this.state = 'levelup';
        const modal = document.getElementById('levelUpModal'), opts = document.getElementById('upgradeOptions');
        
        // Milestone levels (every 5 levels) get EPIC/LEGENDARY guaranteed!
        const isMilestone = this.player.level % 5 === 0;
        
        const choices = [];
        const aw = []; for (const w of this.player.weapons) { if (w.level < CONFIG.MAX_UPGRADE_LEVEL) aw.push({ type: 'weapon', id: w.id, isNew: false }); }
        if (this.player.weapons.length < CONFIG.MAX_WEAPONS) Object.keys(WEAPONS).filter(w => !this.player.weapons.find(pw => pw.id === w)).forEach(w => aw.push({ type: 'weapon', id: w, isNew: true }));
        const ab = []; for (const b of this.player.books) { if (b.level < CONFIG.MAX_UPGRADE_LEVEL) ab.push({ type: 'book', id: b.id, isNew: false }); }
        if (this.player.books.length < CONFIG.MAX_BOOKS) Object.keys(BOOKS).filter(b => !this.player.books.find(pb => pb.id === b)).forEach(b => ab.push({ type: 'book', id: b, isNew: true }));
        const all = [...aw, ...ab];
        while (choices.length < 3 && all.length > 0) choices.push(all.splice(Math.floor(Math.random() * all.length), 1)[0]);
        opts.innerHTML = '';
        
        // Show milestone banner
        if (isMilestone) {
            const banner = document.createElement('div');
            banner.style.cssText = 'width:100%;text-align:center;color:#ffd700;font-size:1rem;margin-bottom:8px;text-shadow:0 0 10px #ffd700;animation:pulse 0.5s ease-in-out infinite alternate';
            banner.innerHTML = `â­ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ ${this.player.level}! ØªØ±Ù‚ÙŠØ§Øª Ù†Ø§Ø¯Ø±Ø©! â­`;
            opts.appendChild(banner);
        }
        
        choices.forEach(c => {
            // Milestone levels get guaranteed EPIC or LEGENDARY
            let rar;
            if (isMilestone) {
                rar = Math.random() < 0.4 ? RARITY.LEGENDARY : RARITY.EPIC;
            } else {
                rar = getRandomRarity(this.player.luck);
            }
            const card = document.createElement('div');
            card.className = 'upgrade-card';
            card.style.borderColor = rar.color;
            card.style.boxShadow = `0 0 12px ${rar.color}35`;
            const data = c.type === 'weapon' ? WEAPONS[c.id] : BOOKS[c.id];
            const lvl = c.isNew ? 0 : (c.type === 'weapon' ? this.player.weapons : this.player.books).find(x => x.id === c.id).level;
            
            // Calculate stat changes for display
            let statChangeText = '';
            
            if (c.type === 'weapon') {
                const w = c.isNew ? null : this.player.weapons.find(x => x.id === c.id);
                let types = ['damage', 'count', 'cooldown'];
                const typeNames = { damage: 'âš”ï¸ Ø¶Ø±Ø±', count: 'ğŸ¯ Ø¹Ø¯Ø¯', cooldown: 'âš¡ Ø³Ø±Ø¹Ø©' };
                
                // If weapon reached max count (5), remove count from upgrade options
                if (!c.isNew && w) {
                    const currentCount = this.player.getProjectileCount(w);
                    if (currentCount >= 5) {
                        types = types.filter(t => t !== 'count');
                    }
                }
                
                const upgradeType = types[Math.floor(Math.random() * types.length)];
                
                if (c.isNew) {
                    // New weapon - show base stats
                    const baseDmg = CONFIG.WEAPON_BASE_DMG;
                    statChangeText = `<div style="font-size:0.55rem;color:#4f4;margin-top:3px">Ø¶Ø±Ø± Ø£Ø³Ø§Ø³ÙŠ: ${baseDmg.toFixed(0)}</div>`;
                } else {
                    // Existing weapon - show upgrade effect with EXPONENTIAL scaling
                    if (upgradeType === 'damage') {
                        // Current damage
                        const currentBaseDmg = CONFIG.WEAPON_BASE_DMG * Math.pow(1.18, w.level - 1);
                        // Next level damage (exponential: +18% per level)
                        const nextBaseDmg = CONFIG.WEAPON_BASE_DMG * Math.pow(1.18, w.level);
                        const percentIncrease = Math.round((nextBaseDmg / currentBaseDmg - 1) * 100);
                        statChangeText = `<div style="font-size:0.55rem;color:#4f4;margin-top:3px">${typeNames[upgradeType]} +${percentIncrease}%</div>
                            <div style="font-size:0.5rem;color:#ff0">${Math.round(currentBaseDmg)} â†’ ${Math.round(nextBaseDmg)}</div>`;
                    } else if (upgradeType === 'count') {
                        const currentCount = this.player.getProjectileCount(w);
                        const newCount = Math.min(currentCount + 1, 5); // +1 per upgrade, max 5
                        statChangeText = `<div style="font-size:0.55rem;color:#4f4;margin-top:3px">${typeNames[upgradeType]} +1</div>
                            <div style="font-size:0.5rem;color:#ff0">${currentCount} â†’ ${newCount}</div>`;
                    } else if (upgradeType === 'cooldown') {
                        const wData = WEAPONS[w.id];
                        const currentCD = this.player.getCD(w);
                        const reduction = 1 - (rar.bonus * 0.06);
                        const newCD = currentCD * reduction;
                        statChangeText = `<div style="font-size:0.55rem;color:#4f4;margin-top:3px">${typeNames[upgradeType]}</div>
                            <div style="font-size:0.5rem;color:#ff0">${currentCD.toFixed(2)}s â†’ ${newCD.toFixed(2)}s</div>`;
                    }
                }
                c.upgradeType = upgradeType;
            } else {
                // Book - show stat change
                const book = BOOKS[c.id];
                const v = book.val * (1 + rar.bonus * 0.12);
                const statNames = {
                    damage: 'Ø¶Ø±Ø±', atkSpd: 'Ø³Ø±Ø¹Ø© Ù‡Ø¬ÙˆÙ…', moveSpd: 'Ø³Ø±Ø¹Ø© Ø­Ø±ÙƒØ©',
                    xp: 'Ø®Ø¨Ø±Ø©', maxHp: 'ØµØ­Ø©', armor: 'Ø¯ÙØ§Ø¹',
                    pickup: 'Ù…ØºÙ†Ø§Ø·ÙŠØ³', luck: 'Ø­Ø¸', curse: 'Ù„Ø¹Ù†Ø©',
                    regen: 'ØªØ¬Ø¯ÙŠØ¯', crit: 'Ø¶Ø±Ø¨Ø© Ø­Ø±Ø¬Ø©'
                };
                
                // Get current and new values
                let currentVal, newVal, unit = '';
                switch (book.stat) {
                    case 'damage': currentVal = this.player.dmgMult * 100; newVal = (this.player.dmgMult + v) * 100; unit = '%'; break;
                    case 'atkSpd': currentVal = this.player.atkSpd * 100; newVal = (this.player.atkSpd + v) * 100; unit = '%'; break;
                    case 'moveSpd': currentVal = this.player.speed; newVal = this.player.speed * (1 + v); unit = ''; break;
                    case 'xp': currentVal = this.player.xpMult * 100; newVal = (this.player.xpMult + v) * 100; unit = '%'; break;
                    case 'maxHp': currentVal = this.player.maxHp; newVal = this.player.maxHp * (1 + v); unit = ''; break;
                    case 'armor': currentVal = this.player.armor; newVal = this.player.armor + v * 6; unit = ''; break;
                    case 'pickup': currentVal = this.player.pickupRange; newVal = this.player.pickupRange * (1 + v); unit = ''; break;
                    case 'luck': currentVal = this.player.luck; newVal = this.player.luck + v; unit = ''; break;
                    case 'curse': currentVal = this.player.curse * 100; newVal = (this.player.curse + v) * 100; unit = '%'; break;
                    case 'regen': currentVal = this.player.regen; newVal = this.player.regen + v; unit = '/s'; break;
                    case 'crit': currentVal = this.player.crit * 100; newVal = (this.player.crit + v) * 100; unit = '%'; break;
                    default: currentVal = 0; newVal = v; unit = '';
                }
                
                statChangeText = `<div style="font-size:0.55rem;color:#4f4;margin-top:3px">${statNames[book.stat] || book.stat}</div>
                    <div style="font-size:0.5rem;color:#ff0">${currentVal.toFixed(1)}${unit} â†’ ${newVal.toFixed(1)}${unit}</div>`;
            }
            
            // Create icon - use sprite if available, otherwise emoji
            let iconHtml = data.icon;
            if (c.type === 'weapon' && data.iconSprite) {
                const iconImg = this.assets.get(data.iconSprite);
                if (iconImg) {
                    iconHtml = `<img src="${iconImg.src}" style="width:36px;height:36px;object-fit:contain;image-rendering:pixelated;">`;
                }
            }
            card.innerHTML = `<div class="upgrade-icon">${iconHtml}</div><div class="upgrade-name" style="color:${rar.color}">${data.name}</div><div class="upgrade-type">${c.type === 'weapon' ? 'Ø³Ù„Ø§Ø­' : 'ÙƒØªØ§Ø¨'}</div><div class="upgrade-level">${c.isNew ? '<span style="font-size:0.75rem;font-weight:bold;color:#00ff88;text-shadow:0 0 8px #00ff88;white-space:nowrap">âœ¨Ø¬Ø¯ÙŠØ¯!âœ¨</span>' : `Ù…Ø³ØªÙˆÙ‰ ${lvl} â†’ ${lvl + 1}`}</div>${statChangeText}<div class="upgrade-rarity" style="background:${rar.color}20;color:${rar.color};font-size:0.55rem;padding:2px 4px">${rar.name}</div>`;
            card.onclick = () => { 
                this.selectUpgrade(c, rar, c.upgradeType); 
                modal.style.display = 'none'; 
                this.state = 'playing';
                // Prevent immediate re-trigger of level up
                this.levelUpCooldown = 0.5;
            };
            opts.appendChild(card);
        });
        
        // Add reroll button
        const rerollCost = Math.floor(10 * Math.pow(1.5, this.rerollCount || 0));
        let rerollContainer = document.getElementById('rerollContainer');
        if (!rerollContainer) {
            rerollContainer = document.createElement('div');
            rerollContainer.id = 'rerollContainer';
            rerollContainer.style.cssText = 'width:100%;text-align:center;margin-top:12px;';
            opts.parentNode.appendChild(rerollContainer);
        }
        rerollContainer.innerHTML = `
            <button id="rerollBtn" style="background:linear-gradient(135deg,#3a3a3a,#1a1a1a);border:2px solid #ffd700;color:#ffd700;padding:8px 20px;border-radius:8px;cursor:pointer;font-family:'PixelAE',monospace;font-size:0.8rem;display:inline-flex;align-items:center;gap:6px;transition:all 0.2s;${this.player.gold >= rerollCost ? '' : 'opacity:0.5;cursor:not-allowed;'}">
                ğŸ² Ø¬Ø±Ø¨ Ø­Ø¸Ùƒ <span style="color:#fff;font-size:0.7rem">(ğŸ’°${rerollCost})</span>
            </button>
        `;
        const rerollBtn = document.getElementById('rerollBtn');
        if (this.player.gold >= rerollCost) {
            rerollBtn.onclick = () => {
                this.player.gold -= rerollCost;
                this.rerollCount = (this.rerollCount || 0) + 1;
                this.updateHUD();
                this.showLevelUp(); // Re-generate options
            };
            rerollBtn.onmouseenter = () => { rerollBtn.style.transform = 'scale(1.05)'; rerollBtn.style.boxShadow = '0 0 15px #ffd70050'; };
            rerollBtn.onmouseleave = () => { rerollBtn.style.transform = 'scale(1)'; rerollBtn.style.boxShadow = 'none'; };
        }
        
        modal.style.display = 'flex';
    }
    
    selectUpgrade(c, rar, upgradeType) {
        try {
            // Apply the upgrade
            if (c.type === 'weapon') {
                const type = upgradeType || ['damage', 'count', 'cooldown'][Math.floor(Math.random() * 3)];
                const upgrade = { rarity: rar, type: type };
                
                if (c.isNew) {
                    this.player.weapons.push({ id: c.id, level: 1, upgrades: [upgrade] });
                } else { 
                    const w = this.player.weapons.find(x => x.id === c.id); 
                    if (w) {
                        w.level++; 
                        w.upgrades.push(upgrade);
                    }
                }
            } else {
                if (c.isNew) { 
                    this.player.books.push({ id: c.id, level: 1, upgrades: [{ rarity: rar }] }); 
                    this.applyBook(c.id, 1, rar);
                } else { 
                    const b = this.player.books.find(x => x.id === c.id); 
                    if (b) {
                        b.level++; 
                        b.upgrades.push({ rarity: rar }); 
                        this.applyBook(c.id, b.level, rar);
                    }
                }
            }
            
            // Update equipment display
            this.updateSlots();
            
            // Visual effects (wrapped in try-catch to prevent crashes)
            try {
                const effectColor = rar.color || '#ffd700';
                if (this.texts && this.player) {
                    const msg = c.isNew ? (c.type === 'weapon' ? 'Ø³Ù„Ø§Ø­ Ø¬Ø¯ÙŠØ¯!' : BOOKS[c.id].name + '!') : '+ØªØ±Ù‚ÙŠØ©!';
                    this.texts.push(new FloatText(this.player.x, this.player.y - 40, msg, effectColor, 16));
                }
                if (this.particles && this.player) {
                    this.particles.emit(this.player.x, this.player.y, 15, { color: effectColor, minS: 80, maxS: 150, size: 3, life: 0.6 });
                }
                // Play sound
                if (this.audio) {
                    this.audio.play(880, 0.15, 0.1, 'sine');
                }
            } catch (e) {
                console.log('Visual effect error:', e);
            }
        } catch (e) {
            console.error('selectUpgrade error:', e);
        }
    }
    
    applyBook(id, level, rar) {
        const book = BOOKS[id], v = book.val * (1 + rar.bonus * 0.12);
        switch (book.stat) {
            case 'damage': this.player.dmgMult += v; break;
            case 'atkSpd': this.player.atkSpd += v; break;
            case 'moveSpd': this.player.speed += this.player.speed * v; break;
            case 'xp': this.player.xpMult += v; break;
            case 'maxHp': const inc = this.player.maxHp * v; this.player.maxHp += inc; this.player.hp += inc; break;
            case 'armor': this.player.armor += v * 6; break;
            case 'pickup': this.player.pickupRange += this.player.pickupRange * v; break;
            case 'luck': this.player.luck += v; break;
            case 'curse': this.player.curse += v; break;
            case 'regen': this.player.regen += v; break;
            case 'crit': this.player.crit += v; break;
        }
    }
    
    over(victory) {
        this.state = 'gameover';
        this.audio.stopBGM();
        this.audio.stopBossMusic();
        document.getElementById('hud').style.display = 'none';
        document.getElementById('equipmentSlots').style.display = 'none';
        document.getElementById('miniMap').style.display = 'none';
        document.getElementById('pauseBtn').style.display = 'none';
        
        const title = document.getElementById('gameOverTitle'), unlock = document.getElementById('unlockMessage');
        if (victory) { 
            this.audio.victory(); 
            title.textContent = 'ğŸ‰ Ø§Ù†ØªØµØ§Ø±! ğŸ‰'; 
            title.className = 'game-over-title victory-title'; 
            if (!this.baghdadUnlocked) { 
                this.baghdadUnlocked = true; 
                localStorage.setItem('baghdadUnlocked', 'true'); 
                unlock.textContent = 'ğŸ”“ ØªÙ… ÙØªØ­ Ø®Ø±ÙŠØ·Ø© Ø¨ØºØ¯Ø§Ø¯!'; 
                unlock.style.display = 'block'; 
            } else unlock.style.display = 'none'; 
        } else { 
            this.audio.death(); 
            title.textContent = 'Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©'; 
            title.className = 'game-over-title'; 
            unlock.style.display = 'none'; 
        }
        
        if (this.player.kills > this.highScore) { 
            this.highScore = this.player.kills; 
            localStorage.setItem('goldBloodHighScore', this.highScore.toString()); 
            document.getElementById('highScore').textContent = this.highScore; 
        }
        
        const m = Math.floor(this.time / 60), s = Math.floor(this.time % 60);
        document.getElementById('finalStats').innerHTML = `
            <p>â±ï¸ ${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}</p>
            <p>â­ Ø§Ù„Ù…Ø³ØªÙˆÙ‰: ${this.player.level}</p>
            <p>ğŸ’€ Ø§Ù„Ù‚ØªÙ„Ù‰: ${this.player.kills}</p>
            <p>ğŸ’° Ø§Ù„Ø°Ù‡Ø¨: ${this.player.gold}</p>
        `;
        
        // Auto-save with last used name, show quick name change option
        const savedName = localStorage.getItem('goldblood_playerName') || '';
        const nameSection = document.getElementById('nameInputSection');
        
        nameSection.innerHTML = `
            <div style="background:#1a1a2e;padding:15px;border-radius:10px;border:2px solid #ffd700">
                <p style="color:#ffd700;margin-bottom:10px;font-size:0.9rem">ğŸ“ Ø§Ø³Ù…Ùƒ ÙÙŠ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø¨Ø·Ø§Ù„:</p>
                <input type="text" id="playerNameInput" value="${savedName}" placeholder="Ø§ÙƒØªØ¨ Ø§Ø³Ù…Ùƒ..." maxlength="15" 
                    style="padding:10px 15px;font-size:1rem;border-radius:8px;border:2px solid #ffd700;background:#0a0a1e;color:#fff;text-align:center;font-family:'PixelAE',sans-serif;width:100%;margin-bottom:10px">
                <button id="submitScoreBtn" class="btn" style="background:linear-gradient(135deg,#ffd700,#ff8c00);color:#000;padding:12px 25px;width:100%;font-size:1rem;font-weight:bold;border-radius:8px;border:none;cursor:pointer">
                    âœ… Ø§Ø­ÙØ¸ ÙˆØ´Ø§Ø±Ùƒ Ù†ØªÙŠØ¬ØªÙƒ
                </button>
            </div>
        `;
        nameSection.style.display = 'block';
        
        // Re-bind submit button
        document.getElementById('submitScoreBtn').onclick = () => this.submitScore();
        
        document.getElementById('gameOverScreen').style.display = 'flex';
    }
    
    updateHUD() {
        const healthPercent = (this.player.hp / this.player.maxHp) * 100;
        document.getElementById('healthBar').style.width = `${healthPercent}%`;
        document.getElementById('healthText').textContent = `${Math.ceil(this.player.hp)}/${Math.ceil(this.player.maxHp)}`;
        
        // Flash health bar when low
        const healthBar = document.getElementById('healthBar');
        if (healthPercent < 25) {
            healthBar.style.animation = 'pulse 0.5s ease-in-out infinite';
        } else {
            healthBar.style.animation = '';
        }
        
        // Same formula as checkLevelUp
        const level = this.player.level;
        const req = level <= 10 
            ? Math.floor(10 * Math.pow(1.25, level - 1))
            : Math.floor(10 * Math.pow(1.25, 9) * Math.pow(1.15, level - 10));
        document.getElementById('xpBar').style.width = `${(this.player.xp / req) * 100}%`;
        document.getElementById('xpText').textContent = `${Math.floor(this.player.xp)}/${req}`;
        document.getElementById('levelText').textContent = `Lv.${this.player.level}`;
        document.getElementById('goldText').textContent = this.player.gold;
        document.getElementById('killText').textContent = this.player.kills;
        const m = Math.floor(this.time / 60), s = Math.floor(this.time % 60);
        document.getElementById('timerText').textContent = `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    }
    
    draw() {
        const ctx = this.ctx;
        ctx.fillStyle = this.city === 'baghdad' ? '#7a9a7a' : '#d4b896';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        if (this.state === 'menu') { this.drawMenuBg(); return; }
        if (['playing', 'paused', 'levelup', 'itemPickup', 'gameover'].includes(this.state)) this.drawGame();
    }
    
    drawMenuBg() {
        const ctx = this.ctx, t = Date.now() / 1000;
        const w = this.canvas.width, h = this.canvas.height;
        
        // Gradient background
        const gradient = ctx.createLinearGradient(0, 0, 0, h);
        gradient.addColorStop(0, '#0a0a15');
        gradient.addColorStop(0.5, '#1a1a2e');
        gradient.addColorStop(1, '#0f0f1a');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, w, h);
        
        // Animated sand dunes
        for (let i = 0; i < 5; i++) { 
            const y = h * 0.4 + i * 50; 
            const alpha = 0.15 + i * 0.05;
            ctx.fillStyle = `rgba(${80 + i * 15}, ${60 + i * 10}, ${40 + i * 5}, ${alpha})`; 
            ctx.beginPath(); 
            ctx.moveTo(0, y); 
            for (let x = 0; x <= w; x += 30) {
                ctx.lineTo(x, y + Math.sin(x * 0.006 + t * 0.5 + i * 0.5) * 15);
            }
            ctx.lineTo(w, h); 
            ctx.lineTo(0, h); 
            ctx.fill(); 
        }
        
        // Floating particles
        ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
        for (let i = 0; i < 15; i++) {
            const x = (t * 20 + i * 100) % w;
            const y = h * 0.3 + Math.sin(t * 2 + i) * 30 + i * 20;
            const size = 1 + Math.sin(t * 3 + i * 0.5) * 0.5;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Subtle stars
        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
        for (let i = 0; i < 30; i++) {
            const x = (i * 67) % w;
            const y = (i * 43) % (h * 0.4);
            const size = 0.5 + Math.sin(t * 2 + i) * 0.3;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    drawGame() {
        const ctx = this.ctx;
        this.drawBg();
        this.particles.draw(ctx, this.cam);
        for (const p of this.pickups) p.draw(ctx, this.cam, this.assets);
        
        // Draw chests
        for (const chest of this.chests) {
            chest.draw(ctx, this.cam, this.assets);
        }
        
        // Draw breakable pots (behind items)
        for (const pot of this.pots) {
            pot.draw(ctx, this.cam);
        }
        
        // Draw ground buffs
        for (const buff of this.groundBuffs) {
            buff.draw(ctx, this.cam);
        }
        
        for (const i of this.items) i.draw(ctx, this.cam, this.assets);
        
        // Draw effects
        for (const f of this.fx) {
            const sx = f.x - this.cam.x, sy = f.y - this.cam.y;
            if (f.type === 'lightning') { 
                // Outer glow
                ctx.fillStyle = `rgba(255, 255, 100, ${f.life / 0.25 * 0.3})`;
                ctx.beginPath();
                ctx.arc(sx, sy, 45, 0, Math.PI * 2);
                ctx.fill();
                
                // Multiple lightning bolts
                for (let b = 0; b < 3; b++) {
                    ctx.strokeStyle = `rgba(255, 255, ${150 + b * 35}, ${f.life / 0.25})`; 
                    ctx.lineWidth = 4 - b; 
                    ctx.beginPath(); 
                    ctx.moveTo(sx + (b - 1) * 8, sy - 400); 
                    let lx = sx + (b - 1) * 8;
                    for (let i = 0; i < 12; i++) {
                        lx += (Math.random() - 0.5) * 25;
                        ctx.lineTo(lx, sy - 400 + i * 35);
                    }
                    ctx.lineTo(sx, sy); 
                    ctx.stroke();
                }
                
                // Impact glow
                ctx.fillStyle = `rgba(255, 255, 200, ${f.life / 0.25 * 0.6})`; 
                ctx.beginPath(); 
                ctx.arc(sx, sy, 30, 0, Math.PI * 2); 
                ctx.fill();
                ctx.fillStyle = `rgba(255, 255, 255, ${f.life / 0.25 * 0.8})`; 
                ctx.beginPath(); 
                ctx.arc(sx, sy, 15, 0, Math.PI * 2); 
                ctx.fill();
            }
            else if (f.type === 'meteor' && f.delay <= 0) { 
                if (f.life > 0.35) { 
                    // Target indicator
                    ctx.strokeStyle = 'rgba(255, 70, 0, 0.5)'; 
                    ctx.lineWidth = 3; 
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath(); 
                    ctx.arc(sx, sy, f.radius, 0, Math.PI * 2); 
                    ctx.stroke(); 
                    ctx.setLineDash([]);
                    
                    // Incoming meteor with trail
                    const meteorY = sy - (f.life - 0.35) * 280;
                    // Trail
                    ctx.fillStyle = 'rgba(255, 100, 0, 0.3)';
                    ctx.beginPath();
                    ctx.moveTo(sx - 10, meteorY);
                    ctx.lineTo(sx, meteorY - 60);
                    ctx.lineTo(sx + 10, meteorY);
                    ctx.fill();
                    // Meteor
                    ctx.fillStyle = '#ff4400';
                    ctx.beginPath();
                    ctx.arc(sx, meteorY, 16, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    ctx.arc(sx, meteorY, 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(sx, meteorY, 5, 0, Math.PI * 2);
                    ctx.fill();
                } else { 
                    // Explosion
                    const progress = 1 - f.life / 0.35;
                    ctx.fillStyle = `rgba(255, 100, 0, ${0.5 - progress * 0.4})`; 
                    ctx.beginPath(); 
                    ctx.arc(sx, sy, f.radius * progress, 0, Math.PI * 2); 
                    ctx.fill(); 
                    ctx.fillStyle = `rgba(255, 200, 0, ${0.6 - progress * 0.5})`; 
                    ctx.beginPath(); 
                    ctx.arc(sx, sy, f.radius * progress * 0.6, 0, Math.PI * 2); 
                    ctx.fill(); 
                } 
            }
            else if (f.type === 'tornado') { 
                // Animated tornado
                const time = Date.now() * 0.003;
                ctx.save();
                ctx.translate(sx, sy);
                
                // Outer dust clouds
                ctx.fillStyle = 'rgba(160, 140, 100, 0.3)';
                for (let i = 0; i < 6; i++) {
                    const angle = time + i * Math.PI / 3;
                    const dist = f.radius * 0.9;
                    ctx.beginPath();
                    ctx.arc(Math.cos(angle) * dist, Math.sin(angle) * dist, 8, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Spiral lines
                ctx.strokeStyle = 'rgba(180, 160, 120, 0.6)';
                ctx.lineWidth = 3;
                for (let spiral = 0; spiral < 3; spiral++) {
                    ctx.beginPath();
                    for (let i = 0; i < 20; i++) {
                        const angle = time * 2 + i * 0.3 + spiral * 2;
                        const r = f.radius * (1 - i / 25);
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r * 0.4 - i * 2;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                
                // Center column
                ctx.fillStyle = 'rgba(140, 120, 90, 0.5)';
                ctx.fillRect(-8, -f.radius * 0.8, 16, f.radius * 1.2);
                
                ctx.restore();
            }
        }
        
        // Draw enemies with sprites
        for (const e of this.enemies) e.draw(ctx, this.cam, this.assets);
        if (this.boss) this.boss.draw(ctx, this.cam, this.assets);
        
        // Draw aura effect UNDER the player
        this.player.drawAuraUnder(ctx, this.cam, this.assets);
        
        // Draw player with sprite
        this.player.draw(ctx, this.cam, this.assets);
        
        // Draw projectiles with IconSet sprites
        const iconset = this.assets.get('iconset');
        for (const p of this.proj) { 
            const px = p.x - this.cam.x, py = p.y - this.cam.y;
            const angle = Math.atan2(p.vy, p.vx);
            
            // Try to draw from IconSet if projectile has iconPos
            if (p.iconPos && iconset) {
                ctx.save();
                ctx.translate(px, py);
                ctx.rotate(angle);
                ctx.imageSmoothingEnabled = false;
                const iconSize = 24;
                const drawSize = p.size * 3;
                ctx.drawImage(
                    iconset,
                    p.iconPos.col * iconSize, p.iconPos.row * iconSize,
                    iconSize, iconSize,
                    -drawSize/2, -drawSize/2, drawSize, drawSize
                );
                ctx.restore();
            } else if (p.type === 'fire') {
                // Fire projectile with outer glow
                ctx.fillStyle = 'rgba(255, 69, 0, 0.4)';
                ctx.beginPath();
                ctx.arc(px, py, p.size + 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ff4500';
                ctx.beginPath();
                ctx.arc(px, py, p.size + 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ff6600';
                ctx.beginPath();
                ctx.arc(px, py, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(px, py, p.size * 0.4, 0, Math.PI * 2);
                ctx.fill();
            } else if (p.type === 'arrow') {
                // Arrow projectile from IconSet
                if (iconset) {
                    ctx.save();
                    ctx.translate(px, py);
                    ctx.rotate(angle);
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(iconset, 30 * 24, 6 * 24, 24, 24, -16, -8, 32, 16);
                    ctx.restore();
                } else {
                    ctx.save();
                    ctx.translate(px, py);
                    ctx.rotate(angle);
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(-12, -2, 20, 4);
                    ctx.fillStyle = '#C0C0C0';
                    ctx.beginPath();
                    ctx.moveTo(8, -5);
                    ctx.lineTo(14, 0);
                    ctx.lineTo(8, 5);
                    ctx.fill();
                    ctx.restore();
                }
            } else if (p.type === 'rock') {
                // Rock projectile from IconSet
                if (iconset) {
                    ctx.save();
                    ctx.translate(px, py);
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(iconset, 9 * 24, 3 * 24, 24, 24, -12, -12, 24, 24);
                    ctx.restore();
                } else {
                    ctx.fillStyle = '#5a5a5a';
                    ctx.beginPath();
                    ctx.arc(px, py, p.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (p.type === 'spear') {
                // Spear projectile from IconSet
                if (iconset) {
                    ctx.save();
                    ctx.translate(px, py);
                    ctx.rotate(angle);
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(iconset, 4 * 24, 29 * 24, 24, 24, -18, -9, 36, 18);
                    ctx.restore();
                } else {
                    ctx.save();
                    ctx.translate(px, py);
                    ctx.rotate(angle);
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(-15, -2, 30, 4);
                    ctx.fillStyle = '#C0C0C0';
                    ctx.beginPath();
                    ctx.moveTo(15, 0);
                    ctx.lineTo(10, -4);
                    ctx.lineTo(10, 4);
                    ctx.fill();
                    ctx.restore();
                }
            } else if (p.type === 'blue_fire') {
                // Blue fire (for Layla)
                ctx.fillStyle = 'rgba(0, 100, 255, 0.4)';
                ctx.beginPath();
                ctx.arc(px, py, p.size + 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#0066ff';
                ctx.beginPath();
                ctx.arc(px, py, p.size + 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#00aaff';
                ctx.beginPath();
                ctx.arc(px, py, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#aaeeff';
                ctx.beginPath();
                ctx.arc(px, py, p.size * 0.4, 0, Math.PI * 2);
                ctx.fill();
            } else if (p.type === 'dot' && p.weaponId) {
                // DOT projectile with animated sprite (onion)
                const wData = WEAPONS[p.weaponId];
                const projSprite = wData.projectileSprite && this.assets.get(wData.projectileSprite);
                if (projSprite && wData.projFrameW) {
                    const fps = 12;
                    const frame = Math.floor((this.time * fps) % wData.projFrames);
                    ctx.save();
                    ctx.translate(px, py);
                    ctx.rotate(angle);
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(projSprite, frame * wData.projFrameW, 0, wData.projFrameW, wData.projFrameW,
                        -wData.projFrameW * 0.6, -wData.projFrameW * 0.6, wData.projFrameW * 1.2, wData.projFrameW * 1.2);
                    ctx.restore();
                } else {
                    ctx.fillStyle = '#9f9';
                    ctx.beginPath();
                    ctx.arc(px, py, p.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (p.type === 'mgma') {
                // Mgma shotgun projectile with animated sprite
                const wData = WEAPONS.mgma;
                const effectSprite = wData.effectSprite && this.assets.get(wData.effectSprite);
                if (effectSprite && wData.frameW) {
                    const fps = 15;
                    const frame = Math.floor((this.time * fps) % wData.frames);
                    ctx.save();
                    ctx.translate(px, py);
                    ctx.rotate(angle);
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(effectSprite, frame * wData.frameW, 0, wData.frameW, wData.frameH,
                        -wData.frameW * 0.5, -wData.frameH * 0.5, wData.frameW, wData.frameH);
                    ctx.restore();
                } else {
                    ctx.fillStyle = '#f80';
                    ctx.beginPath();
                    ctx.arc(px, py, p.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (p.type === 'bounce') {
                // Shuriken projectile with spinning animation
                const effectSprite = p.effectSprite && this.assets.get(p.effectSprite);
                if (effectSprite && p.frameW) {
                    ctx.save();
                    ctx.translate(px, py);
                    // Spinning rotation based on time
                    ctx.rotate(this.time * 15);
                    ctx.imageSmoothingEnabled = false;
                    const frame = p.currentFrame || 0;
                    const scale = 0.18; // Much smaller projectile
                    ctx.drawImage(effectSprite, frame * p.frameW, 0, p.frameW, p.frameH,
                        -p.frameW * scale / 2, -p.frameH * scale / 2, p.frameW * scale, p.frameH * scale);
                    ctx.restore();
                } else {
                    // Fallback: draw star shape
                    ctx.save();
                    ctx.translate(px, py);
                    ctx.rotate(this.time * 15);
                    ctx.fillStyle = '#aaf';
                    ctx.beginPath();
                    for (let j = 0; j < 4; j++) {
                        const a = j * Math.PI / 2;
                        ctx.lineTo(Math.cos(a) * p.size * 0.6, Math.sin(a) * p.size * 0.6);
                        ctx.lineTo(Math.cos(a + Math.PI / 4) * p.size * 0.25, Math.sin(a + Math.PI / 4) * p.size * 0.25);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                }
            } else {
                ctx.fillStyle = p.color; 
                ctx.beginPath(); 
                ctx.arc(px, py, p.size, 0, Math.PI * 2); 
                ctx.fill();
            }
            
            // Trail effect
            ctx.globalAlpha = 0.35;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(px - p.vx * 0.015, py - p.vy * 0.015, p.size * 0.65, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 0.2;
            ctx.beginPath();
            ctx.arc(px - p.vx * 0.03, py - p.vy * 0.03, p.size * 0.4, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
        for (const p of this.eProj) { 
            const px = p.x - this.cam.x, py = p.y - this.cam.y;
            
            if (p.type === 'gas') {
                // Green gas effect
                ctx.fillStyle = 'rgba(34, 170, 34, 0.3)';
                ctx.beginPath();
                ctx.arc(px, py, p.size * 1.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'rgba(68, 255, 68, 0.5)';
                ctx.beginPath();
                ctx.arc(px, py, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'rgba(150, 255, 150, 0.7)';
                ctx.beginPath();
                ctx.arc(px, py, p.size * 0.5, 0, Math.PI * 2);
                ctx.fill();
            } else {
                ctx.fillStyle = p.color; 
                ctx.beginPath(); 
                ctx.arc(px, py, p.size, 0, Math.PI * 2); 
                ctx.fill(); 
            }
        }
        for (const t of this.texts) t.draw(ctx, this.cam);
        
        // Draw sprite effects
        for (const e of this.spriteEffects) e.draw(ctx, this.cam, this.assets);
        
        this.drawLighting();
        
        // Virtual joystick for mobile
        if (this.input.joy) { 
            ctx.fillStyle = 'rgba(255, 255, 255, 0.12)'; 
            ctx.beginPath(); 
            ctx.arc(80, this.canvas.height - 80, 55, 0, Math.PI * 2); 
            ctx.fill(); 
            ctx.fillStyle = 'rgba(255, 215, 0, 0.35)'; 
            ctx.beginPath(); 
            ctx.arc(80 + this.input.joy.x * 35, this.canvas.height - 80 + this.input.joy.y * 35, 20, 0, Math.PI * 2); 
            ctx.fill(); 
        }
        
        // Boss health bar - positioned below HUD
        if (this.boss) {
            const bw = Math.min(350, this.canvas.width * 0.8), bx = (this.canvas.width - bw) / 2;
            const by = 85; // Moved down to be below HUD
            
            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)'; 
            ctx.fillRect(bx - 5, by - 5, bw + 10, 35);
            
            // Border
            ctx.strokeStyle = '#ff4444';
            ctx.lineWidth = 2;
            ctx.strokeRect(bx - 5, by - 5, bw + 10, 35);
            
            // HP bar background
            ctx.fillStyle = '#333'; 
            ctx.fillRect(bx, by + 10, bw, 16);
            
            // HP fill
            const hpColor = this.boss.phase === 3 ? '#ff0000' : this.boss.phase === 2 ? '#ff6600' : '#ffcc00';
            ctx.fillStyle = hpColor;
            ctx.fillRect(bx, by + 10, bw * (this.boss.hp / this.boss.maxHp), 16);
            
            // Boss name
            const bossName = this.boss.name || BOSS.name;
            ctx.fillStyle = '#fff'; 
            ctx.font = 'bold 11px PixelAE, Cairo'; 
            ctx.textAlign = 'center';
            ctx.fillText(`ğŸ‘¹ ${bossName} - Ø§Ù„Ù…Ø±Ø­Ù„Ø© ${this.boss.phase}`, this.canvas.width / 2, by + 5);
        }
        
        // Draw price below each chest
        for (const chest of this.chests) {
            if (chest.opened) continue;
            const chestX = chest.x - this.cam.x;
            const chestY = chest.y - this.cam.y;
            const price = ChestManager.getPrice(this.player.chestDiscount);
            const canAfford = this.player.gold >= price;
            
            // Price tag below chest
            ctx.fillStyle = canAfford ? '#ffd700' : '#ff4444';
            ctx.font = 'bold 11px PixelAE, Cairo';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText(`${price}ğŸ’°`, chestX, chestY + 22);
            
            // If player is near, show timer progress
            if (chest.nearTimer && chest.nearTimer > 0) {
                const progress = chest.nearTimer / 1.5;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(chestX - 20, chestY - 30, 40, 6);
                ctx.fillStyle = canAfford ? '#00ff00' : '#ff4444';
                ctx.fillRect(chestX - 20, chestY - 30, 40 * progress, 6);
            }
        }
        
        // Draw active buff indicators
        const activeBuffsList = Object.entries(this.activeBuffs).filter(([k, v]) => v > 0);
        if (activeBuffsList.length > 0) {
            let buffX = 10;
            const buffY = this.canvas.height - 50;
            
            for (const [buffType, duration] of activeBuffsList) {
                const buffData = BUFF_TYPES[buffType];
                if (!buffData) continue;
                
                // Background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.beginPath();
                ctx.roundRect(buffX, buffY, 45, 40, 5);
                ctx.fill();
                
                // Border with buff color
                ctx.strokeStyle = buffData.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(buffX, buffY, 45, 40, 5);
                ctx.stroke();
                
                // Icon
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(buffData.icon, buffX + 22, buffY + 15);
                
                // Timer
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 10px PixelAE, Cairo';
                ctx.fillText(Math.ceil(duration) + 's', buffX + 22, buffY + 32);
                
                buffX += 50;
            }
        }
    }
    
    drawBg() {
        const ctx = this.ctx;
        
        // Try to draw the new map image
        const mapImg = this.assets.get('map_bg');
        if (mapImg && this.city === 'badaya') {
            ctx.imageSmoothingEnabled = false;
            // Map is 4000x4000, world is CONFIG.WORLD_SIZE
            const mapSize = CONFIG.WORLD_SIZE;
            const halfMap = mapSize / 2;
            
            // Calculate visible area
            const drawX = -halfMap - this.cam.x;
            const drawY = -halfMap - this.cam.y;
            
            ctx.drawImage(mapImg, drawX, drawY, mapSize, mapSize);
        } else {
            // Fallback to solid color
            ctx.fillStyle = this.city === 'badaya' ? '#c9a66b' : '#5a8a5a';
            ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        }
        
        // Draw map borders
        if (this.map.generated) {
            this.map.drawBorders(ctx, this.cam, CONFIG.WORLD_SIZE);
        }
    }
    
    drawLighting() {
        // Subtle vignette effect only - no heavy darkness
        const ctx = this.ctx;
        const cx = this.canvas.width / 2, cy = this.canvas.height / 2;
        const maxDist = Math.max(this.canvas.width, this.canvas.height) * 0.7;
        
        // Very subtle edge darkening (vignette)
        const vignette = ctx.createRadialGradient(cx, cy, maxDist * 0.5, cx, cy, maxDist);
        vignette.addColorStop(0, 'rgba(0, 0, 0, 0)');
        vignette.addColorStop(1, 'rgba(0, 0, 0, 0.15)');
        ctx.fillStyle = vignette;
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Warm tint overlay
        ctx.fillStyle = 'rgba(255, 200, 100, 0.02)';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }
    
    drawHudAvatar() {
        const canvas = document.getElementById('hudAvatarCanvas');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, 32, 32);
        ctx.imageSmoothingEnabled = false;
        
        const charId = this.charIds[this.charIdx];
        const spriteInfo = CHAR_SPRITES[charId];
        
        if (spriteInfo) {
            let sprite = null;
            
            if (spriteInfo.type === 'walk_idle') {
                // Use previewSprite for HUD if available, otherwise idleSprite
                const spriteKey = spriteInfo.previewSprite || spriteInfo.idleSprite;
                sprite = this.assets.get(spriteKey);
                if (sprite) {
                    // Check if previewSprite (full image) or spritesheet
                    if (spriteInfo.previewSprite) {
                        // Full static image
                        const scale = Math.min(30 / sprite.width, 30 / sprite.height);
                        const drawW = sprite.width * scale;
                        const drawH = sprite.height * scale;
                        ctx.drawImage(sprite, (32 - drawW) / 2, (32 - drawH) / 2, drawW, drawH);
                    } else if (spriteInfo.frameWidth) {
                        // Spritesheet - draw first frame
                        const frameW = spriteInfo.frameWidth;
                        const frameH = spriteInfo.frameHeight;
                        const scale = Math.min(30 / frameW, 30 / frameH);
                        const drawW = frameW * scale;
                        const drawH = frameH * scale;
                        ctx.drawImage(sprite, 0, 0, frameW, frameH, (32 - drawW) / 2, (32 - drawH) / 2, drawW, drawH);
                    } else {
                        // Full image fallback
                        const scale = Math.min(30 / sprite.width, 30 / sprite.height);
                        const drawW = sprite.width * scale;
                        const drawH = sprite.height * scale;
                        ctx.drawImage(sprite, (32 - drawW) / 2, (32 - drawH) / 2, drawW, drawH);
                    }
                }
            } else if (spriteInfo.type === 'multiframe' && spriteInfo.frames) {
                sprite = this.assets.get(spriteInfo.frames[0]);
                if (sprite) {
                    const scale = Math.min(28 / sprite.width, 28 / sprite.height) * 2;
                    const drawW = sprite.width * scale;
                    const drawH = sprite.height * scale;
                    ctx.drawImage(sprite, (32 - drawW) / 2, (32 - drawH) / 2, drawW, drawH);
                }
            }
        }
        
        // Fallback: draw colored circle with initial
        if (!ctx.getImageData(16, 16, 1, 1).data[3]) {
            const colors = CHARACTERS[charId]?.colors || { body: '#666' };
            ctx.fillStyle = colors.body || '#666';
            ctx.beginPath();
            ctx.arc(16, 16, 12, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(CHARACTERS[charId]?.name?.[0] || '?', 16, 16);
        }
    }
    
    drawMiniMap() {
        const miniMapEl = document.getElementById('miniMap');
        const canvas = document.getElementById('miniMapCanvas');
        if (!canvas || !miniMapEl) return;
        
        const ctx = canvas.getContext('2d');
        const w = canvas.width, h = canvas.height;
        const scale = 0.015; // Scale factor for mini map
        const range = 600; // How far to show on mini map
        
        // Clear
        ctx.fillStyle = this.city === 'baghdad' ? 'rgba(60, 90, 60, 0.9)' : 'rgba(80, 70, 50, 0.9)';
        ctx.fillRect(0, 0, w, h);
        
        // Draw grid
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 0.5;
        for (let i = 0; i < 5; i++) {
            ctx.beginPath();
            ctx.moveTo(i * w / 4, 0);
            ctx.lineTo(i * w / 4, h);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, i * h / 4);
            ctx.lineTo(w, i * h / 4);
            ctx.stroke();
        }
        
        const cx = w / 2, cy = h / 2;
        
        // Draw pickups (small green dots)
        ctx.fillStyle = '#44ff44';
        for (const p of this.pickups) {
            const dx = (p.x - this.player.x) * scale;
            const dy = (p.y - this.player.y) * scale;
            if (Math.abs(dx) < range * scale && Math.abs(dy) < range * scale) {
                ctx.beginPath();
                ctx.arc(cx + dx, cy + dy, 1.5, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Draw chests (golden squares)
        ctx.fillStyle = '#ffd700';
        for (const chest of this.chests) {
            if (chest.opened) continue;
            const dx = (chest.x - this.player.x) * scale;
            const dy = (chest.y - this.player.y) * scale;
            if (Math.abs(dx) < range * scale && Math.abs(dy) < range * scale) {
                ctx.fillRect(cx + dx - 3, cy + dy - 3, 6, 6);
            }
        }
        
        // Draw pots (brown dots)
        ctx.fillStyle = '#8B4513';
        for (const pot of this.pots) {
            if (pot.broken) continue;
            const dx = (pot.x - this.player.x) * scale;
            const dy = (pot.y - this.player.y) * scale;
            if (Math.abs(dx) < range * scale && Math.abs(dy) < range * scale) {
                ctx.beginPath();
                ctx.arc(cx + dx, cy + dy, pot.type === 'gold' ? 3 : 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Draw items (yellow dots)
        ctx.fillStyle = '#ffff00';
        for (const i of this.items) {
            const dx = (i.x - this.player.x) * scale;
            const dy = (i.y - this.player.y) * scale;
            if (Math.abs(dx) < range * scale && Math.abs(dy) < range * scale) {
                ctx.beginPath();
                ctx.arc(cx + dx, cy + dy, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Draw enemies (red dots)
        ctx.fillStyle = '#ff4444';
        for (const e of this.enemies) {
            const dx = (e.x - this.player.x) * scale;
            const dy = (e.y - this.player.y) * scale;
            if (Math.abs(dx) < range * scale && Math.abs(dy) < range * scale) {
                ctx.beginPath();
                ctx.arc(cx + dx, cy + dy, 2.5, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Draw boss (large red dot)
        if (this.boss) {
            const dx = (this.boss.x - this.player.x) * scale;
            const dy = (this.boss.y - this.player.y) * scale;
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(cx + dx, cy + dy, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#ffff00';
            ctx.lineWidth = 1;
            ctx.stroke();
        }
        
        // Draw player (center, white with gold border)
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(cx, cy, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#ffd700';
        ctx.lineWidth = 1.5;
        ctx.stroke();
        
        // Draw direction indicator
        const angle = Math.atan2(this.player.vy, this.player.vx);
        if (Math.abs(this.player.vx) > 5 || Math.abs(this.player.vy) > 5) {
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.lineTo(cx + Math.cos(angle) * 8, cy + Math.sin(angle) * 8);
            ctx.stroke();
        }
        
        // Border
        ctx.strokeStyle = 'rgba(255, 215, 0, 0.5)';
        ctx.lineWidth = 2;
        ctx.strokeRect(1, 1, w - 2, h - 2);
    }
}

window.addEventListener('load', () => { window.gameInstance = new Game(); });
    </script>
</body>
</html>
