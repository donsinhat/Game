<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>ÿ∞Ÿáÿ® ÿ£ÿµŸÅÿ± ÿ£Ÿà ÿØŸÖ ÿ£ÿ≠ŸÖÿ± - Gold or Blood</title>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700;900&family=Changa:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }
        
        body {
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0f0f1a 100%);
            font-family: 'Cairo', 'Changa', sans-serif;
            overflow: hidden;
            min-height: 100vh;
            color: #fff;
        }
        
        #gameCanvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        
        /* Rarity Colors */
        .rarity-common { color: #9d9d9d; }
        .rarity-uncommon { color: #1eff00; }
        .rarity-rare { color: #0070dd; }
        .rarity-epic { color: #a335ee; }
        .rarity-legendary { color: #ff8000; }
        
        /* Main Menu Styles */
        #mainMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            background: linear-gradient(180deg, rgba(10,10,15,0.97) 0%, rgba(26,26,46,0.98) 100%);
            padding: 20px;
        }
        
        .menu-title {
            font-size: clamp(1.5rem, 5vw, 2.5rem);
            font-weight: 900;
            text-align: center;
            margin-bottom: 5px;
            background: linear-gradient(135deg, #ffd700 0%, #ff8c00 50%, #ffd700 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .menu-subtitle {
            font-size: clamp(0.8rem, 2.5vw, 1rem);
            color: #888;
            margin-bottom: 20px;
        }
        
        /* Character Selection */
        .character-select {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 25px;
        }
        
        .char-arrow {
            width: 50px;
            height: 50px;
            background: rgba(255, 215, 0, 0.1);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 50%;
            color: #ffd700;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .char-arrow:hover {
            background: rgba(255, 215, 0, 0.2);
            border-color: #ffd700;
            transform: scale(1.1);
        }
        
        .character-display {
            width: 280px;
            padding: 20px;
            background: rgba(30, 30, 40, 0.9);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 20px;
            text-align: center;
        }
        
        .char-preview {
            width: 120px;
            height: 120px;
            margin: 0 auto 15px;
            image-rendering: pixelated;
            border-radius: 10px;
            background: rgba(0,0,0,0.3);
        }
        
        .char-name {
            font-size: 1.4rem;
            font-weight: 900;
            color: #ffd700;
            margin-bottom: 5px;
        }
        
        .char-title {
            font-size: 0.85rem;
            color: #888;
            margin-bottom: 10px;
        }
        
        .char-desc {
            font-size: 0.8rem;
            color: #aaa;
            margin-bottom: 12px;
            line-height: 1.4;
            min-height: 40px;
        }
        
        .char-stats {
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 10px;
        }
        
        .char-stat {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            margin: 4px 0;
        }
        
        .char-stat-label { color: #888; }
        .char-stat-value { color: #4f4; font-weight: bold; }
        .char-stat-negative { color: #f44; }
        
        .char-weapon {
            font-size: 0.85rem;
            color: #ff8888;
            padding: 8px;
            background: rgba(255,0,0,0.1);
            border-radius: 8px;
        }
        
        /* City Selection */
        .city-select {
            display: flex;
            gap: 15px;
            margin-bottom: 25px;
        }
        
        .city-card {
            width: 160px;
            padding: 15px;
            background: rgba(30, 30, 40, 0.9);
            border: 2px solid rgba(100, 100, 100, 0.3);
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        
        .city-card:hover:not(.locked), .city-card.selected {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.1);
            transform: translateY(-5px);
        }
        
        .city-card.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .city-icon {
            font-size: 2.5rem;
            margin-bottom: 8px;
        }
        
        .city-name {
            font-size: 1rem;
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 5px;
        }
        
        .city-desc {
            font-size: 0.7rem;
            color: #888;
        }
        
        .city-locked {
            font-size: 0.7rem;
            color: #f44;
            margin-top: 8px;
        }
        
        /* Buttons */
        .btn {
            padding: 12px 40px;
            font-size: 1.1rem;
            font-family: 'Cairo', sans-serif;
            font-weight: 700;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%);
            color: #000;
            box-shadow: 0 8px 25px rgba(255, 215, 0, 0.4);
        }
        
        .btn-primary:hover {
            transform: scale(1.05);
            box-shadow: 0 12px 35px rgba(255, 215, 0, 0.5);
        }
        
        .high-score {
            margin-top: 15px;
            font-size: 0.8rem;
            color: #666;
        }
        
        /* HUD Styles */
        #hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px 15px;
            display: none;
            justify-content: space-between;
            align-items: flex-start;
            z-index: 50;
            pointer-events: none;
        }
        
        .hud-left, .hud-right {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .hud-bar {
            width: 160px;
            height: 20px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.2);
            position: relative;
        }
        
        .hud-bar-fill {
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }
        
        .hud-bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.65rem;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
        }
        
        .health-fill {
            background: linear-gradient(90deg, #ff4444 0%, #ff0000 100%);
        }
        
        .xp-fill {
            background: linear-gradient(90deg, #44ff44 0%, #00ff00 100%);
        }
        
        .hud-stat {
            font-size: 0.85rem;
            font-weight: 700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }
        
        .gold-text { color: #ffd700; }
        .kill-text { color: #ff4444; }
        .level-text { color: #44ff44; }
        
        /* Equipment Slots */
        .equipment-slots {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            gap: 8px;
            z-index: 50;
            pointer-events: none;
        }
        
        .slot-group {
            display: flex;
            gap: 4px;
            padding: 6px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 8px;
        }
        
        .equipment-slot {
            width: 38px;
            height: 38px;
            background: rgba(50, 50, 50, 0.8);
            border: 2px solid #444;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            font-size: 1.2rem;
        }
        
        .slot-level {
            position: absolute;
            bottom: -2px;
            right: -2px;
            background: #000;
            color: #fff;
            font-size: 0.55rem;
            padding: 1px 3px;
            border-radius: 3px;
            font-weight: bold;
        }
        
        /* Level Up Modal */
        #levelUpModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        
        .level-up-content {
            text-align: center;
            padding: 25px;
            background: rgba(20, 20, 30, 0.95);
            border: 3px solid #ffd700;
            border-radius: 20px;
            max-width: 95%;
            max-height: 85vh;
            overflow-y: auto;
        }
        
        .level-up-title {
            font-size: 1.6rem;
            color: #ffd700;
            margin-bottom: 20px;
        }
        
        .upgrade-options {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .upgrade-card {
            width: 150px;
            padding: 12px;
            background: rgba(30, 30, 40, 0.9);
            border: 3px solid #444;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }
        
        .upgrade-card:hover {
            transform: scale(1.05);
        }
        
        .upgrade-icon {
            font-size: 2rem;
            margin-bottom: 8px;
        }
        
        .upgrade-name {
            font-size: 0.9rem;
            font-weight: bold;
            margin-bottom: 4px;
        }
        
        .upgrade-type {
            font-size: 0.7rem;
            color: #888;
            margin-bottom: 4px;
        }
        
        .upgrade-level {
            font-size: 0.75rem;
            margin-bottom: 4px;
        }
        
        .upgrade-desc {
            font-size: 0.65rem;
            color: #aaa;
        }
        
        .upgrade-rarity {
            font-size: 0.65rem;
            font-weight: bold;
            margin-top: 6px;
            padding: 2px 6px;
            border-radius: 8px;
            display: inline-block;
        }
        
        /* Game Over Screen */
        #gameOverScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
        }
        
        .game-over-title {
            font-size: 2rem;
            color: #ff0000;
            margin-bottom: 15px;
            text-shadow: 0 0 20px rgba(255, 0, 0, 0.8);
        }
        
        .victory-title {
            color: #ffd700 !important;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8) !important;
        }
        
        .final-stats {
            margin-bottom: 20px;
            font-size: 1rem;
            line-height: 1.6;
        }
        
        .unlock-message {
            color: #ffd700;
            font-size: 1.1rem;
            margin-bottom: 15px;
            padding: 10px 20px;
            background: rgba(255, 215, 0, 0.1);
            border-radius: 10px;
        }
        
        /* Boss Warning */
        #bossWarning {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            color: #ff0000;
            text-shadow: 0 0 30px rgba(255, 0, 0, 0.8);
            display: none;
            z-index: 150;
            text-align: center;
            animation: bossWarn 0.5s ease-in-out infinite alternate;
        }
        
        @keyframes bossWarn {
            from { transform: translate(-50%, -50%) scale(1); }
            to { transform: translate(-50%, -50%) scale(1.1); }
        }
        
        /* Pause indicator */
        #pauseIndicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            color: #ffd700;
            display: none;
            z-index: 150;
        }
        
        /* Item Notification */
        .item-notification {
            position: fixed;
            top: 18%;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.85);
            border-radius: 8px;
            border-left: 4px solid;
            font-size: 0.9rem;
            z-index: 160;
            animation: itemNotify 2s ease-out forwards;
        }
        
        @keyframes itemNotify {
            0% { opacity: 0; transform: translateX(-50%) translateY(20px); }
            15% { opacity: 1; transform: translateX(-50%) translateY(0); }
            85% { opacity: 1; }
            100% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
        }
        
        /* Mobile */
        @media (max-width: 600px) {
            .character-display { width: 240px; padding: 15px; }
            .char-preview { width: 90px; height: 90px; }
            .city-card { width: 130px; padding: 12px; }
            .upgrade-card { width: 130px; padding: 10px; }
            .hud-bar { width: 130px; height: 18px; }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <!-- Main Menu -->
    <div id="mainMenu">
        <h1 class="menu-title">ÿ∞Ÿáÿ® ÿ£ÿµŸÅÿ± ÿ£Ÿà ÿØŸÖ ÿ£ÿ≠ŸÖÿ±</h1>
        <p class="menu-subtitle">ÿßŸÇÿ™ŸÑ ÿßŸÑÿ™ŸÜŸäŸÜ ÿßŸÑÿµÿ≠ÿ±ÿßŸàŸä ŸÅŸä 10 ÿØŸÇÿßÿ¶ŸÇ!</p>
        
        <!-- Character Selection -->
        <div class="character-select">
            <button class="char-arrow" id="charPrev">‚Üí</button>
            <div class="character-display">
                <canvas class="char-preview" id="charPreview" width="120" height="120"></canvas>
                <div class="char-name" id="charName">ÿ£ÿ®Ÿà ÿ≥ŸÑŸäŸÖÿßŸÜ</div>
                <div class="char-title" id="charTitle">ÿßŸÑÿ™ÿßÿ¨ÿ± ÿßŸÑÿ´ÿ±Ÿä</div>
                <div class="char-desc" id="charDesc">ÿ™ÿßÿ¨ÿ± ÿ´ÿ±Ÿä Ÿäÿ≠ÿ® ÿßŸÑÿ∞Ÿáÿ® ÿ£ŸÉÿ´ÿ± ŸÖŸÜ ÿ£Ÿä ÿ¥Ÿäÿ°</div>
                <div class="char-stats" id="charStats"></div>
                <div class="char-weapon" id="charWeapon">üó°Ô∏è ÿßŸÑÿπŸÇÿßŸÑ</div>
            </div>
            <button class="char-arrow" id="charNext">‚Üê</button>
        </div>
        
        <!-- City Selection -->
        <div class="city-select">
            <div class="city-card selected" id="cityBadaya" data-city="badaya">
                <div class="city-icon">üèúÔ∏è</div>
                <div class="city-name">ÿßŸÑÿ®ÿØÿßÿ¶ÿπ</div>
                <div class="city-desc">ÿµÿ≠ÿ±ÿßÿ° ŸàŸÜÿÆŸäŸÑ</div>
            </div>
            <div class="city-card locked" id="cityBaghdad" data-city="baghdad">
                <div class="city-icon">üèõÔ∏è</div>
                <div class="city-name">ÿ®ÿ∫ÿØÿßÿØ</div>
                <div class="city-desc">ŸÖÿØŸäŸÜÿ© ÿ≠ÿ∂ÿßÿ±Ÿäÿ©</div>
                <div class="city-locked">üîí ÿßŸÇÿ™ŸÑ ÿßŸÑÿ™ŸÜŸäŸÜ ÿ£ŸàŸÑÿßŸã</div>
            </div>
        </div>
        
        <button class="btn btn-primary" id="startBtn">ÿßÿ®ÿØÿ£ ÿßŸÑŸÑÿπÿ®</button>
        <p class="high-score">ÿ£ÿπŸÑŸâ ŸÜÿ™Ÿäÿ¨ÿ©: <span id="highScore">0</span> ŸÇÿ™ŸäŸÑ</p>
    </div>
    
    <!-- HUD -->
    <div id="hud">
        <div class="hud-left">
            <div class="hud-bar">
                <div class="hud-bar-fill health-fill" id="healthBar" style="width: 100%"></div>
                <span class="hud-bar-text" id="healthText">100/100</span>
            </div>
            <div class="hud-bar">
                <div class="hud-bar-fill xp-fill" id="xpBar" style="width: 0%"></div>
                <span class="hud-bar-text" id="xpText">0/10</span>
            </div>
            <span class="hud-stat level-text" id="levelText">ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ: 1</span>
        </div>
        <div class="hud-right">
            <span class="hud-stat gold-text">üí∞ <span id="goldText">0</span></span>
            <span class="hud-stat kill-text">üíÄ <span id="killText">0</span></span>
            <span class="hud-stat" id="timerText">‚è±Ô∏è 00:00</span>
        </div>
    </div>
    
    <!-- Equipment Slots -->
    <div class="equipment-slots" id="equipmentSlots">
        <div class="slot-group" id="weaponSlots"></div>
        <div class="slot-group" id="bookSlots"></div>
    </div>
    
    <!-- Level Up Modal -->
    <div id="levelUpModal">
        <div class="level-up-content">
            <h2 class="level-up-title">üéâ ŸÖÿ≥ÿ™ŸàŸâ ÿ¨ÿØŸäÿØ! üéâ</h2>
            <div class="upgrade-options" id="upgradeOptions"></div>
        </div>
    </div>
    
    <!-- Game Over Screen -->
    <div id="gameOverScreen">
        <h1 class="game-over-title" id="gameOverTitle">ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑŸÑÿπÿ®ÿ©</h1>
        <div class="unlock-message" id="unlockMessage" style="display: none;"></div>
        <div class="final-stats" id="finalStats"></div>
        <button class="btn btn-primary" id="restartBtn">ÿßŸÑÿπÿ® ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ</button>
    </div>
    
    <!-- Boss Warning -->
    <div id="bossWarning">‚ö†Ô∏è ÿ™ÿ≠ÿ∞Ÿäÿ±! ‚ö†Ô∏è<br><span style="font-size: 1.2rem;">ÿßŸÑÿ™ŸÜŸäŸÜ ÿßŸÑÿµÿ≠ÿ±ÿßŸàŸä ŸÇÿßÿØŸÖ!</span></div>
    
    <!-- Pause Indicator -->
    <div id="pauseIndicator">‚è∏Ô∏è ÿ•ŸäŸÇÿßŸÅ ŸÖÿ§ŸÇÿ™</div>

    <script>
// ==================== GAME CONFIG ====================
const CONFIG = {
    WORLD_SIZE: 4000,
    TILE_SIZE: 64,
    PLAYER_LIGHT_RADIUS: 300,
    MAX_WEAPONS: 4,
    MAX_BOOKS: 4,
    MAX_UPGRADE_LEVEL: 20,
    BOSS_TIME: 600,
    
    // Base enemy stats
    BASE_ENEMY_HP: 7,
    BASE_ENEMY_ATTACK: 5,
    BASE_ENEMY_SPEED: 60,
    BASE_ENEMY_ATTACK_SPEED: 0.8,
    
    // Scaling per minute (20%)
    SCALING_PER_MINUTE: 0.20,
    
    // Base weapon damage
    BASE_WEAPON_DAMAGE: 5
};

// ==================== RARITY SYSTEM ====================
const RARITY = {
    COMMON: { name: 'ÿ¥ÿßÿ¶ÿπ', nameEn: 'common', color: '#9d9d9d', bonus: 1, weight: 50 },
    UNCOMMON: { name: 'ÿ∫Ÿäÿ± ÿ¥ÿßÿ¶ÿπ', nameEn: 'uncommon', color: '#1eff00', bonus: 2, weight: 25 },
    RARE: { name: 'ŸÜÿßÿØÿ±', nameEn: 'rare', color: '#0070dd', bonus: 3, weight: 13 },
    EPIC: { name: 'ŸÖŸÑÿ≠ŸÖŸä', nameEn: 'epic', color: '#a335ee', bonus: 4, weight: 7 },
    LEGENDARY: { name: 'ÿ£ÿ≥ÿ∑Ÿàÿ±Ÿä', nameEn: 'legendary', color: '#ff8000', bonus: 5, weight: 5 }
};

function getRandomRarity() {
    const total = Object.values(RARITY).reduce((s, r) => s + r.weight, 0);
    let rand = Math.random() * total;
    for (const r of Object.values(RARITY)) {
        rand -= r.weight;
        if (rand <= 0) return r;
    }
    return RARITY.COMMON;
}

// ==================== CHARACTERS ====================
const CHARACTERS = {
    abuSulaiman: {
        name: 'ÿ£ÿ®Ÿà ÿ≥ŸÑŸäŸÖÿßŸÜ',
        title: 'ÿßŸÑÿ™ÿßÿ¨ÿ± ÿßŸÑÿ´ÿ±Ÿä',
        desc: 'ÿ™ÿßÿ¨ÿ± ÿ´ÿ±Ÿä Ÿäÿ≠ÿ® ÿßŸÑÿ∞Ÿáÿ® ÿ£ŸÉÿ´ÿ± ŸÖŸÜ ÿ£Ÿä ÿ¥Ÿäÿ° ŸÅŸä ÿßŸÑÿØŸÜŸäÿß',
        weapon: 'agal',
        stats: { gold: 1.25, luck: 1.1, hp: 100, speed: 200, crit: 0, enemyBuff: 0 },
        passiveText: ['+25% ÿ∞Ÿáÿ®', '+10% ÿ≠ÿ∏'],
        colors: { body: '#f5f5f5', head: '#cc0000', skin: '#d4a574', acc: '#8b6914' }
    },
    jayzen: {
        name: 'ÿ¨Ÿäÿ≤ÿßŸÜ',
        title: 'ÿßŸÑŸÖŸÇÿßÿ™ŸÑ ÿßŸÑÿ¥ÿ±ÿ≥',
        desc: 'ŸÖŸÇÿßÿ™ŸÑ ÿπŸÜŸäÿØ ŸÑÿß ŸäÿÆÿßŸÅ ÿßŸÑŸÖŸàÿ™ÿå ÿµÿπÿ® ÿßŸÑŸÖÿ±ÿßÿ≥',
        weapon: 'rock',
        stats: { gold: 1, luck: 1, hp: 115, speed: 200, damageReduction: 0.3, crit: 0, enemyBuff: 0 },
        passiveText: ['-30% ÿ∂ÿ±ÿ± ŸÖÿ≥ÿ™ŸÑŸÖ', '+15% ÿµÿ≠ÿ©'],
        colors: { body: '#6a1b9a', head: '#cc3333', skin: '#d4a574', acc: '#333' }
    },
    noura: {
        name: 'ŸÜŸàÿ±ÿ©',
        title: 'ÿßŸÑŸÖÿ±ÿ£ÿ© ÿßŸÑŸÇŸàŸäÿ©',
        desc: 'ÿßŸÖÿ±ÿ£ÿ© ŸÇŸàŸäÿ© Ÿàÿ∞ŸÉŸäÿ©ÿå ÿ™ÿ¨ŸÖÿπ ŸÉŸÑ ÿ¥Ÿäÿ° ÿ≠ŸàŸÑŸáÿß',
        weapon: 'aura',
        stats: { gold: 1, luck: 1, hp: 100, speed: 200, pickup: 2.5, xpMult: 1.2, crit: 0, enemyBuff: 0 },
        passiveText: ['+150% ŸÖÿ∫ŸÜÿßÿ∑Ÿäÿ≥', '+20% ÿÆÿ®ÿ±ÿ©'],
        colors: { body: '#1e88e5', head: '#f5f5f5', skin: '#e8d5c4', acc: '#1565c0' }
    },
    bedouin: {
        name: 'ÿßŸÑÿßÿπÿ±ÿßÿ®Ÿä',
        title: 'ÿ®ÿØŸàŸä ÿ∫ÿØÿßÿ±',
        desc: 'ÿ®ÿØŸàŸä Ÿàÿ∫ÿØÿßÿ±ÿå ÿßŸÑŸÑŸá Ÿäÿ±ÿ≠ŸÖ ŸÖŸÜ ÿ∑ŸÑÿπŸáŸÖ ŸÖŸÜ ÿÆŸäÿßŸÖŸáŸÖ',
        weapon: 'spear',
        stats: { gold: 1, luck: 1, hp: 90, speed: 220, crit: 0.20, enemyBuff: 0 },
        passiveText: ['+20% ÿ∂ÿ±ÿ®ÿ© ÿ≠ÿ±ÿ¨ÿ©', '+10% ÿ≥ÿ±ÿπÿ©'],
        colors: { body: '#8b4513', head: '#d2691e', skin: '#c4956a', acc: '#2f1810' }
    },
    hawshabi: {
        name: 'ÿßŸÑÿ≠Ÿàÿ¥ÿ®Ÿä',
        title: 'ÿµÿπŸàÿ®ÿ© ŸÖÿ™ŸÇÿØŸÖÿ©',
        desc: 'ÿßÿ∞ÿß ÿ™ÿ®Ÿä ÿ™ÿµÿπÿ® ÿßŸÑŸàÿ∂ÿπ ÿπŸÑŸäŸÉ ÿßŸÑÿπÿ® ŸÅŸäŸá Ÿàÿßÿ≠ÿ™ÿ≥ÿ® ÿßŸÑÿßÿ¨ÿ±',
        weapon: 'sword',
        stats: { gold: 1.5, luck: 1.2, hp: 80, speed: 180, crit: 0, enemyBuff: 0.20 },
        passiveText: ['+20% ŸÇŸàÿ© ÿßŸÑÿ£ÿπÿØÿßÿ°', '+50% ÿ∞Ÿáÿ®', '+20% ÿ≠ÿ∏'],
        colors: { body: '#4a0000', head: '#1a1a1a', skin: '#d4a574', acc: '#ffd700' }
    },
    layla: {
        name: 'ŸÑŸäŸÑŸâ',
        title: 'ÿßŸÑÿ≥ÿßÿ≠ÿ±ÿ©',
        desc: 'ÿ≥ÿßÿ≠ÿ±ÿ© ÿ∫ÿßŸÖÿ∂ÿ© ÿ™ÿ™ÿ≠ŸÉŸÖ ÿ®ÿßŸÑŸÜÿßÿ± ÿßŸÑÿ≤ÿ±ŸÇÿßÿ°',
        weapon: 'flame',
        stats: { gold: 1, luck: 1, hp: 85, speed: 210, cooldown: 0.8, range: 1.3, crit: 0, enemyBuff: 0 },
        passiveText: ['-20% ŸÉŸàŸÑÿØÿßŸàŸÜ', '+30% ŸÖÿØŸâ'],
        colors: { body: '#1a1a2e', head: '#4a0080', skin: '#e8d5c4', acc: '#00ffff' }
    }
};

// ==================== WEAPONS ====================
const WEAPONS = {
    agal: { name: 'ÿßŸÑÿπŸÇÿßŸÑ', desc: 'ÿ≠ÿ®ŸÑ ŸäÿØŸàÿ± ÿ≠ŸàŸÑŸÉ', type: 'orbit', baseDamage: 5, cooldown: 0.1, range: 70, icon: '‚≠ï' },
    rock: { name: 'ÿßŸÑÿµÿÆÿ±ÿ©', desc: 'ŸÇÿ∞ŸäŸÅÿ© ŸÑÿ£ŸÇÿ±ÿ® ÿπÿØŸà', type: 'projectile', baseDamage: 5, cooldown: 1.0, range: 400, icon: 'ü™®' },
    aura: { name: 'ÿßŸÑŸáŸäÿ®ÿ©', desc: 'ŸáÿßŸÑÿ© ÿ∂ÿ±ÿ± ÿÆŸÅŸäŸÅÿ©', type: 'aura', baseDamage: 4, cooldown: 0.5, range: 60, icon: 'üí´' },
    spear: { name: 'ÿßŸÑÿ±ŸÖÿ≠', desc: 'Ÿäÿ±ŸÖŸä ŸÑÿ£ŸÇÿ±ÿ® ÿπÿØŸà', type: 'projectile', baseDamage: 5, cooldown: 0.5, range: 350, icon: 'üî±' },
    sword: { name: 'ÿßŸÑÿ≥ŸäŸÅ', desc: 'ÿ∂ÿ±ÿ®ÿ© ÿ£ŸÖÿßŸÖŸäÿ©', type: 'melee', baseDamage: 5, cooldown: 0.7, range: 80, icon: '‚öîÔ∏è' },
    flame: { name: 'ÿßŸÑÿ¥ÿπŸÑÿ©', desc: 'ŸÜÿßÿ± ŸÑÿ£ŸÇÿ±ÿ® ÿπÿØŸà', type: 'projectile', baseDamage: 5, cooldown: 0.35, range: 300, icon: 'üî•' },
    arrows: { name: 'ÿßŸÑÿ≥ŸáÿßŸÖ', desc: 'ÿ≥ŸáÿßŸÖ ÿ®ŸÉŸÑ ÿßÿ™ÿ¨ÿßŸá', type: 'radial', baseDamage: 4, cooldown: 0.9, range: 350, icon: 'üèπ' },
    lightning: { name: 'ÿßŸÑÿ®ÿ±ŸÇ', desc: 'ÿµÿßÿπŸÇÿ© ÿπÿ¥Ÿàÿßÿ¶Ÿäÿ©', type: 'lightning', baseDamage: 5, cooldown: 2.0, range: 450, icon: '‚ö°' },
    tornado: { name: 'ÿßŸÑÿØŸàÿßŸÖÿ©', desc: 'ÿ™ÿ®ÿ∑ÿ¶ ÿßŸÑÿ£ÿπÿØÿßÿ°', type: 'tornado', baseDamage: 4, cooldown: 2.5, range: 180, icon: 'üå™Ô∏è' },
    meteor: { name: 'ÿßŸÑŸÜŸäÿ≤ŸÉ', desc: 'ÿµÿÆŸàÿ± ŸÖŸÜ ÿßŸÑÿ≥ŸÖÿßÿ°', type: 'meteor', baseDamage: 5, cooldown: 1.8, range: 100, icon: '‚òÑÔ∏è' }
};

// ==================== BOOKS ====================
const BOOKS = {
    power: { name: 'ŸÉÿ™ÿßÿ® ÿßŸÑŸÇŸàÿ©', desc: 'Ÿäÿ≤ŸäÿØ ÿßŸÑÿ∂ÿ±ÿ±', stat: 'damage', baseValue: 0.08, icon: 'üìï' },
    speed: { name: 'ŸÉÿ™ÿßÿ® ÿßŸÑÿ≥ÿ±ÿπÿ©', desc: 'ÿ≥ÿ±ÿπÿ© ÿßŸÑŸáÿ¨ŸàŸÖ', stat: 'attackSpeed', baseValue: 0.06, icon: 'üìó' },
    wind: { name: 'ŸÉÿ™ÿßÿ® ÿßŸÑÿ±Ÿäÿ≠', desc: 'ÿ≥ÿ±ÿπÿ© ÿßŸÑÿ≠ÿ±ŸÉÿ©', stat: 'moveSpeed', baseValue: 0.05, icon: 'üìò' },
    wisdom: { name: 'ŸÉÿ™ÿßÿ® ÿßŸÑÿ≠ŸÉŸÖÿ©', desc: 'ÿÆÿ®ÿ±ÿ© ÿ£ŸÉÿ´ÿ±', stat: 'xpGain', baseValue: 0.10, icon: 'üìô' },
    life: { name: 'ŸÉÿ™ÿßÿ® ÿßŸÑÿ≠Ÿäÿßÿ©', desc: 'ÿµÿ≠ÿ© ÿ£ŸÉÿ´ÿ±', stat: 'maxHealth', baseValue: 0.08, icon: 'üìì' },
    armor: { name: 'ŸÉÿ™ÿßÿ® ÿßŸÑÿØÿ±ÿπ', desc: 'ÿ∂ÿ±ÿ± ÿ£ŸÇŸÑ', stat: 'armor', baseValue: 0.04, icon: 'üìî' },
    magnet: { name: 'ŸÉÿ™ÿßÿ® ÿßŸÑŸÖÿ∫ŸÜÿßÿ∑Ÿäÿ≥', desc: 'ÿ¨ŸÖÿπ ÿ£ÿ≥ŸáŸÑ', stat: 'pickup', baseValue: 0.12, icon: 'üìí' },
    luck: { name: 'ŸÉÿ™ÿßÿ® ÿßŸÑÿ≠ÿ∏', desc: 'ÿØÿ±Ÿàÿ® ÿ£ŸÅÿ∂ŸÑ', stat: 'luck', baseValue: 0.06, icon: 'üìö' },
    curse: { name: 'ŸÉÿ™ÿßÿ® ÿßŸÑŸÑÿπŸÜÿ©', desc: 'ÿ£ÿπÿØÿßÿ° ÿ£ŸÉÿ´ÿ±ÿå ÿÆÿ®ÿ±ÿ© ÿ£ŸÉÿ´ÿ±', stat: 'curse', baseValue: 0.15, icon: 'üìñ' },
    regen: { name: 'ŸÉÿ™ÿßÿ® ÿßŸÑÿ™ÿ¨ÿØŸäÿØ', desc: 'ÿ¥ŸÅÿßÿ° ŸÖÿ≥ÿ™ŸÖÿ±', stat: 'regen', baseValue: 0.8, icon: 'üìú' }
};

// ==================== ITEMS ====================
const ITEMS = {
    bread: { name: 'ÿÆÿ®ÿ≤', rarity: 'COMMON', effect: 'heal', value: 8, icon: 'üçû' },
    feather: { name: 'ÿ±Ÿäÿ¥ÿ©', rarity: 'COMMON', effect: 'tempSpeed', value: 0.15, duration: 10, icon: 'ü™∂' },
    pebble: { name: 'ÿ≠ÿµÿßÿ©', rarity: 'COMMON', effect: 'tempDamage', value: 0.1, duration: 12, icon: 'ü™®' },
    herb: { name: 'ÿπÿ¥ÿ®ÿ©', rarity: 'COMMON', effect: 'heal', value: 5, icon: 'üåø' },
    copper: { name: 'ŸÜÿ≠ÿßÿ≥', rarity: 'COMMON', effect: 'gold', value: 5, icon: 'ü™ô' },
    redPotion: { name: 'ÿ¨ÿ±ÿπÿ© ÿ≠ŸÖÿ±ÿßÿ°', rarity: 'RARE', effect: 'heal', value: 25, icon: 'üß™' },
    bluePotion: { name: 'ÿ¨ÿ±ÿπÿ© ÿ≤ÿ±ŸÇÿßÿ°', rarity: 'RARE', effect: 'tempAttackSpeed', value: 0.3, duration: 15, icon: 'üß¥' },
    amulet: { name: 'ÿ™ŸÖŸäŸÖÿ©', rarity: 'RARE', effect: 'shield', value: 15, icon: 'üìø' },
    hourglass: { name: 'ÿ≥ÿßÿπÿ© ÿ±ŸÖŸÑŸäÿ©', rarity: 'RARE', effect: 'slow', value: 0.5, duration: 4, icon: '‚è≥' },
    silver: { name: 'ŸÅÿ∂ÿ©', rarity: 'RARE', effect: 'gold', value: 20, icon: 'ü•à' },
    elixir: { name: 'ÿ•ŸÉÿ≥Ÿäÿ±', rarity: 'LEGENDARY', effect: 'fullHeal', value: 15, icon: '‚öóÔ∏è' },
    dragonHeart: { name: 'ŸÇŸÑÿ® ÿßŸÑÿ™ŸÜŸäŸÜ', rarity: 'LEGENDARY', effect: 'tempDamage', value: 0.5, duration: 25, icon: '‚ù§Ô∏è‚Äçüî•' },
    phoenixEye: { name: 'ÿπŸäŸÜ ÿßŸÑÿπŸÜŸÇÿßÿ°', rarity: 'LEGENDARY', effect: 'revive', value: 1, icon: 'üëÅÔ∏è' },
    crown: { name: 'ÿ™ÿßÿ¨ ÿ∞Ÿáÿ®Ÿä', rarity: 'LEGENDARY', effect: 'permGold', value: 0.5, icon: 'üëë' },
    star: { name: 'ŸÜÿ¨ŸÖÿ©', rarity: 'LEGENDARY', effect: 'randomEquip', value: 1, icon: '‚≠ê' }
};

// ==================== ENEMIES ====================
const ENEMIES = {
    wolf: { name: 'ÿ∞ÿ¶ÿ®', hpMult: 1, atkMult: 1, speedMult: 1.2, xp: 2, time: 0, color: '#6a6a6a' },
    scorpion: { name: 'ÿπŸÇÿ±ÿ®', hpMult: 0.7, atkMult: 0.8, speedMult: 1.5, xp: 2, time: 0, color: '#ffa500' },
    dhub: { name: 'ÿ∂ÿ®', hpMult: 2, atkMult: 1.2, speedMult: 0.6, xp: 4, time: 60, color: '#5a8a5a', zigzag: true },
    snake: { name: 'ÿ´ÿπÿ®ÿßŸÜ', hpMult: 1.2, atkMult: 1, speedMult: 1, xp: 3, time: 120, color: '#2d5a27', ranged: true },
    hyena: { name: 'ÿ∂ÿ®ÿπ', hpMult: 0.8, atkMult: 0.9, speedMult: 1.3, xp: 2, time: 180, color: '#8b7355', pack: true },
    eagle: { name: 'ŸÜÿ≥ÿ±', hpMult: 1, atkMult: 1.3, speedMult: 1.6, xp: 4, time: 240, color: '#4a3728' },
    lion: { name: 'ÿ£ÿ≥ÿØ', hpMult: 3, atkMult: 2, speedMult: 0.8, xp: 8, time: 300, color: '#c4a35a' },
    djinn: { name: 'ÿ¨ŸÜŸä', hpMult: 1.5, atkMult: 1.5, speedMult: 1.4, xp: 6, time: 360, color: '#4a0080', teleport: true },
    ghoul: { name: 'ÿ∫ŸàŸÑ', hpMult: 5, atkMult: 2.5, speedMult: 0.5, xp: 12, time: 420, color: '#2a2a2a' },
    knight: { name: 'ŸÅÿßÿ±ÿ≥', hpMult: 2.5, atkMult: 1.8, speedMult: 1, xp: 10, time: 480, color: '#1a1a1a' }
};

const BOSS = { name: 'ÿßŸÑÿ™ŸÜŸäŸÜ ÿßŸÑÿµÿ≠ÿ±ÿßŸàŸä', hp: 8000, damage: 35, speed: 55, color: '#8b0000' };

// ==================== CITIES ====================
const CITIES = {
    badaya: { name: 'ÿßŸÑÿ®ÿØÿßÿ¶ÿπ', bg: '#d4b896', accent: '#2d5016', locked: false },
    baghdad: { name: 'ÿ®ÿ∫ÿØÿßÿØ', bg: '#8fbc8f', accent: '#4a6741', locked: true }
};

// ==================== AUDIO ====================
class Audio {
    constructor() { this.ctx = null; }
    init() { if (!this.ctx) try { this.ctx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e) {} }
    tone(f, d, t='square', v=0.15) {
        if (!this.ctx) return;
        const o = this.ctx.createOscillator(), g = this.ctx.createGain();
        o.type = t; o.frequency.value = f; o.connect(g); g.connect(this.ctx.destination);
        g.gain.setValueAtTime(v, this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + d);
        o.start(); o.stop(this.ctx.currentTime + d);
    }
    hit() { this.tone(150, 0.12, 'sawtooth', 0.2); }
    shoot() { this.tone(350, 0.04); }
    pickup() { this.tone(550, 0.04, 'sine'); }
    levelUp() { [523,659,784,1047].forEach((f,i) => setTimeout(() => this.tone(f,0.12,'sine',0.2), i*70)); }
    victory() { [523,659,784,880,1047].forEach((f,i) => setTimeout(() => this.tone(f,0.2,'sine',0.25), i*120)); }
    death() { this.tone(180, 0.25, 'sawtooth'); this.tone(90, 0.3, 'sawtooth'); }
    bossWarn() { this.tone(90, 0.4, 'sawtooth', 0.3); setTimeout(() => this.tone(70, 0.4, 'sawtooth', 0.3), 500); }
}

// ==================== PARTICLES ====================
class Particles {
    constructor() { this.list = []; this.stains = []; }
    emit(x, y, n, opt = {}) {
        for (let i = 0; i < n; i++) {
            const a = Math.random() * Math.PI * 2;
            const s = (opt.minS || 40) + Math.random() * ((opt.maxS || 120) - (opt.minS || 40));
            this.list.push({
                x, y, vx: Math.cos(a) * s, vy: Math.sin(a) * s,
                color: opt.color || '#fff', size: (opt.minSz || 2) + Math.random() * 3,
                life: (opt.minL || 0.3) + Math.random() * 0.5, maxLife: 0.8, gravity: opt.gravity || 0
            });
        }
    }
    blood(x, y) {
        this.emit(x, y, 10, { color: '#8b0000', minS: 40, maxS: 150, gravity: 180 });
        this.stains.push({ x, y, size: 6 + Math.random() * 10 });
        if (this.stains.length > 120) this.stains.shift();
    }
    update(dt) {
        this.list = this.list.filter(p => {
            p.x += p.vx * dt; p.y += p.vy * dt; p.vy += p.gravity * dt; p.life -= dt;
            return p.life > 0;
        });
    }
    draw(ctx, cam) {
        ctx.fillStyle = '#4a0000';
        for (const s of this.stains) { ctx.globalAlpha = 0.35; ctx.beginPath(); ctx.arc(s.x - cam.x, s.y - cam.y, s.size, 0, Math.PI * 2); ctx.fill(); }
        for (const p of this.list) { ctx.globalAlpha = p.life / p.maxLife; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x - cam.x, p.y - cam.y, p.size, 0, Math.PI * 2); ctx.fill(); }
        ctx.globalAlpha = 1;
    }
}

// ==================== FLOATING TEXT ====================
class FloatText {
    constructor(x, y, text, color = '#fff', size = 16) {
        this.x = x; this.y = y; this.text = text; this.color = color; this.size = size; this.life = 0.8; this.vy = -50;
    }
    update(dt) { this.y += this.vy * dt; this.life -= dt; }
    draw(ctx, cam) {
        ctx.globalAlpha = this.life / 0.8;
        ctx.fillStyle = this.color; ctx.font = `bold ${this.size}px Cairo`; ctx.textAlign = 'center';
        ctx.fillText(this.text, this.x - cam.x, this.y - cam.y);
        ctx.globalAlpha = 1;
    }
}

// ==================== PLAYER ====================
class Player {
    constructor(x, y, charId) {
        this.x = x; this.y = y; this.charId = charId;
        const c = CHARACTERS[charId];
        this.maxHp = c.stats.hp || 100;
        this.hp = this.maxHp;
        this.speed = c.stats.speed || 200;
        this.damage = 1;
        this.attackSpeed = 1;
        this.pickupRange = 45 * (c.stats.pickup || 1);
        this.xpMult = c.stats.xpMult || 1;
        this.goldMult = c.stats.gold || 1;
        this.damageReduction = c.stats.damageReduction || 0;
        this.luck = c.stats.luck || 1;
        this.crit = c.stats.crit || 0;
        this.enemyBuff = c.stats.enemyBuff || 0;
        this.armor = 0;
        this.regen = 0;
        this.curse = 0;
        this.range = c.stats.range || 1;
        this.cooldownMult = c.stats.cooldown || 1;
        
        this.weapons = [{ id: c.weapon, level: 1, upgrades: [] }];
        this.books = [];
        
        this.xp = 0; this.level = 1; this.gold = 0; this.kills = 0;
        this.invuln = 0; this.facing = 1; this.vx = 0; this.vy = 0; this.anim = 0;
        this.shield = 0; this.hasRevive = false; this.tempBuffs = [];
        this.weaponTimers = {};
        this.width = 36; this.height = 50;
    }
    
    getDamage(w) {
        let dmg = CONFIG.BASE_WEAPON_DAMAGE;
        // Add level bonus
        dmg += (w.level - 1) * 0.5;
        // Add rarity bonuses
        w.upgrades.forEach(u => dmg += u.rarity.bonus);
        // Multiply by player damage stat
        dmg *= this.damage;
        // Temp buffs
        this.tempBuffs.filter(b => b.type === 'damage').forEach(b => dmg *= (1 + b.value));
        // Crit
        if (this.crit > 0 && Math.random() < this.crit) {
            dmg *= 2;
        }
        return dmg;
    }
    
    getCooldown(w) {
        const base = WEAPONS[w.id].cooldown;
        let mult = this.cooldownMult / this.attackSpeed;
        this.tempBuffs.filter(b => b.type === 'attackSpeed').forEach(b => mult /= (1 + b.value));
        return Math.max(0.1, base * mult * (1 - (w.level - 1) * 0.02));
    }
    
    getRange(w) { return WEAPONS[w.id].range * this.range * (1 + (w.level - 1) * 0.03); }
    
    findNearestEnemy(game, maxDist = 500) {
        let nearest = null, minD = maxDist;
        for (const e of game.enemies) {
            const d = Math.hypot(e.x - this.x, e.y - this.y);
            if (d < minD) { minD = d; nearest = e; }
        }
        if (game.boss) {
            const d = Math.hypot(game.boss.x - this.x, game.boss.y - this.y);
            if (d < minD) { minD = d; nearest = game.boss; }
        }
        return nearest;
    }
    
    update(dt, input, game) {
        let dx = 0, dy = 0;
        if (input.left) dx -= 1; if (input.right) dx += 1;
        if (input.up) dy -= 1; if (input.down) dy += 1;
        if (input.joy) { dx += input.joy.x; dy += input.joy.y; }
        
        const mag = Math.hypot(dx, dy);
        if (mag > 0) {
            dx /= mag; dy /= mag;
            let spd = this.speed;
            this.tempBuffs.filter(b => b.type === 'speed').forEach(b => spd *= (1 + b.value));
            this.vx = dx * spd; this.vy = dy * spd;
            if (dx !== 0) this.facing = dx > 0 ? 1 : -1;
        } else { this.vx = 0; this.vy = 0; }
        
        this.x += this.vx * dt; this.y += this.vy * dt;
        this.x = Math.max(-CONFIG.WORLD_SIZE/2, Math.min(CONFIG.WORLD_SIZE/2, this.x));
        this.y = Math.max(-CONFIG.WORLD_SIZE/2, Math.min(CONFIG.WORLD_SIZE/2, this.y));
        
        if (this.invuln > 0) this.invuln -= dt;
        this.anim += dt;
        
        if (this.regen > 0) this.hp = Math.min(this.maxHp, this.hp + this.regen * dt);
        
        this.tempBuffs = this.tempBuffs.filter(b => { b.duration -= dt; return b.duration > 0; });
        
        // Fire weapons - target nearest enemy
        const target = this.findNearestEnemy(game);
        
        this.weapons.forEach(w => {
            if (!this.weaponTimers[w.id]) this.weaponTimers[w.id] = 0;
            this.weaponTimers[w.id] -= dt;
            if (this.weaponTimers[w.id] <= 0) {
                this.fire(w, game, target);
                this.weaponTimers[w.id] = this.getCooldown(w);
            }
        });
    }
    
    fire(w, game, target) {
        const data = WEAPONS[w.id];
        const dmg = this.getDamage(w);
        const range = this.getRange(w);
        
        switch(data.type) {
            case 'projectile': {
                if (target && Math.hypot(target.x - this.x, target.y - this.y) < range) {
                    const a = Math.atan2(target.y - this.y, target.x - this.x);
                    game.projectiles.push({ x: this.x, y: this.y, vx: Math.cos(a) * 380, vy: Math.sin(a) * 380, dmg, life: 2.5, size: 7, color: data.icon === 'üî•' ? '#ff4500' : '#8b4513', pierce: w.level > 10 ? 2 : 1 });
                    game.audio.shoot();
                }
                break;
            }
            case 'radial': {
                const n = 4 + Math.floor(w.level / 4);
                for (let i = 0; i < n; i++) {
                    const a = (i / n) * Math.PI * 2;
                    game.projectiles.push({ x: this.x, y: this.y, vx: Math.cos(a) * 320, vy: Math.sin(a) * 320, dmg: dmg * 0.7, life: 2, size: 5, color: '#4a2800' });
                }
                game.audio.shoot();
                break;
            }
            case 'lightning': {
                const targets = game.enemies.filter(e => Math.hypot(e.x - this.x, e.y - this.y) < range);
                if (targets.length > 0) {
                    const t = targets[Math.floor(Math.random() * targets.length)];
                    game.effects.push({ type: 'lightning', x: t.x, y: t.y, life: 0.25 });
                    if (t.takeDamage(dmg, game)) game.killEnemy(t);
                    game.audio.tone(700, 0.08, 'sawtooth');
                }
                break;
            }
            case 'meteor': {
                const n = 1 + Math.floor(w.level / 4);
                for (let i = 0; i < n; i++) {
                    game.effects.push({
                        type: 'meteor', x: this.x + (Math.random() - 0.5) * range * 2, y: this.y + (Math.random() - 0.5) * range * 2,
                        dmg, radius: 55, life: 0.8, delay: i * 0.15, hit: false
                    });
                }
                break;
            }
            case 'tornado': {
                game.effects.push({
                    type: 'tornado', x: this.x + this.facing * 40, y: this.y, vx: this.facing * 90, vy: 0,
                    dmg: dmg * 0.4, slow: 0.5, life: 3.5 + w.level * 0.15, radius: 35
                });
                break;
            }
        }
    }
    
    takeDamage(amt, game) {
        if (this.invuln > 0) return;
        if (this.shield > 0) { const ab = Math.min(this.shield, amt); this.shield -= ab; amt -= ab; if (amt <= 0) return; }
        const actual = amt * (1 - this.damageReduction) * (1 - Math.min(0.7, this.armor * 0.025));
        this.hp -= actual;
        this.invuln = 0.4;
        game.audio.hit();
        game.shake = 0.15;
        game.texts.push(new FloatText(this.x, this.y - 25, `-${Math.round(actual)}`, '#f00'));
        if (this.hp <= 0) {
            if (this.hasRevive) { this.hasRevive = false; this.hp = this.maxHp * 0.5; this.invuln = 1.5; game.texts.push(new FloatText(this.x, this.y - 40, 'ÿ•ÿ≠Ÿäÿßÿ°!', '#ffd700', 20)); }
            else game.over(false);
        }
    }
    
    draw(ctx, cam) {
        const sx = this.x - cam.x, sy = this.y - cam.y;
        if (this.invuln > 0 && Math.floor(this.invuln * 12) % 2 === 0) ctx.globalAlpha = 0.4;
        
        // Draw character sprite
        const c = CHARACTERS[this.charId].colors;
        ctx.save();
        if (this.facing < 0) { ctx.translate(sx, sy); ctx.scale(-1, 1); ctx.translate(-sx, sy); }
        
        // Body
        ctx.fillStyle = c.body;
        ctx.fillRect(sx - 12, sy - 10, 24, 30);
        
        // Head/Headwear
        ctx.fillStyle = c.head;
        ctx.fillRect(sx - 10, sy - 28, 20, 10);
        
        // Face
        ctx.fillStyle = c.skin;
        ctx.fillRect(sx - 8, sy - 18, 16, 12);
        
        // Eyes
        ctx.fillStyle = '#000';
        ctx.fillRect(sx - 5, sy - 15, 3, 3);
        ctx.fillRect(sx + 2, sy - 15, 3, 3);
        
        // Legs
        ctx.fillStyle = c.acc;
        ctx.fillRect(sx - 8, sy + 20, 6, 10);
        ctx.fillRect(sx + 2, sy + 20, 6, 10);
        
        ctx.restore();
        ctx.globalAlpha = 1;
        
        // Weapon effects
        this.weapons.forEach(w => {
            const data = WEAPONS[w.id];
            const range = this.getRange(w);
            
            if (data.type === 'orbit') {
                const n = 5 + Math.floor(w.level / 4);
                ctx.fillStyle = '#222';
                for (let i = 0; i < n; i++) {
                    const a = this.anim * 2.5 + (i / n) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.arc(sx + Math.cos(a) * range, sy + Math.sin(a) * range, 3 + w.level * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (data.type === 'aura') {
                const r = range + Math.sin(this.anim * 3) * 5;
                ctx.strokeStyle = 'rgba(100, 50, 150, 0.25)';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(sx, sy, r, 0, Math.PI * 2);
                ctx.stroke();
            } else if (data.type === 'melee') {
                const timer = this.weaponTimers[w.id] || 0;
                const cd = this.getCooldown(w);
                if (timer > cd * 0.75) {
                    ctx.strokeStyle = 'rgba(180, 180, 180, 0.4)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(sx, sy, range, -0.4 * this.facing, 0.4 * this.facing);
                    ctx.stroke();
                }
            }
        });
        
        // Shield
        if (this.shield > 0) {
            ctx.strokeStyle = 'rgba(100, 180, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(sx, sy, 30, 0, Math.PI * 2);
            ctx.stroke();
        }
    }
}

// ==================== ENEMY ====================
class Enemy {
    constructor(x, y, type, gameTime, enemyBuff = 0) {
        this.x = x; this.y = y; this.type = type;
        const e = ENEMIES[type];
        
        // Calculate stats based on time scaling
        const minutesPassed = gameTime / 60;
        const scale = 1 + minutesPassed * CONFIG.SCALING_PER_MINUTE;
        const buffScale = 1 + enemyBuff;
        
        this.maxHp = Math.round(CONFIG.BASE_ENEMY_HP * e.hpMult * scale * buffScale);
        this.hp = this.maxHp;
        this.atk = CONFIG.BASE_ENEMY_ATTACK * e.atkMult * scale * buffScale;
        this.speed = CONFIG.BASE_ENEMY_SPEED * e.speedMult;
        this.xp = e.xp;
        this.color = e.color;
        
        this.vx = 0; this.vy = 0;
        this.hitFlash = 0; this.slow = 1; this.slowTimer = 0;
        this.zigTimer = 0; this.zigDir = 1;
        this.teleTimer = 0; this.atkTimer = 0;
        this.width = 28; this.height = 28;
        
        this.zigzag = e.zigzag; this.ranged = e.ranged; this.teleport = e.teleport;
    }
    
    update(dt, player, enemies, game) {
        const dx = player.x - this.x, dy = player.y - this.y;
        const dist = Math.hypot(dx, dy);
        
        if (this.slowTimer > 0) { this.slowTimer -= dt; if (this.slowTimer <= 0) this.slow = 1; }
        
        if (dist > 0) {
            let mx = dx / dist, my = dy / dist;
            
            if (this.zigzag) {
                this.zigTimer += dt;
                if (this.zigTimer > 0.4) { this.zigTimer = 0; this.zigDir *= -1; }
                mx = mx * 0.7 + (-my * this.zigDir) * 0.3;
                my = my * 0.7 + (mx * this.zigDir) * 0.3;
            }
            
            if (this.teleport) {
                this.teleTimer += dt;
                if (this.teleTimer > 1.8 && dist > 80) {
                    this.teleTimer = 0;
                    const a = Math.random() * Math.PI * 2;
                    this.x = player.x + Math.cos(a) * 120;
                    this.y = player.y + Math.sin(a) * 120;
                    game.particles.emit(this.x, this.y, 8, { color: '#4a0080' });
                }
            }
            
            if (this.ranged && dist < 250 && dist > 60) {
                this.atkTimer -= dt;
                if (this.atkTimer <= 0) {
                    this.atkTimer = 1 / CONFIG.BASE_ENEMY_ATTACK_SPEED;
                    const a = Math.atan2(dy, dx);
                    game.enemyProj.push({ x: this.x, y: this.y, vx: Math.cos(a) * 180, vy: Math.sin(a) * 180, dmg: this.atk * 0.5, life: 2.5, size: 4, color: this.color });
                }
            }
            
            // Separation
            let sepX = 0, sepY = 0;
            for (const o of enemies) {
                if (o === this) continue;
                const ox = this.x - o.x, oy = this.y - o.y, od = Math.hypot(ox, oy);
                if (od < 30 && od > 0) { sepX += ox / od * (30 - od) / 30; sepY += oy / od * (30 - od) / 30; }
            }
            mx += sepX * 0.4; my += sepY * 0.4;
            
            const m = Math.hypot(mx, my);
            if (m > 0) { this.vx = (mx / m) * this.speed * this.slow; this.vy = (my / m) * this.speed * this.slow; }
        }
        
        this.x += this.vx * dt; this.y += this.vy * dt;
        if (this.hitFlash > 0) this.hitFlash -= dt;
    }
    
    takeDamage(amt, game) {
        this.hp -= amt; this.hitFlash = 0.08;
        game.texts.push(new FloatText(this.x + (Math.random() - 0.5) * 15, this.y - 15, Math.round(amt).toString(), '#ff0'));
        return this.hp <= 0;
    }
    
    draw(ctx, cam) {
        const sx = this.x - cam.x, sy = this.y - cam.y;
        if (this.hitFlash > 0) ctx.globalAlpha = 0.6;
        
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(sx, sy, 14, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#f00';
        ctx.fillRect(sx - 4, sy - 3, 3, 3);
        ctx.fillRect(sx + 1, sy - 3, 3, 3);
        
        ctx.globalAlpha = 1;
        
        if (this.hp < this.maxHp) {
            ctx.fillStyle = '#333';
            ctx.fillRect(sx - 15, sy - 22, 30, 4);
            ctx.fillStyle = '#f00';
            ctx.fillRect(sx - 15, sy - 22, 30 * (this.hp / this.maxHp), 4);
        }
    }
}

// ==================== BOSS ====================
class Boss {
    constructor(x, y, enemyBuff = 0) {
        this.x = x; this.y = y;
        this.maxHp = BOSS.hp * (1 + enemyBuff);
        this.hp = this.maxHp;
        this.atk = BOSS.damage * (1 + enemyBuff);
        this.speed = BOSS.speed;
        this.phase = 1;
        this.atkTimer = 0; this.specTimer = 0; this.hitFlash = 0;
        this.width = 80; this.height = 80;
    }
    
    update(dt, player, game) {
        const pct = this.hp / this.maxHp;
        this.phase = pct < 0.33 ? 3 : pct < 0.66 ? 2 : 1;
        
        const dx = player.x - this.x, dy = player.y - this.y, dist = Math.hypot(dx, dy);
        if (dist > 0) {
            const spd = this.speed * (1 + (3 - this.phase) * 0.15);
            this.x += (dx / dist) * spd * dt;
            this.y += (dy / dist) * spd * dt;
        }
        
        this.atkTimer -= dt;
        if (this.atkTimer <= 0) {
            this.atkTimer = 1.8 / this.phase;
            const a = Math.atan2(dy, dx);
            for (let i = -2; i <= 2; i++) {
                game.enemyProj.push({ x: this.x, y: this.y, vx: Math.cos(a + i * 0.15) * 220, vy: Math.sin(a + i * 0.15) * 220, dmg: this.atk, life: 2.5, size: 8, color: '#ff4500' });
            }
        }
        
        if (this.phase >= 2) {
            this.specTimer -= dt;
            if (this.specTimer <= 0) {
                this.specTimer = 4;
                const types = ['wolf', 'scorpion'];
                for (let i = 0; i < this.phase * 2; i++) {
                    const a = Math.random() * Math.PI * 2;
                    game.enemies.push(new Enemy(this.x + Math.cos(a) * 80, this.y + Math.sin(a) * 80, types[Math.floor(Math.random() * types.length)], game.time, player.enemyBuff));
                }
            }
        }
        
        if (this.hitFlash > 0) this.hitFlash -= dt;
    }
    
    takeDamage(amt, game) {
        this.hp -= amt; this.hitFlash = 0.08;
        game.texts.push(new FloatText(this.x + (Math.random() - 0.5) * 30, this.y - 30, Math.round(amt).toString(), '#ff0', 18));
        return this.hp <= 0;
    }
    
    draw(ctx, cam) {
        const sx = this.x - cam.x, sy = this.y - cam.y;
        if (this.hitFlash > 0) ctx.globalAlpha = 0.6;
        
        ctx.fillStyle = BOSS.color;
        ctx.beginPath();
        ctx.ellipse(sx, sy, 40, 35, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.beginPath();
        ctx.ellipse(sx, sy - 35, 25, 20, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#ff0';
        ctx.fillRect(sx - 15, sy - 40, 6, 6);
        ctx.fillRect(sx + 9, sy - 40, 6, 6);
        
        ctx.fillStyle = '#5a0000';
        ctx.beginPath();
        ctx.moveTo(sx - 35, sy - 10);
        ctx.lineTo(sx - 55, sy - 40);
        ctx.lineTo(sx - 20, sy - 5);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(sx + 35, sy - 10);
        ctx.lineTo(sx + 55, sy - 40);
        ctx.lineTo(sx + 20, sy - 5);
        ctx.fill();
        
        ctx.globalAlpha = 1;
    }
}

// ==================== PICKUPS ====================
class Pickup {
    constructor(x, y, type, value) { this.x = x; this.y = y; this.type = type; this.value = value; this.bob = Math.random() * Math.PI * 2; }
    update(dt) { this.bob += dt * 4; }
    draw(ctx, cam) {
        const sx = this.x - cam.x, sy = this.y - cam.y + Math.sin(this.bob) * 3;
        if (this.type === 'xp') { ctx.fillStyle = '#0f0'; ctx.beginPath(); ctx.moveTo(sx, sy - 5); ctx.lineTo(sx + 5, sy); ctx.lineTo(sx, sy + 5); ctx.lineTo(sx - 5, sy); ctx.fill(); }
        else { ctx.fillStyle = '#ffd700'; ctx.beginPath(); ctx.arc(sx, sy, 4, 0, Math.PI * 2); ctx.fill(); }
    }
}

class ItemDrop {
    constructor(x, y, id) { this.x = x; this.y = y; this.id = id; this.bob = Math.random() * Math.PI * 2; }
    update(dt) { this.bob += dt * 4; }
    draw(ctx, cam) {
        const sx = this.x - cam.x, sy = this.y - cam.y + Math.sin(this.bob) * 4;
        const item = ITEMS[this.id];
        ctx.fillStyle = RARITY[item.rarity].color + '30';
        ctx.beginPath();
        ctx.arc(sx, sy, 15, 0, Math.PI * 2);
        ctx.fill();
        ctx.font = '18px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(item.icon, sx, sy);
    }
}

// ==================== GAME ====================
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.audio = new Audio();
        this.particles = new Particles();
        
        this.state = 'menu';
        this.charIndex = 0;
        this.charIds = Object.keys(CHARACTERS);
        this.selectedCity = 'badaya';
        
        this.player = null;
        this.enemies = [];
        this.boss = null;
        this.projectiles = [];
        this.enemyProj = [];
        this.pickups = [];
        this.items = [];
        this.texts = [];
        this.effects = [];
        
        this.cam = { x: 0, y: 0 };
        this.shake = 0;
        
        this.input = { up: false, down: false, left: false, right: false, joy: null };
        
        this.spawnTimer = 0;
        this.time = 0;
        this.bossSpawned = false;
        this.bossWarnShown = false;
        this.globalSlow = 0;
        
        this.highScore = parseInt(localStorage.getItem('goldBloodHighScore') || '0');
        this.baghdadUnlocked = localStorage.getItem('baghdadUnlocked') === 'true';
        
        this.lastTime = 0;
        
        this.init();
    }
    
    init() {
        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.setupInput();
        this.setupMenu();
        requestAnimationFrame(t => this.loop(t));
    }
    
    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    }
    
    setupMenu() {
        document.getElementById('highScore').textContent = this.highScore;
        
        if (this.baghdadUnlocked) {
            document.getElementById('cityBaghdad').classList.remove('locked');
            document.getElementById('cityBaghdad').querySelector('.city-locked').style.display = 'none';
        }
        
        this.updateCharDisplay();
        
        document.getElementById('charPrev').onclick = () => { this.charIndex = (this.charIndex - 1 + this.charIds.length) % this.charIds.length; this.updateCharDisplay(); };
        document.getElementById('charNext').onclick = () => { this.charIndex = (this.charIndex + 1) % this.charIds.length; this.updateCharDisplay(); };
        
        document.querySelectorAll('.city-card').forEach(card => {
            card.onclick = () => {
                if (card.classList.contains('locked')) return;
                document.querySelectorAll('.city-card').forEach(c => c.classList.remove('selected'));
                card.classList.add('selected');
                this.selectedCity = card.dataset.city;
            };
        });
        
        document.getElementById('startBtn').onclick = () => this.start();
        document.getElementById('restartBtn').onclick = () => this.restart();
    }
    
    updateCharDisplay() {
        const id = this.charIds[this.charIndex];
        const c = CHARACTERS[id];
        
        document.getElementById('charName').textContent = c.name;
        document.getElementById('charTitle').textContent = c.title;
        document.getElementById('charDesc').textContent = c.desc;
        document.getElementById('charWeapon').innerHTML = `üó°Ô∏è ${WEAPONS[c.weapon].name}`;
        
        let statsHtml = '';
        c.passiveText.forEach(p => {
            const isNeg = p.includes('+20% ŸÇŸàÿ© ÿßŸÑÿ£ÿπÿØÿßÿ°');
            statsHtml += `<div class="char-stat"><span class="char-stat-label">‚Ä¢</span><span class="${isNeg ? 'char-stat-negative' : 'char-stat-value'}">${p}</span></div>`;
        });
        document.getElementById('charStats').innerHTML = statsHtml;
        
        // Draw preview
        const canvas = document.getElementById('charPreview');
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, 120, 120);
        
        const col = c.colors;
        ctx.fillStyle = col.body;
        ctx.fillRect(42, 45, 36, 45);
        ctx.fillStyle = col.head;
        ctx.fillRect(45, 20, 30, 15);
        ctx.fillStyle = col.skin;
        ctx.fillRect(48, 35, 24, 18);
        ctx.fillStyle = '#000';
        ctx.fillRect(52, 40, 5, 5);
        ctx.fillRect(63, 40, 5, 5);
        ctx.fillStyle = col.acc;
        ctx.fillRect(45, 90, 12, 18);
        ctx.fillRect(63, 90, 12, 18);
    }
    
    setupInput() {
        window.addEventListener('keydown', e => {
            if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') this.input.up = true;
            if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') this.input.down = true;
            if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') this.input.left = true;
            if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') this.input.right = true;
            if ((e.key === 'Escape' || e.key === 'p') && this.state === 'playing') this.pause();
        });
        window.addEventListener('keyup', e => {
            if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') this.input.up = false;
            if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') this.input.down = false;
            if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') this.input.left = false;
            if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') this.input.right = false;
        });
        
        let touchStart = null;
        this.canvas.addEventListener('touchstart', e => {
            if (this.state !== 'playing') return;
            e.preventDefault();
            touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            this.input.joy = { x: 0, y: 0 };
        }, { passive: false });
        this.canvas.addEventListener('touchmove', e => {
            if (this.state !== 'playing' || !touchStart) return;
            e.preventDefault();
            const dx = e.touches[0].clientX - touchStart.x, dy = e.touches[0].clientY - touchStart.y;
            const d = Math.min(Math.hypot(dx, dy), 70), a = Math.atan2(dy, dx);
            this.input.joy = { x: Math.cos(a) * d / 70, y: Math.sin(a) * d / 70 };
        }, { passive: false });
        this.canvas.addEventListener('touchend', () => { touchStart = null; this.input.joy = null; });
    }
    
    setupEquipSlots() {
        const ws = document.getElementById('weaponSlots');
        const bs = document.getElementById('bookSlots');
        ws.innerHTML = ''; bs.innerHTML = '';
        for (let i = 0; i < CONFIG.MAX_WEAPONS; i++) ws.innerHTML += `<div class="equipment-slot" id="ws${i}"></div>`;
        for (let i = 0; i < CONFIG.MAX_BOOKS; i++) bs.innerHTML += `<div class="equipment-slot" id="bs${i}"></div>`;
    }
    
    updateEquipSlots() {
        for (let i = 0; i < CONFIG.MAX_WEAPONS; i++) {
            const slot = document.getElementById(`ws${i}`);
            if (this.player.weapons[i]) {
                const w = this.player.weapons[i];
                slot.innerHTML = `<span style="font-size:1.2rem">${WEAPONS[w.id].icon}</span><span class="slot-level">${w.level}</span>`;
                if (w.upgrades.length > 0) slot.style.borderColor = w.upgrades[w.upgrades.length - 1].rarity.color;
                else slot.style.borderColor = '#444';
            } else slot.innerHTML = '';
        }
        for (let i = 0; i < CONFIG.MAX_BOOKS; i++) {
            const slot = document.getElementById(`bs${i}`);
            if (this.player.books[i]) {
                const b = this.player.books[i];
                slot.innerHTML = `<span style="font-size:1.2rem">${BOOKS[b.id].icon}</span><span class="slot-level">${b.level}</span>`;
                if (b.upgrades.length > 0) slot.style.borderColor = b.upgrades[b.upgrades.length - 1].rarity.color;
                else slot.style.borderColor = '#444';
            } else slot.innerHTML = '';
        }
    }
    
    start() {
        this.audio.init();
        this.state = 'playing';
        document.getElementById('mainMenu').style.display = 'none';
        document.getElementById('hud').style.display = 'flex';
        document.getElementById('equipmentSlots').style.display = 'flex';
        
        this.player = new Player(0, 0, this.charIds[this.charIndex]);
        this.enemies = [];
        this.boss = null;
        this.projectiles = [];
        this.enemyProj = [];
        this.pickups = [];
        this.items = [];
        this.texts = [];
        this.effects = [];
        this.particles.list = [];
        this.particles.stains = [];
        
        this.time = 0;
        this.spawnTimer = 0;
        this.bossSpawned = false;
        this.bossWarnShown = false;
        
        this.setupEquipSlots();
        this.updateEquipSlots();
    }
    
    restart() {
        document.getElementById('gameOverScreen').style.display = 'none';
        document.getElementById('mainMenu').style.display = 'flex';
        document.getElementById('hud').style.display = 'none';
        document.getElementById('equipmentSlots').style.display = 'none';
        this.state = 'menu';
        
        if (this.baghdadUnlocked) {
            document.getElementById('cityBaghdad').classList.remove('locked');
            document.getElementById('cityBaghdad').querySelector('.city-locked').style.display = 'none';
        }
    }
    
    pause() {
        if (this.state === 'playing') { this.state = 'paused'; document.getElementById('pauseIndicator').style.display = 'block'; }
        else if (this.state === 'paused') { this.state = 'playing'; document.getElementById('pauseIndicator').style.display = 'none'; }
    }
    
    loop(t) {
        const dt = Math.min((t - this.lastTime) / 1000, 0.08);
        this.lastTime = t;
        if (this.state === 'playing') this.update(dt);
        this.draw();
        requestAnimationFrame(t => this.loop(t));
    }
    
    update(dt) {
        this.time += dt;
        
        // Boss warning
        if (this.time >= CONFIG.BOSS_TIME - 30 && !this.bossWarnShown) {
            this.bossWarnShown = true;
            document.getElementById('bossWarning').style.display = 'block';
            this.audio.bossWarn();
            setTimeout(() => document.getElementById('bossWarning').style.display = 'none', 3000);
        }
        
        // Spawn boss
        if (this.time >= CONFIG.BOSS_TIME && !this.bossSpawned) {
            this.bossSpawned = true;
            const a = Math.random() * Math.PI * 2;
            this.boss = new Boss(this.player.x + Math.cos(a) * 350, this.player.y + Math.sin(a) * 350, this.player.enemyBuff);
        }
        
        if (this.globalSlow > 0) this.globalSlow -= dt;
        
        this.player.update(dt, this.input, this);
        
        this.cam.x = this.player.x - this.canvas.width / 2;
        this.cam.y = this.player.y - this.canvas.height / 2;
        if (this.shake > 0) {
            this.shake -= dt;
            this.cam.x += (Math.random() - 0.5) * 8;
            this.cam.y += (Math.random() - 0.5) * 8;
        }
        
        // Spawn enemies
        if (!this.bossSpawned) {
            this.spawnTimer -= dt;
            const rate = 1.3 / (1 + this.player.curse * 0.4);
            const maxEnemies = 60 + this.player.curse * 15;
            if (this.spawnTimer <= 0 && this.enemies.length < maxEnemies) {
                this.spawnEnemy();
                this.spawnTimer = rate / (1 + this.time / 120);
            }
        }
        
        // Update enemies
        const eDt = this.globalSlow > 0 ? dt * 0.5 : dt;
        for (const e of this.enemies) {
            e.update(eDt, this.player, this.enemies, this);
            
            if (Math.hypot(e.x - this.player.x, e.y - this.player.y) < (e.width + this.player.width) / 2) {
                this.player.takeDamage(e.atk, this);
            }
            
            // Aura/orbit damage
            for (const w of this.player.weapons) {
                const data = WEAPONS[w.id];
                if (data.type === 'orbit' || data.type === 'aura') {
                    const range = this.player.getRange(w);
                    if (Math.hypot(e.x - this.player.x, e.y - this.player.y) < range + e.width / 2) {
                        const dps = this.player.getDamage(w) * (data.type === 'aura' ? 0.8 : 1.5);
                        if (e.takeDamage(dps * dt, this)) this.killEnemy(e);
                    }
                } else if (data.type === 'melee') {
                    const range = this.player.getRange(w);
                    const dist = Math.hypot(e.x - this.player.x, e.y - this.player.y);
                    const angle = Math.atan2(e.y - this.player.y, e.x - this.player.x);
                    const pAngle = this.player.facing > 0 ? 0 : Math.PI;
                    if (dist < range + e.width / 2 && Math.abs(angle - pAngle) < Math.PI / 2) {
                        const timer = this.player.weaponTimers[w.id] || 0;
                        const cd = this.player.getCooldown(w);
                        if (timer > cd * 0.78 && timer < cd * 0.92) {
                            if (e.takeDamage(this.player.getDamage(w), this)) this.killEnemy(e);
                        }
                    }
                }
            }
        }
        this.enemies = this.enemies.filter(e => e.hp > 0);
        
        // Update boss
        if (this.boss) {
            this.boss.update(dt, this.player, this);
            if (Math.hypot(this.boss.x - this.player.x, this.boss.y - this.player.y) < (this.boss.width + this.player.width) / 2) {
                this.player.takeDamage(this.boss.atk, this);
            }
            for (const w of this.player.weapons) {
                const data = WEAPONS[w.id];
                if (data.type === 'orbit' || data.type === 'aura') {
                    const range = this.player.getRange(w);
                    if (Math.hypot(this.boss.x - this.player.x, this.boss.y - this.player.y) < range + this.boss.width / 2) {
                        this.boss.takeDamage(this.player.getDamage(w) * dt, this);
                    }
                }
            }
            if (this.boss.hp <= 0) this.over(true);
        }
        
        // Update projectiles
        for (let i = this.projectiles.length - 1; i >= 0; i--) {
            const p = this.projectiles[i];
            p.x += p.vx * dt; p.y += p.vy * dt; p.life -= dt;
            if (p.life <= 0) { this.projectiles.splice(i, 1); continue; }
            for (const e of this.enemies) {
                if (Math.hypot(p.x - e.x, p.y - e.y) < p.size + e.width / 2) {
                    if (e.takeDamage(p.dmg, this)) this.killEnemy(e);
                    p.pierce = (p.pierce || 1) - 1;
                    if (p.pierce <= 0) this.projectiles.splice(i, 1);
                    break;
                }
            }
            if (this.boss && Math.hypot(p.x - this.boss.x, p.y - this.boss.y) < p.size + this.boss.width / 2) {
                this.boss.takeDamage(p.dmg, this);
                this.projectiles.splice(i, 1);
            }
        }
        
        // Update enemy projectiles
        for (let i = this.enemyProj.length - 1; i >= 0; i--) {
            const p = this.enemyProj[i];
            p.x += p.vx * dt; p.y += p.vy * dt; p.life -= dt;
            if (p.life <= 0) { this.enemyProj.splice(i, 1); continue; }
            if (Math.hypot(p.x - this.player.x, p.y - this.player.y) < p.size + this.player.width / 2) {
                this.player.takeDamage(p.dmg, this);
                this.enemyProj.splice(i, 1);
            }
        }
        
        // Update effects
        for (let i = this.effects.length - 1; i >= 0; i--) {
            const e = this.effects[i];
            if (e.type === 'lightning') { e.life -= dt; if (e.life <= 0) this.effects.splice(i, 1); }
            else if (e.type === 'meteor') {
                if (e.delay > 0) { e.delay -= dt; continue; }
                e.life -= dt;
                if (e.life <= 0.4 && !e.hit) {
                    e.hit = true;
                    this.particles.emit(e.x, e.y, 12, { color: '#ff4500', minS: 60, maxS: 160 });
                    for (const en of this.enemies) {
                        if (Math.hypot(e.x - en.x, e.y - en.y) < e.radius) {
                            if (en.takeDamage(e.dmg, this)) this.killEnemy(en);
                        }
                    }
                }
                if (e.life <= 0) this.effects.splice(i, 1);
            }
            else if (e.type === 'tornado') {
                e.x += e.vx * dt; e.y += e.vy * dt; e.life -= dt;
                for (const en of this.enemies) {
                    if (Math.hypot(e.x - en.x, e.y - en.y) < e.radius + en.width / 2) {
                        en.takeDamage(e.dmg * dt, this);
                        en.slow = e.slow;
                        en.slowTimer = 0.4;
                    }
                }
                if (e.life <= 0) this.effects.splice(i, 1);
            }
        }
        
        // Update pickups
        for (let i = this.pickups.length - 1; i >= 0; i--) {
            const p = this.pickups[i];
            p.update(dt);
            const d = Math.hypot(p.x - this.player.x, p.y - this.player.y);
            if (d < this.player.pickupRange * 2) {
                const a = Math.atan2(this.player.y - p.y, this.player.x - p.x);
                const spd = 220 * (1 - d / (this.player.pickupRange * 2));
                p.x += Math.cos(a) * spd * dt;
                p.y += Math.sin(a) * spd * dt;
            }
            if (d < this.player.pickupRange) {
                if (p.type === 'xp') {
                    this.player.xp += p.value * this.player.xpMult * (1 + this.player.curse * 0.5);
                    this.audio.pickup();
                    this.checkLevelUp();
                } else {
                    this.player.gold += Math.round(p.value * this.player.goldMult);
                    this.audio.pickup();
                }
                this.pickups.splice(i, 1);
            }
        }
        
        // Update item drops
        for (let i = this.items.length - 1; i >= 0; i--) {
            const item = this.items[i];
            item.update(dt);
            if (Math.hypot(item.x - this.player.x, item.y - this.player.y) < 25) {
                this.collectItem(item);
                this.items.splice(i, 1);
            }
        }
        
        this.texts = this.texts.filter(t => { t.update(dt); return t.life > 0; });
        this.particles.update(dt);
        
        this.updateHUD();
        this.updateEquipSlots();
    }
    
    spawnEnemy() {
        const a = Math.random() * Math.PI * 2;
        const d = 450 + Math.random() * 80;
        const x = this.player.x + Math.cos(a) * d;
        const y = this.player.y + Math.sin(a) * d;
        
        const available = Object.entries(ENEMIES).filter(([, e]) => this.time >= e.time);
        const weights = available.map((_, i) => Math.pow(1.8, i));
        const total = weights.reduce((s, w) => s + w, 0);
        let r = Math.random() * total;
        let type = available[0][0];
        for (let i = 0; i < weights.length; i++) {
            r -= weights[i];
            if (r <= 0) { type = available[i][0]; break; }
        }
        
        this.enemies.push(new Enemy(x, y, type, this.time, this.player.enemyBuff));
        
        if (ENEMIES[type].pack) {
            for (let i = 0; i < 2; i++) {
                this.enemies.push(new Enemy(x + (Math.random() - 0.5) * 40, y + (Math.random() - 0.5) * 40, type, this.time, this.player.enemyBuff));
            }
        }
    }
    
    killEnemy(enemy) {
        this.player.kills++;
        this.audio.pickup();
        this.particles.blood(enemy.x, enemy.y);
        this.pickups.push(new Pickup(enemy.x, enemy.y, 'xp', enemy.xp));
        if (Math.random() < 0.2) this.pickups.push(new Pickup(enemy.x + (Math.random() - 0.5) * 15, enemy.y + (Math.random() - 0.5) * 15, 'gold', 1 + Math.floor(this.time / 60)));
        if (Math.random() < 0.015 * this.player.luck) this.dropItem(enemy.x, enemy.y);
    }
    
    dropItem(x, y) {
        const r = Math.random() * 100 / this.player.luck;
        let rarity;
        if (r < 5) rarity = 'LEGENDARY';
        else if (r < 18) rarity = 'RARE';
        else rarity = 'COMMON';
        
        const pool = Object.entries(ITEMS).filter(([, i]) => i.rarity === rarity);
        if (pool.length > 0) {
            const [id] = pool[Math.floor(Math.random() * pool.length)];
            this.items.push(new ItemDrop(x, y, id));
        }
    }
    
    collectItem(drop) {
        const item = ITEMS[drop.id];
        this.audio.tone(item.rarity === 'LEGENDARY' ? 800 : item.rarity === 'RARE' ? 600 : 450, 0.1, 'sine');
        
        const notif = document.createElement('div');
        notif.className = 'item-notification';
        notif.style.borderColor = RARITY[item.rarity].color;
        notif.innerHTML = `${item.icon} ${item.name}`;
        document.body.appendChild(notif);
        setTimeout(() => notif.remove(), 2000);
        
        switch (item.effect) {
            case 'heal': this.player.hp = Math.min(this.player.maxHp, this.player.hp + item.value); this.texts.push(new FloatText(this.player.x, this.player.y - 25, `+${item.value} HP`, '#0f0')); break;
            case 'fullHeal': this.player.maxHp += item.value; this.player.hp = this.player.maxHp; this.texts.push(new FloatText(this.player.x, this.player.y - 25, 'ÿ¥ŸÅÿßÿ° ŸÉÿßŸÖŸÑ!', '#0f0', 18)); break;
            case 'gold': this.player.gold += Math.round(item.value * this.player.goldMult); break;
            case 'tempSpeed': this.player.tempBuffs.push({ type: 'speed', value: item.value, duration: item.duration }); break;
            case 'tempDamage': this.player.tempBuffs.push({ type: 'damage', value: item.value, duration: item.duration }); break;
            case 'tempAttackSpeed': this.player.tempBuffs.push({ type: 'attackSpeed', value: item.value, duration: item.duration }); break;
            case 'shield': this.player.shield += item.value; break;
            case 'slow': this.globalSlow = item.duration; break;
            case 'revive': this.player.hasRevive = true; this.texts.push(new FloatText(this.player.x, this.player.y - 25, 'ÿ•ÿ≠Ÿäÿßÿ° ŸÖÿ≠ŸÅŸàÿ∏!', '#ffd700')); break;
            case 'permGold': this.player.goldMult += item.value; break;
            case 'randomEquip': this.giveRandomEquip(); break;
        }
    }
    
    giveRandomEquip() {
        if (Math.random() < 0.5 && this.player.weapons.length < CONFIG.MAX_WEAPONS) {
            const avail = Object.keys(WEAPONS).filter(w => !this.player.weapons.find(pw => pw.id === w));
            if (avail.length > 0) {
                const id = avail[Math.floor(Math.random() * avail.length)];
                this.player.weapons.push({ id, level: 1, upgrades: [] });
                this.texts.push(new FloatText(this.player.x, this.player.y - 35, `${WEAPONS[id].name}!`, '#ffd700', 18));
            }
        } else if (this.player.books.length < CONFIG.MAX_BOOKS) {
            const avail = Object.keys(BOOKS).filter(b => !this.player.books.find(pb => pb.id === b));
            if (avail.length > 0) {
                const id = avail[Math.floor(Math.random() * avail.length)];
                this.player.books.push({ id, level: 1, upgrades: [] });
                this.applyBook(id, 1, RARITY.COMMON);
                this.texts.push(new FloatText(this.player.x, this.player.y - 35, `${BOOKS[id].name}!`, '#ffd700', 18));
            }
        }
    }
    
    checkLevelUp() {
        const req = Math.floor(10 * Math.pow(1.4, this.player.level - 1));
        if (this.player.xp >= req) {
            this.player.xp -= req;
            this.player.level++;
            this.player.hp = Math.min(this.player.maxHp, this.player.hp + this.player.maxHp * 0.15);
            this.audio.levelUp();
            this.showLevelUp();
        }
    }
    
    showLevelUp() {
        this.state = 'levelup';
        const modal = document.getElementById('levelUpModal');
        const opts = document.getElementById('upgradeOptions');
        
        const choices = [];
        
        // Available weapons
        const aw = [];
        for (const w of this.player.weapons) { if (w.level < CONFIG.MAX_UPGRADE_LEVEL) aw.push({ type: 'weapon', id: w.id, isNew: false }); }
        if (this.player.weapons.length < CONFIG.MAX_WEAPONS) {
            Object.keys(WEAPONS).filter(w => !this.player.weapons.find(pw => pw.id === w)).forEach(w => aw.push({ type: 'weapon', id: w, isNew: true }));
        }
        
        // Available books
        const ab = [];
        for (const b of this.player.books) { if (b.level < CONFIG.MAX_UPGRADE_LEVEL) ab.push({ type: 'book', id: b.id, isNew: false }); }
        if (this.player.books.length < CONFIG.MAX_BOOKS) {
            Object.keys(BOOKS).filter(b => !this.player.books.find(pb => pb.id === b)).forEach(b => ab.push({ type: 'book', id: b, isNew: true }));
        }
        
        const all = [...aw, ...ab];
        while (choices.length < 3 && all.length > 0) {
            choices.push(all.splice(Math.floor(Math.random() * all.length), 1)[0]);
        }
        
        opts.innerHTML = '';
        choices.forEach(c => {
            const rarity = getRandomRarity();
            const card = document.createElement('div');
            card.className = 'upgrade-card';
            card.style.borderColor = rarity.color;
            card.style.boxShadow = `0 0 15px ${rarity.color}40`;
            
            const data = c.type === 'weapon' ? WEAPONS[c.id] : BOOKS[c.id];
            const lvl = c.isNew ? 0 : (c.type === 'weapon' ? this.player.weapons : this.player.books).find(x => x.id === c.id).level;
            
            card.innerHTML = `
                <div class="upgrade-icon">${data.icon}</div>
                <div class="upgrade-name" style="color:${rarity.color}">${data.name}</div>
                <div class="upgrade-type">${c.type === 'weapon' ? 'ÿ≥ŸÑÿßÿ≠' : 'ŸÉÿ™ÿßÿ®'}</div>
                <div class="upgrade-level">${c.isNew ? 'ÿ¨ÿØŸäÿØ!' : `${lvl} ‚Üí ${lvl + 1}`}</div>
                <div class="upgrade-desc">${data.desc}</div>
                <div class="upgrade-rarity" style="background:${rarity.color}25;color:${rarity.color}">${rarity.name} (+${rarity.bonus})</div>
            `;
            
            card.onclick = () => {
                this.selectUpgrade(c, rarity);
                modal.style.display = 'none';
                this.state = 'playing';
            };
            
            opts.appendChild(card);
        });
        
        modal.style.display = 'flex';
    }
    
    selectUpgrade(choice, rarity) {
        if (choice.type === 'weapon') {
            if (choice.isNew) {
                this.player.weapons.push({ id: choice.id, level: 1, upgrades: [{ rarity }] });
            } else {
                const w = this.player.weapons.find(x => x.id === choice.id);
                w.level++;
                w.upgrades.push({ rarity });
            }
        } else {
            if (choice.isNew) {
                this.player.books.push({ id: choice.id, level: 1, upgrades: [{ rarity }] });
                this.applyBook(choice.id, 1, rarity);
            } else {
                const b = this.player.books.find(x => x.id === choice.id);
                b.level++;
                b.upgrades.push({ rarity });
                this.applyBook(choice.id, b.level, rarity);
            }
        }
        this.updateEquipSlots();
    }
    
    applyBook(id, level, rarity) {
        const book = BOOKS[id];
        const val = book.baseValue * (1 + rarity.bonus * 0.15);
        
        switch (book.stat) {
            case 'damage': this.player.damage += val; break;
            case 'attackSpeed': this.player.attackSpeed += val; break;
            case 'moveSpeed': this.player.speed += this.player.speed * val; break;
            case 'xpGain': this.player.xpMult += val; break;
            case 'maxHealth': const inc = this.player.maxHp * val; this.player.maxHp += inc; this.player.hp += inc; break;
            case 'armor': this.player.armor += val * 8; break;
            case 'pickup': this.player.pickupRange += this.player.pickupRange * val; break;
            case 'luck': this.player.luck += val; break;
            case 'curse': this.player.curse += val; break;
            case 'regen': this.player.regen += val; break;
        }
    }
    
    over(victory) {
        this.state = 'gameover';
        document.getElementById('hud').style.display = 'none';
        document.getElementById('equipmentSlots').style.display = 'none';
        
        const title = document.getElementById('gameOverTitle');
        const unlock = document.getElementById('unlockMessage');
        
        if (victory) {
            this.audio.victory();
            title.textContent = 'üéâ ÿßŸÜÿ™ÿµÿßÿ±! üéâ';
            title.className = 'game-over-title victory-title';
            
            if (!this.baghdadUnlocked) {
                this.baghdadUnlocked = true;
                localStorage.setItem('baghdadUnlocked', 'true');
                unlock.textContent = 'üîì ÿ™ŸÖ ŸÅÿ™ÿ≠ ÿÆÿ±Ÿäÿ∑ÿ© ÿ®ÿ∫ÿØÿßÿØ!';
                unlock.style.display = 'block';
            } else {
                unlock.style.display = 'none';
            }
        } else {
            this.audio.death();
            title.textContent = 'ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑŸÑÿπÿ®ÿ©';
            title.className = 'game-over-title';
            unlock.style.display = 'none';
        }
        
        if (this.player.kills > this.highScore) {
            this.highScore = this.player.kills;
            localStorage.setItem('goldBloodHighScore', this.highScore.toString());
            document.getElementById('highScore').textContent = this.highScore;
        }
        
        const m = Math.floor(this.time / 60), s = Math.floor(this.time % 60);
        document.getElementById('finalStats').innerHTML = `
            <p>‚è±Ô∏è ÿßŸÑŸàŸÇÿ™: ${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}</p>
            <p>‚≠ê ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ: ${this.player.level}</p>
            <p>üíÄ ÿßŸÑŸÇÿ™ŸÑŸâ: ${this.player.kills}</p>
            <p>üí∞ ÿßŸÑÿ∞Ÿáÿ®: ${this.player.gold}</p>
        `;
        
        document.getElementById('gameOverScreen').style.display = 'flex';
    }
    
    updateHUD() {
        const hpPct = (this.player.hp / this.player.maxHp) * 100;
        document.getElementById('healthBar').style.width = `${hpPct}%`;
        document.getElementById('healthText').textContent = `${Math.ceil(this.player.hp)}/${Math.ceil(this.player.maxHp)}`;
        
        const xpReq = Math.floor(10 * Math.pow(1.4, this.player.level - 1));
        const xpPct = (this.player.xp / xpReq) * 100;
        document.getElementById('xpBar').style.width = `${xpPct}%`;
        document.getElementById('xpText').textContent = `${Math.floor(this.player.xp)}/${xpReq}`;
        
        document.getElementById('levelText').textContent = `ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ: ${this.player.level}`;
        document.getElementById('goldText').textContent = this.player.gold;
        document.getElementById('killText').textContent = this.player.kills;
        
        const m = Math.floor(this.time / 60), s = Math.floor(this.time % 60);
        document.getElementById('timerText').textContent = `‚è±Ô∏è ${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    }
    
    draw() {
        const ctx = this.ctx;
        
        // Background based on city
        const city = CITIES[this.selectedCity];
        ctx.fillStyle = city ? city.bg : '#d4b896';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        if (this.state === 'menu') {
            this.drawMenuBg();
            return;
        }
        
        if (['playing', 'paused', 'levelup', 'gameover'].includes(this.state)) {
            this.drawGame();
        }
    }
    
    drawMenuBg() {
        const ctx = this.ctx;
        const t = Date.now() / 1000;
        
        for (let i = 0; i < 4; i++) {
            const y = this.canvas.height * 0.45 + i * 70;
            ctx.fillStyle = `rgba(${50 + i * 8}, ${40 + i * 5}, ${25 + i * 3}, 0.4)`;
            ctx.beginPath();
            ctx.moveTo(0, y);
            for (let x = 0; x <= this.canvas.width; x += 40) ctx.lineTo(x, y + Math.sin(x * 0.008 + t + i) * 15);
            ctx.lineTo(this.canvas.width, this.canvas.height);
            ctx.lineTo(0, this.canvas.height);
            ctx.fill();
        }
    }
    
    drawGame() {
        const ctx = this.ctx;
        
        this.drawBg();
        this.particles.draw(ctx, this.cam);
        
        for (const p of this.pickups) p.draw(ctx, this.cam);
        for (const i of this.items) i.draw(ctx, this.cam);
        
        // Effects
        for (const e of this.effects) {
            const sx = e.x - this.cam.x, sy = e.y - this.cam.y;
            if (e.type === 'lightning') {
                ctx.strokeStyle = `rgba(255, 255, 100, ${e.life / 0.25})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(sx, sy - 400);
                ctx.lineTo(sx, sy);
                ctx.stroke();
                ctx.fillStyle = `rgba(255, 255, 180, ${e.life / 0.25 * 0.4})`;
                ctx.beginPath();
                ctx.arc(sx, sy, 25, 0, Math.PI * 2);
                ctx.fill();
            } else if (e.type === 'meteor' && e.delay <= 0) {
                if (e.life > 0.4) {
                    ctx.strokeStyle = 'rgba(255, 80, 0, 0.4)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(sx, sy, e.radius, 0, Math.PI * 2);
                    ctx.stroke();
                } else {
                    ctx.fillStyle = 'rgba(255, 80, 0, 0.25)';
                    ctx.beginPath();
                    ctx.arc(sx, sy, e.radius * (1 - e.life / 0.4), 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (e.type === 'tornado') {
                ctx.strokeStyle = 'rgba(180, 160, 130, 0.5)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.arc(sx, sy, e.radius - i * 8, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
        }
        
        for (const e of this.enemies) e.draw(ctx, this.cam);
        if (this.boss) this.boss.draw(ctx, this.cam);
        this.player.draw(ctx, this.cam);
        
        // Projectiles
        for (const p of this.projectiles) {
            const sx = p.x - this.cam.x, sy = p.y - this.cam.y;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(sx, sy, p.size, 0, Math.PI * 2);
            ctx.fill();
        }
        
        for (const p of this.enemyProj) {
            const sx = p.x - this.cam.x, sy = p.y - this.cam.y;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(sx, sy, p.size, 0, Math.PI * 2);
            ctx.fill();
        }
        
        for (const t of this.texts) t.draw(ctx, this.cam);
        
        this.drawLighting();
        
        // Joystick
        if (this.input.joy) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.12)';
            ctx.beginPath();
            ctx.arc(90, this.canvas.height - 90, 55, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'rgba(255, 215, 0, 0.35)';
            ctx.beginPath();
            ctx.arc(90 + this.input.joy.x * 35, this.canvas.height - 90 + this.input.joy.y * 35, 22, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Boss health bar
        if (this.boss) {
            const bw = Math.min(350, this.canvas.width * 0.8);
            const bx = (this.canvas.width - bw) / 2;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(bx - 3, 48, bw + 6, 26);
            ctx.fillStyle = '#333';
            ctx.fillRect(bx, 51, bw, 20);
            const hc = this.boss.phase === 3 ? '#f00' : this.boss.phase === 2 ? '#f80' : '#ff0';
            ctx.fillStyle = hc;
            ctx.fillRect(bx, 51, bw * (this.boss.hp / this.boss.maxHp), 20);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 12px Cairo';
            ctx.textAlign = 'center';
            ctx.fillText(`${BOSS.name} - ÿßŸÑŸÖÿ±ÿ≠ŸÑÿ© ${this.boss.phase}`, this.canvas.width / 2, 45);
        }
    }
    
    drawBg() {
        const ctx = this.ctx;
        const ts = CONFIG.TILE_SIZE;
        const city = CITIES[this.selectedCity];
        
        const sx = Math.floor(this.cam.x / ts) - 1;
        const sy = Math.floor(this.cam.y / ts) - 1;
        const ex = Math.ceil((this.cam.x + this.canvas.width) / ts) + 1;
        const ey = Math.ceil((this.cam.y + this.canvas.height) / ts) + 1;
        
        for (let y = sy; y <= ey; y++) {
            for (let x = sx; x <= ex; x++) {
                const px = x * ts - this.cam.x;
                const py = y * ts - this.cam.y;
                
                const n = Math.sin(x * 0.4) * Math.cos(y * 0.4) * 0.08;
                let r = 210, g = 180, b = 140;
                if (this.selectedCity === 'baghdad') { r = 140; g = 180; b = 140; }
                r = Math.floor(r + n * 25);
                g = Math.floor(g + n * 20);
                b = Math.floor(b + n * 15);
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                ctx.fillRect(px, py, ts + 1, ts + 1);
                
                const seed = Math.abs(Math.sin(x * 12.9898 + y * 78.233) * 43758.5453) % 1;
                if (seed < 0.015) {
                    ctx.fillStyle = '#5a5a5a';
                    ctx.beginPath();
                    ctx.arc(px + ts / 2, py + ts / 2, 5 + seed * 6, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.selectedCity === 'badaya' && seed < 0.025) {
                    // Palm tree
                    ctx.fillStyle = '#4a3020';
                    ctx.fillRect(px + ts / 2 - 3, py + ts / 2 - 15, 6, 20);
                    ctx.fillStyle = '#2d5016';
                    for (let i = 0; i < 5; i++) {
                        ctx.beginPath();
                        ctx.ellipse(px + ts / 2 + Math.cos(i * 1.2) * 12, py + ts / 2 - 18 + Math.sin(i * 1.2) * 5, 10, 4, i * 0.8, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (this.selectedCity === 'baghdad' && seed < 0.04) {
                    // Grass
                    ctx.fillStyle = '#3a6030';
                    for (let i = 0; i < 3; i++) {
                        ctx.fillRect(px + ts / 3 + i * 8, py + ts / 2, 2, 8);
                    }
                }
            }
        }
    }
    
    drawLighting() {
        const ctx = this.ctx;
        
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        const px = this.player.x - this.cam.x;
        const py = this.player.y - this.cam.y;
        
        ctx.globalCompositeOperation = 'destination-out';
        
        const g = ctx.createRadialGradient(px, py, 0, px, py, CONFIG.PLAYER_LIGHT_RADIUS);
        g.addColorStop(0, 'rgba(0, 0, 0, 1)');
        g.addColorStop(0.5, 'rgba(0, 0, 0, 0.5)');
        g.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(px, py, CONFIG.PLAYER_LIGHT_RADIUS, 0, Math.PI * 2);
        ctx.fill();
        
        for (const p of this.projectiles) {
            const sx = p.x - this.cam.x, sy = p.y - this.cam.y;
            const pg = ctx.createRadialGradient(sx, sy, 0, sx, sy, 35);
            pg.addColorStop(0, 'rgba(0, 0, 0, 0.6)');
            pg.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = pg;
            ctx.beginPath();
            ctx.arc(sx, sy, 35, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.globalCompositeOperation = 'source-over';
        
        ctx.fillStyle = 'rgba(255, 190, 90, 0.03)';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }
}

// Start
window.addEventListener('load', () => new Game());
    </script>
</body>
</html>
