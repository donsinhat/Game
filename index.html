<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Ø°Ù‡Ø¨ Ø£ØµÙØ± Ø£Ùˆ Ø¯Ù… Ø£Ø­Ù…Ø± - Gold or Blood</title>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700;900&family=Changa:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
        body { background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0f0f1a 100%); font-family: 'Cairo', 'Changa', sans-serif; overflow: hidden; min-height: 100vh; color: #fff; }
        #gameCanvas { display: block; position: absolute; top: 0; left: 0; }
        
        .rarity-common { color: #9d9d9d; }
        .rarity-uncommon { color: #1eff00; }
        .rarity-rare { color: #0070dd; }
        .rarity-epic { color: #a335ee; }
        .rarity-legendary { color: #ff8000; }
        
        #mainMenu { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; background: linear-gradient(180deg, rgba(10,10,15,0.97) 0%, rgba(26,26,46,0.98) 100%); padding: 20px; }
        .menu-title { font-size: clamp(1.5rem, 5vw, 2.5rem); font-weight: 900; text-align: center; margin-bottom: 5px; background: linear-gradient(135deg, #ffd700 0%, #ff8c00 50%, #ffd700 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
        .menu-subtitle { font-size: clamp(0.8rem, 2.5vw, 1rem); color: #888; margin-bottom: 20px; }
        
        .character-select { display: flex; align-items: center; gap: 15px; margin-bottom: 25px; }
        .char-arrow { width: 50px; height: 50px; background: rgba(255, 215, 0, 0.1); border: 2px solid rgba(255, 215, 0, 0.3); border-radius: 50%; color: #ffd700; font-size: 1.5rem; cursor: pointer; transition: all 0.3s; display: flex; align-items: center; justify-content: center; }
        .char-arrow:hover { background: rgba(255, 215, 0, 0.2); border-color: #ffd700; transform: scale(1.1); }
        
        .character-display { width: 280px; padding: 20px; background: rgba(30, 30, 40, 0.9); border: 2px solid rgba(255, 215, 0, 0.3); border-radius: 20px; text-align: center; }
        .char-preview { width: 120px; height: 120px; margin: 0 auto 15px; image-rendering: pixelated; border-radius: 10px; background: rgba(0,0,0,0.3); }
        .char-name { font-size: 1.4rem; font-weight: 900; color: #ffd700; margin-bottom: 5px; }
        .char-title { font-size: 0.85rem; color: #888; margin-bottom: 10px; }
        .char-desc { font-size: 0.8rem; color: #aaa; margin-bottom: 12px; line-height: 1.4; min-height: 40px; }
        .char-stats { background: rgba(0,0,0,0.3); padding: 10px; border-radius: 10px; margin-bottom: 10px; }
        .char-stat { display: flex; justify-content: space-between; font-size: 0.8rem; margin: 4px 0; }
        .char-stat-label { color: #888; }
        .char-stat-value { color: #4f4; font-weight: bold; }
        .char-stat-negative { color: #f44; }
        .char-weapon { font-size: 0.85rem; color: #ff8888; padding: 8px; background: rgba(255,0,0,0.1); border-radius: 8px; }
        
        .city-select { display: flex; gap: 15px; margin-bottom: 25px; }
        .city-card { width: 160px; padding: 15px; background: rgba(30, 30, 40, 0.9); border: 2px solid rgba(100, 100, 100, 0.3); border-radius: 15px; cursor: pointer; transition: all 0.3s; text-align: center; }
        .city-card:hover:not(.locked), .city-card.selected { border-color: #ffd700; background: rgba(255, 215, 0, 0.1); transform: translateY(-5px); }
        .city-card.locked { opacity: 0.5; cursor: not-allowed; }
        .city-icon { font-size: 2.5rem; margin-bottom: 8px; }
        .city-name { font-size: 1rem; font-weight: bold; color: #ffd700; margin-bottom: 5px; }
        .city-desc { font-size: 0.7rem; color: #888; }
        .city-locked { font-size: 0.7rem; color: #f44; margin-top: 8px; }
        
        .btn { padding: 12px 40px; font-size: 1.1rem; font-family: 'Cairo', sans-serif; font-weight: 700; border: none; border-radius: 50px; cursor: pointer; transition: all 0.3s ease; }
        .btn-primary { background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%); color: #000; box-shadow: 0 8px 25px rgba(255, 215, 0, 0.4); }
        .btn-primary:hover { transform: scale(1.05); box-shadow: 0 12px 35px rgba(255, 215, 0, 0.5); }
        .high-score { margin-top: 15px; font-size: 0.8rem; color: #666; }
        
        #hud { position: fixed; top: 0; left: 0; width: 100%; padding: 10px 15px; display: none; justify-content: space-between; align-items: flex-start; z-index: 50; pointer-events: none; }
        .hud-left, .hud-right { display: flex; flex-direction: column; gap: 6px; }
        .hud-bar { width: 180px; height: 24px; background: linear-gradient(180deg, rgba(20, 20, 30, 0.95) 0%, rgba(10, 10, 15, 0.95) 100%); border-radius: 12px; overflow: hidden; border: 2px solid rgba(255, 215, 0, 0.4); position: relative; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5), inset 0 2px 4px rgba(0, 0, 0, 0.5); }
        .hud-bar-fill { height: 100%; transition: width 0.3s ease; border-radius: 10px; position: relative; }
        .hud-bar-fill::after { content: ''; position: absolute; top: 2px; left: 4px; right: 4px; height: 8px; background: linear-gradient(180deg, rgba(255,255,255,0.4) 0%, transparent 100%); border-radius: 4px; }
        .hud-bar-text { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 0.7rem; font-weight: bold; text-shadow: 1px 1px 3px #000, 0 0 10px rgba(0,0,0,0.8); letter-spacing: 1px; }
        .health-fill { background: linear-gradient(90deg, #ff2222 0%, #ff4444 50%, #ff6666 100%); box-shadow: 0 0 15px rgba(255, 50, 50, 0.5); }
        .xp-fill { background: linear-gradient(90deg, #22ff22 0%, #44ff44 50%, #66ff66 100%); box-shadow: 0 0 15px rgba(50, 255, 50, 0.5); }
        .hud-stat { font-size: 0.9rem; font-weight: 700; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8); display: flex; align-items: center; gap: 6px; padding: 4px 10px; background: rgba(0, 0, 0, 0.5); border-radius: 8px; }
        .hud-stat-icon { font-size: 1.1rem; }
        .gold-text { color: #ffd700; border: 1px solid rgba(255, 215, 0, 0.3); }
        .kill-text { color: #ff6666; border: 1px solid rgba(255, 100, 100, 0.3); }
        .level-text { color: #66ff66; border: 1px solid rgba(100, 255, 100, 0.3); }
        .timer-text { color: #66ccff; border: 1px solid rgba(100, 200, 255, 0.3); }
        
        .equipment-slots { position: fixed; bottom: 15px; left: 50%; transform: translateX(-50%); display: none; gap: 10px; z-index: 50; pointer-events: none; }
        .slot-group { display: flex; gap: 6px; padding: 8px 12px; background: linear-gradient(180deg, rgba(30, 30, 40, 0.95) 0%, rgba(15, 15, 20, 0.95) 100%); border-radius: 12px; border: 2px solid rgba(255, 215, 0, 0.3); box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5); }
        .equipment-slot { width: 44px; height: 44px; background: linear-gradient(135deg, rgba(60, 60, 70, 0.9) 0%, rgba(40, 40, 50, 0.9) 100%); border: 2px solid #555; border-radius: 8px; display: flex; align-items: center; justify-content: center; position: relative; font-size: 1.3rem; box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.4); transition: all 0.2s; }
        .equipment-slot:hover { border-color: #ffd700; transform: scale(1.1); }
        .slot-level { position: absolute; bottom: -4px; right: -4px; background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%); color: #000; font-size: 0.6rem; padding: 2px 5px; border-radius: 6px; font-weight: bold; box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4); }
        
        #levelUpModal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); display: none; justify-content: center; align-items: center; z-index: 200; }
        .level-up-content { text-align: center; padding: 25px; background: rgba(20, 20, 30, 0.95); border: 3px solid #ffd700; border-radius: 20px; max-width: 95%; max-height: 85vh; overflow-y: auto; }
        .level-up-title { font-size: 1.6rem; color: #ffd700; margin-bottom: 20px; }
        .upgrade-options { display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; }
        .upgrade-card { width: 150px; padding: 12px; background: rgba(30, 30, 40, 0.9); border: 3px solid #444; border-radius: 12px; cursor: pointer; transition: all 0.3s ease; text-align: center; }
        .upgrade-card:hover { transform: scale(1.05); }
        .upgrade-icon { font-size: 2rem; margin-bottom: 8px; }
        .upgrade-name { font-size: 0.9rem; font-weight: bold; margin-bottom: 4px; }
        .upgrade-type { font-size: 0.7rem; color: #888; margin-bottom: 4px; }
        .upgrade-level { font-size: 0.75rem; margin-bottom: 4px; }
        .upgrade-desc { font-size: 0.65rem; color: #aaa; }
        .upgrade-rarity { font-size: 0.65rem; font-weight: bold; margin-top: 6px; padding: 2px 6px; border-radius: 8px; display: inline-block; }
        
        /* Item Pickup Modal */
        #itemPickupModal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); display: none; justify-content: center; align-items: center; z-index: 250; }
        .item-pickup-content { text-align: center; padding: 30px; background: rgba(20, 20, 30, 0.95); border: 3px solid #ffd700; border-radius: 20px; max-width: 320px; }
        .item-pickup-icon { font-size: 4rem; margin-bottom: 15px; }
        .item-pickup-name { font-size: 1.4rem; font-weight: bold; margin-bottom: 8px; }
        .item-pickup-rarity { font-size: 0.85rem; margin-bottom: 12px; padding: 4px 12px; border-radius: 10px; display: inline-block; }
        .item-pickup-desc { font-size: 0.95rem; color: #ccc; margin-bottom: 20px; line-height: 1.5; }
        .item-pickup-btn { padding: 10px 30px; font-size: 1rem; font-family: 'Cairo', sans-serif; font-weight: 700; border: none; border-radius: 25px; cursor: pointer; background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%); color: #000; }
        
        #gameOverScreen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.9); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 300; }
        .game-over-title { font-size: 2rem; color: #ff0000; margin-bottom: 15px; text-shadow: 0 0 20px rgba(255, 0, 0, 0.8); }
        .victory-title { color: #ffd700 !important; text-shadow: 0 0 20px rgba(255, 215, 0, 0.8) !important; }
        .final-stats { margin-bottom: 20px; font-size: 1rem; line-height: 1.6; }
        .unlock-message { color: #ffd700; font-size: 1.1rem; margin-bottom: 15px; padding: 10px 20px; background: rgba(255, 215, 0, 0.1); border-radius: 10px; }
        
        #bossWarning { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 2rem; color: #ff0000; text-shadow: 0 0 30px rgba(255, 0, 0, 0.8); display: none; z-index: 150; text-align: center; animation: bossWarn 0.5s ease-in-out infinite alternate; }
        @keyframes bossWarn { from { transform: translate(-50%, -50%) scale(1); } to { transform: translate(-50%, -50%) scale(1.1); } }
        @keyframes pulse { 0%, 100% { opacity: 1; box-shadow: 0 0 15px rgba(255, 50, 50, 0.5); } 50% { opacity: 0.7; box-shadow: 0 0 25px rgba(255, 0, 0, 0.8); } }
        
        #pauseIndicator { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 2rem; color: #ffd700; display: none; z-index: 150; }
        
        /* Pause Button */
        #pauseBtn { position: fixed; top: 10px; left: 50%; transform: translateX(-50%); width: 44px; height: 44px; background: rgba(0,0,0,0.6); border: 2px solid rgba(255,215,0,0.5); border-radius: 50%; color: #ffd700; font-size: 1.3rem; cursor: pointer; z-index: 60; display: none; transition: all 0.2s; }
        #pauseBtn:hover { background: rgba(255,215,0,0.2); border-color: #ffd700; }
        
        /* Pause Menu */
        #pauseMenu { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 200; }
        .pause-title { font-size: 2rem; color: #ffd700; margin-bottom: 30px; }
        .pause-controls { background: rgba(30,30,40,0.95); padding: 25px 35px; border-radius: 15px; border: 2px solid rgba(255,215,0,0.3); min-width: 280px; }
        .volume-control { margin: 15px 0; }
        .volume-label { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; font-size: 0.9rem; color: #ccc; }
        .volume-label span:last-child { color: #ffd700; font-weight: bold; }
        .volume-slider { width: 100%; height: 8px; -webkit-appearance: none; background: #333; border-radius: 4px; outline: none; }
        .volume-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; background: #ffd700; border-radius: 50%; cursor: pointer; }
        .volume-slider::-moz-range-thumb { width: 20px; height: 20px; background: #ffd700; border-radius: 50%; cursor: pointer; border: none; }
        .pause-buttons { display: flex; flex-direction: column; gap: 12px; margin-top: 25px; }
        .pause-btn { padding: 12px 25px; font-size: 1rem; font-family: 'Cairo', sans-serif; font-weight: 700; border: none; border-radius: 25px; cursor: pointer; transition: all 0.2s; }
        .pause-btn-resume { background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%); color: #000; }
        .pause-btn-resume:hover { transform: scale(1.05); }
        .pause-btn-quit { background: rgba(255,0,0,0.2); border: 2px solid #f44; color: #f44; }
        .pause-btn-quit:hover { background: rgba(255,0,0,0.3); }
        
        /* Mini Map */
        #miniMap { position: fixed; bottom: 80px; right: 15px; width: 110px; height: 110px; background: rgba(0, 0, 0, 0.75); border: 2px solid rgba(255, 215, 0, 0.5); border-radius: 12px; display: none; z-index: 55; overflow: hidden; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5); }
        #miniMapCanvas { width: 100%; height: 100%; border-radius: 10px; }
        
        /* Damage numbers animation */
        @keyframes floatUp { 0% { opacity: 1; transform: translateY(0); } 100% { opacity: 0; transform: translateY(-30px); } }
        
        @media (max-width: 600px) {
            .character-display { width: 240px; padding: 15px; }
            .char-preview { width: 90px; height: 90px; }
            .city-card { width: 130px; padding: 12px; }
            .upgrade-card { width: 130px; padding: 10px; }
            .hud-bar { width: 130px; height: 18px; }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="mainMenu">
        <h1 class="menu-title">Ø°Ù‡Ø¨ Ø£ØµÙØ± Ø£Ùˆ Ø¯Ù… Ø£Ø­Ù…Ø±</h1>
        <p class="menu-subtitle">Ø§Ù‚ØªÙ„ Ø§Ø¨Ùˆ Ø­Ù„Ø²Ù‡ ÙÙŠ 10 Ø¯Ù‚Ø§Ø¦Ù‚!</p>
        <div class="character-select">
            <button class="char-arrow" id="charPrev">â†’</button>
            <div class="character-display">
                <canvas class="char-preview" id="charPreview" width="120" height="120"></canvas>
                <div class="char-name" id="charName">Ø£Ø¨Ùˆ Ø³Ù„ÙŠÙ…Ø§Ù†</div>
                <div class="char-title" id="charTitle">Ø§Ù„ØªØ§Ø¬Ø± Ø§Ù„Ø«Ø±ÙŠ</div>
                <div class="char-desc" id="charDesc">ØªØ§Ø¬Ø± Ø«Ø±ÙŠ ÙŠØ­Ø¨ Ø§Ù„Ø°Ù‡Ø¨</div>
                <div class="char-stats" id="charStats"></div>
                <div class="char-weapon" id="charWeapon">ğŸ—¡ï¸ Ø§Ù„Ø¹Ù‚Ø§Ù„</div>
            </div>
            <button class="char-arrow" id="charNext">â†</button>
        </div>
        <div class="city-select">
            <div class="city-card selected" id="cityBadaya" data-city="badaya">
                <div class="city-icon">ğŸœï¸</div>
                <div class="city-name">Ø§Ù„Ø¨Ø¯Ø§Ø¦Ø¹</div>
                <div class="city-desc">ØµØ­Ø±Ø§Ø¡ ÙˆÙ†Ø®ÙŠÙ„</div>
            </div>
            <div class="city-card locked" id="cityBaghdad" data-city="baghdad">
                <div class="city-icon">ğŸ›ï¸</div>
                <div class="city-name">Ø¨ØºØ¯Ø§Ø¯</div>
                <div class="city-desc">Ù…Ø¯ÙŠÙ†Ø© Ø­Ø¶Ø§Ø±ÙŠØ©</div>
                <div class="city-locked">ğŸ”’ Ø§Ù‚ØªÙ„ Ø§Ø¨Ùˆ Ø­Ù„Ø²Ù‡ Ø£ÙˆÙ„Ø§Ù‹</div>
            </div>
        </div>
        <button class="btn btn-primary" id="startBtn">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù„Ø¹Ø¨</button>
        <p class="high-score">Ø£Ø¹Ù„Ù‰ Ù†ØªÙŠØ¬Ø©: <span id="highScore">0</span> Ù‚ØªÙŠÙ„</p>
    </div>
    
    <div id="hud">
        <div class="hud-left">
            <div class="hud-bar"><div class="hud-bar-fill health-fill" id="healthBar" style="width: 100%"></div><span class="hud-bar-text">â¤ï¸ <span id="healthText">100/100</span></span></div>
            <div class="hud-bar"><div class="hud-bar-fill xp-fill" id="xpBar" style="width: 0%"></div><span class="hud-bar-text">â­ <span id="xpText">0/10</span></span></div>
            <span class="hud-stat level-text"><span class="hud-stat-icon">ğŸ“Š</span> <span id="levelText">Ø§Ù„Ù…Ø³ØªÙˆÙ‰: 1</span></span>
        </div>
        <div class="hud-right">
            <span class="hud-stat gold-text"><span class="hud-stat-icon">ğŸ’°</span> <span id="goldText">0</span></span>
            <span class="hud-stat kill-text"><span class="hud-stat-icon">ğŸ’€</span> <span id="killText">0</span></span>
            <span class="hud-stat timer-text"><span class="hud-stat-icon">â±ï¸</span> <span id="timerText">00:00</span></span>
        </div>
    </div>
    
    <div class="equipment-slots" id="equipmentSlots">
        <div class="slot-group" id="weaponSlots"></div>
        <div class="slot-group" id="bookSlots"></div>
    </div>
    
    <div id="miniMap">
        <canvas id="miniMapCanvas" width="110" height="110"></canvas>
    </div>
    
    <div id="levelUpModal">
        <div class="level-up-content">
            <h2 class="level-up-title">ğŸ‰ Ù…Ø³ØªÙˆÙ‰ Ø¬Ø¯ÙŠØ¯! ğŸ‰</h2>
            <div class="upgrade-options" id="upgradeOptions"></div>
        </div>
    </div>
    
    <div id="itemPickupModal">
        <div class="item-pickup-content">
            <div class="item-pickup-icon" id="itemIcon">â­</div>
            <div class="item-pickup-name" id="itemName">Ø§Ø³Ù… Ø§Ù„Ø£ÙŠØªÙ…</div>
            <div class="item-pickup-rarity" id="itemRarity">Ø£Ø³Ø·ÙˆØ±ÙŠ</div>
            <div class="item-pickup-desc" id="itemDesc">ÙˆØµÙ Ø§Ù„Ø£ÙŠØªÙ…</div>
            <button class="item-pickup-btn" id="itemContinueBtn">Ø§Ø³ØªÙ…Ø±Ø§Ø±</button>
        </div>
    </div>
    
    <div id="gameOverScreen">
        <h1 class="game-over-title" id="gameOverTitle">Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©</h1>
        <div class="unlock-message" id="unlockMessage" style="display: none;"></div>
        <div class="final-stats" id="finalStats"></div>
        <button class="btn btn-primary" id="restartBtn">Ø§Ù„Ø¹Ø¨ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰</button>
    </div>
    
    <div id="bossWarning">âš ï¸ ØªØ­Ø°ÙŠØ±! âš ï¸<br><span style="font-size: 1.2rem;">Ø§Ø¨Ùˆ Ø­Ù„Ø²Ù‡ Ù‚Ø§Ø¯Ù…!</span></div>
    <div id="pauseIndicator">â¸ï¸ Ø¥ÙŠÙ‚Ø§Ù Ù…Ø¤Ù‚Øª</div>
    
    <button id="pauseBtn">â¸ï¸</button>
    
    <div id="pauseMenu">
        <h1 class="pause-title">â¸ï¸ Ø¥ÙŠÙ‚Ø§Ù Ù…Ø¤Ù‚Øª</h1>
        <div class="pause-controls">
            <div class="volume-control">
                <div class="volume-label">
                    <span>ğŸµ ØµÙˆØª Ø§Ù„Ù…ÙˆØ³ÙŠÙ‚Ù‰</span>
                    <span id="musicVolText">50%</span>
                </div>
                <input type="range" class="volume-slider" id="musicVolume" min="0" max="100" value="50">
            </div>
            <div class="volume-control">
                <div class="volume-label">
                    <span>ğŸ”Š ØµÙˆØª Ø§Ù„Ù…Ø¤Ø«Ø±Ø§Øª</span>
                    <span id="sfxVolText">70%</span>
                </div>
                <input type="range" class="volume-slider" id="sfxVolume" min="0" max="100" value="70">
            </div>
            <div class="pause-buttons">
                <button class="pause-btn pause-btn-resume" id="resumeBtn">â–¶ï¸ Ø§Ø³ØªÙ…Ø±Ø§Ø±</button>
                <button class="pause-btn pause-btn-quit" id="quitBtn">ğŸšª Ø®Ø±ÙˆØ¬ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø©</button>
            </div>
        </div>
    </div>

    <script>
// ==================== GAME CONFIG ====================
const CONFIG = {
    WORLD_SIZE: 2000,
    TILE_SIZE: 32,
    PLAYER_LIGHT_RADIUS: 300,
    MAX_WEAPONS: 4,
    MAX_BOOKS: 4,
    MAX_UPGRADE_LEVEL: 20,
    BOSS_TIME: 600, // 10 minutes
    
    // Enemy base stats
    ENEMY_BASE_HP: 8,
    ENEMY_BASE_ATK: 5,
    ENEMY_BASE_SPEED: 55,
    
    // Scaling +20% per minute
    SCALING_PER_MIN: 0.20,
    
    // Weapon base damage
    WEAPON_BASE_DMG: 5
};

// ==================== MAP TILES (arabtown-tile.png 246x135) ====================
// Tileset is arranged with various buildings and decorations
// Each tile definition: { x, y, w, h, collision: true/false }
const ARABTOWN_TILES = {
    // Ground is the background color #c9a66b
    fence_top: { x: 0, y: 0, w: 133, h: 13, collision: true },
    gate_large: { x: 0, y: 14, w: 63, h: 50, collision: true },
    dome: { x: 65, y: 18, w: 30, h: 46, collision: true },
    tower: { x: 97, y: 0, w: 34, h: 64, collision: true },
    fence_small: { x: 0, y: 66, w: 39, h: 19, collision: true },
    palm: { x: 133, y: 42, w: 14, h: 22, collision: true },
    rock1: { x: 148, y: 57, w: 9, h: 7, collision: false },
    rock2: { x: 159, y: 56, w: 11, h: 8, collision: false },
    rock3: { x: 172, y: 57, w: 9, h: 7, collision: false },
    building_tall: { x: 205, y: 0, w: 40, h: 70, collision: true },
    shop1: { x: 42, y: 87, w: 50, h: 32, collision: true },
    shop2: { x: 94, y: 87, w: 50, h: 32, collision: true },
    house_small: { x: 147, y: 0, w: 30, h: 42, collision: true },
    market: { x: 147, y: 87, w: 50, h: 32, collision: true },
    well: { x: 178, y: 43, w: 24, h: 20, collision: true },
    person: { x: 133, y: 23, w: 12, h: 18, collision: false }
};

// ==================== RARITY ====================
const RARITY = {
    COMMON: { name: 'Ø´Ø§Ø¦Ø¹', color: '#9d9d9d', bonus: 1, weight: 50 },
    UNCOMMON: { name: 'ØºÙŠØ± Ø´Ø§Ø¦Ø¹', color: '#1eff00', bonus: 2, weight: 25 },
    RARE: { name: 'Ù†Ø§Ø¯Ø±', color: '#0070dd', bonus: 3, weight: 13 },
    EPIC: { name: 'Ù…Ù„Ø­Ù…ÙŠ', color: '#a335ee', bonus: 4, weight: 7 },
    LEGENDARY: { name: 'Ø£Ø³Ø·ÙˆØ±ÙŠ', color: '#ff8000', bonus: 5, weight: 5 }
};

function getRandomRarity(luck = 1) {
    // Luck affects rarity chances - higher luck = better rarities
    // Luck multiplies the weight of rare items and reduces common weight
    const adjustedRarity = {
        COMMON: { ...RARITY.COMMON, weight: RARITY.COMMON.weight / luck },
        UNCOMMON: { ...RARITY.UNCOMMON, weight: RARITY.UNCOMMON.weight * Math.sqrt(luck) },
        RARE: { ...RARITY.RARE, weight: RARITY.RARE.weight * luck },
        EPIC: { ...RARITY.EPIC, weight: RARITY.EPIC.weight * luck * 1.2 },
        LEGENDARY: { ...RARITY.LEGENDARY, weight: RARITY.LEGENDARY.weight * luck * 1.5 }
    };
    
    const total = Object.values(adjustedRarity).reduce((s, r) => s + r.weight, 0);
    let r = Math.random() * total;
    for (const [key, rar] of Object.entries(adjustedRarity)) { 
        r -= rar.weight; 
        if (r <= 0) return RARITY[key]; 
    }
    return RARITY.COMMON;
}

// ==================== CHARACTERS ====================
const CHARACTERS = {
    abuSulaiman: {
        name: 'Ø£Ø¨Ùˆ Ø³Ù„ÙŠÙ…Ø§Ù†', title: 'Ø§Ù„ØªØ§Ø¬Ø± Ø§Ù„Ø«Ø±ÙŠ',
        desc: 'Ø§ÙˆÙ„Ø§Ùˆ ÙŠØ­Ø¨ Ø§Ù„Ø¯Ø±Ø§Ù‡Ù…',
        weapon: 'agal',
        stats: { gold: 1.25, luck: 1.1, hp: 100, speed: 200, crit: 0, enemyBuff: 0 },
        passiveText: ['+25% Ø°Ù‡Ø¨', '+10% Ø­Ø¸'],
        colors: { body: '#f5f5f5', head: '#cc0000', skin: '#d4a574', legs: '#2a2a2a' }
    },
    jayzen: {
        name: 'Ø¬ÙŠØ²Ù†', title: 'Ø§Ù„Ù…Ù‚Ø§ØªÙ„ Ø§Ù„Ø´Ø±Ø³',
        desc: 'Ù„Ø­Ø¬ÙŠ Ø¨Ø³ Ù…ØªØ¹Ø§ÙÙŠ',
        weapon: 'rock',
        stats: { gold: 1, luck: 1, hp: 115, speed: 200, dmgReduce: 0.3, crit: 0, enemyBuff: 0 },
        passiveText: ['-30% Ø¶Ø±Ø± Ù…Ø³ØªÙ„Ù…', '+15% ØµØ­Ø©'],
        colors: { body: '#6a1b9a', head: '#cc3333', skin: '#d4a574', legs: '#333' }
    },
    noura: {
        name: 'Ù†ÙˆØ±Ø©', title: 'Ø§Ù„Ù…Ø±Ø£Ø© Ø§Ù„Ù‚ÙˆÙŠØ©',
        desc: 'Ø³ØªØ±ÙˆÙ†Ù‚ Ø§Ù†Ø¯Ø¨Ù†Ø¯Øª ÙˆÙ…Ù†',
        weapon: 'aura',
        stats: { gold: 1, luck: 1, hp: 100, speed: 200, pickup: 2.5, xpMult: 1.2, crit: 0, enemyBuff: 0 },
        passiveText: ['+150% Ù…ØºÙ†Ø§Ø·ÙŠØ³', '+20% Ø®Ø¨Ø±Ø©'],
        colors: { body: '#1e88e5', head: '#f5f5f5', skin: '#e8d5c4', legs: '#1565c0' }
    },
    bedouin: {
        name: 'Ø§Ù„Ø§Ø¹Ø±Ø§Ø¨ÙŠ', title: 'Ø¨Ø¯ÙˆÙŠ ØºØ¯Ø§Ø±',
        desc: 'Ø¨Ø¯ÙˆÙŠ ÙˆØºØ¯Ø§Ø±ØŒ Ø§Ù„Ù„Ù‡ ÙŠØ±Ø­Ù… Ù…Ù† Ø·Ù„Ø¹Ù‡Ù… Ù…Ù† Ø®ÙŠØ§Ù…Ù‡Ù…',
        weapon: 'spear',
        stats: { gold: 1, luck: 1, hp: 90, speed: 220, crit: 0.20, enemyBuff: 0 },
        passiveText: ['+20% Ø¶Ø±Ø¨Ø© Ø­Ø±Ø¬Ø©', '+10% Ø³Ø±Ø¹Ø©'],
        colors: { body: '#8b4513', head: '#d2691e', skin: '#c4956a', legs: '#2f1810' }
    },
    hawshabi: {
        name: 'Ø§Ù„Ø­ÙˆØ´Ø¨ÙŠ', title: 'ØµØ¹ÙˆØ¨Ø© Ù…ØªÙ‚Ø¯Ù…Ø©',
        desc: 'Ø§Ø°Ø§ ØªØ¨ÙŠ ØªØµØ¹Ø¨ Ø§Ù„ÙˆØ¶Ø¹ Ø¹Ù„ÙŠÙƒ Ø§Ù„Ø¹Ø¨ ÙÙŠÙ‡ ÙˆØ§Ø­ØªØ³Ø¨ Ø§Ù„Ø§Ø¬Ø±',
        weapon: 'sword',
        stats: { gold: 1.5, luck: 1.2, hp: 80, speed: 180, crit: 0, enemyBuff: 0.20 },
        passiveText: ['+20% Ù‚ÙˆØ© Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡', '+50% Ø°Ù‡Ø¨', '+20% Ø­Ø¸'],
        colors: { body: '#4a0000', head: '#1a1a1a', skin: '#d4a574', legs: '#222' }
    },
    layla: {
        name: 'Ù„ÙŠÙ„Ù‰', title: 'Ø§Ù„Ø³Ø§Ø­Ø±Ø©',
        desc: 'Ø³Ø§Ø­Ø±Ø© ØºØ§Ù…Ø¶Ø© ØªØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù†Ø§Ø± Ø§Ù„Ø²Ø±Ù‚Ø§Ø¡',
        weapon: 'flame',
        stats: { gold: 1, luck: 1, hp: 85, speed: 210, cooldown: 0.8, range: 1.3, crit: 0, enemyBuff: 0 },
        passiveText: ['-20% ÙƒÙˆÙ„Ø¯Ø§ÙˆÙ†', '+30% Ù…Ø¯Ù‰'],
        colors: { body: '#1a1a2e', head: '#4a0080', skin: '#e8d5c4', legs: '#0a0a15' }
    }
};

// ==================== WEAPONS ====================
const WEAPONS = {
    // iconPos: position in IconSet.png (24x24 grid) - {row, col}
    // projectileIcon: icon for the flying projectile
    agal: { name: 'Ø§Ù„Ø¹Ù‚Ø§Ù„', desc: 'Ø­Ø¨Ù„ ÙŠØ¯ÙˆØ± Ø­ÙˆÙ„Ùƒ ÙˆÙŠØ¶Ø±Ø¨ Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡', type: 'orbit', dmg: 5, cd: 0.1, range: 65, icon: 'â­•', iconPos: {row: 5, col: 2} },
    rock: { name: 'Ø§Ù„ØµØ®Ø±Ø©', desc: 'Ù‚Ø°ÙŠÙØ© ØªØ³ØªÙ‡Ø¯Ù Ø£Ù‚Ø±Ø¨ Ø¹Ø¯Ùˆ', type: 'projectile', dmg: 5, cd: 0.9, range: 380, icon: 'ğŸª¨', iconPos: {row: 3, col: 9}, projectileIcon: {row: 3, col: 9} },
    aura: { name: 'Ø§Ù„Ù‡ÙŠØ¨Ø©', desc: 'Ù‡Ø§Ù„Ø© Ø¶Ø±Ø± Ø®ÙÙŠÙØ© Ø­ÙˆÙ„Ùƒ', type: 'aura', dmg: 4, cd: 0.5, range: 55, icon: 'ğŸ’«', iconPos: {row: 10, col: 8} },
    spear: { name: 'Ø§Ù„Ø±Ù…Ø­', desc: 'ÙŠØ±Ù…ÙŠ Ø±Ù…Ø­ Ù„Ø£Ù‚Ø±Ø¨ Ø¹Ø¯Ùˆ', type: 'projectile', dmg: 5, cd: 0.45, range: 340, icon: 'ğŸ”±', iconPos: {row: 29, col: 4}, projectileIcon: {row: 29, col: 4} },
    sword: { name: 'Ø§Ù„Ø³ÙŠÙ', desc: 'Ø¶Ø±Ø¨Ø© Ù‚ÙˆØ³ÙŠØ© Ø£Ù…Ø§Ù…Ùƒ', type: 'melee', dmg: 5, cd: 0.65, range: 75, icon: 'âš”ï¸', iconPos: {row: 27, col: 0} },
    flame: { name: 'Ø§Ù„Ø´Ø¹Ù„Ø©', desc: 'ÙƒØ±Ø§Øª Ù†Ø§Ø±ÙŠØ© Ù„Ø£Ù‚Ø±Ø¨ Ø¹Ø¯Ùˆ', type: 'projectile', dmg: 5, cd: 0.3, range: 280, icon: 'ğŸ”¥', iconPos: {row: 16, col: 0}, projectileIcon: {row: 16, col: 1} },
    arrows: { name: 'Ø§Ù„Ø³Ù‡Ø§Ù…', desc: 'Ø³Ù‡Ø§Ù… ØªØ·Ù„Ù‚ Ø¨ÙƒÙ„ Ø§Ù„Ø§ØªØ¬Ø§Ù‡Ø§Øª', type: 'radial', dmg: 4, cd: 0.85, range: 320, icon: 'ğŸ¹', iconPos: {row: 30, col: 0}, projectileIcon: {row: 30, col: 6} },
    lightning: { name: 'Ø§Ù„Ø¨Ø±Ù‚', desc: 'ØµØ§Ø¹Ù‚Ø© Ø¹Ù„Ù‰ Ø¹Ø¯Ùˆ Ø¹Ø´ÙˆØ§Ø¦ÙŠ', type: 'lightning', dmg: 5, cd: 1.8, range: 420, icon: 'âš¡', iconPos: {row: 17, col: 4} },
    tornado: { name: 'Ø§Ù„Ø¯ÙˆØ§Ù…Ø©', desc: 'Ø¥Ø¹ØµØ§Ø± ÙŠØ¨Ø·Ø¦ Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡', type: 'tornado', dmg: 4, cd: 2.2, range: 160, icon: 'ğŸŒªï¸', iconPos: {row: 18, col: 0} },
    meteor: { name: 'Ø§Ù„Ù†ÙŠØ²Ùƒ', desc: 'ØµØ®ÙˆØ± ØªØ³Ù‚Ø· Ù…Ù† Ø§Ù„Ø³Ù…Ø§Ø¡', type: 'meteor', dmg: 5, cd: 1.6, range: 90, icon: 'â˜„ï¸', iconPos: {row: 16, col: 6} }
};

// ==================== BOOKS ====================
const BOOKS = {
    power: { name: 'ÙƒØªØ§Ø¨ Ø§Ù„Ù‚ÙˆØ©', desc: 'ÙŠØ²ÙŠØ¯ Ù‚ÙˆØ© Ø§Ù„Ù‡Ø¬ÙˆÙ…', stat: 'damage', val: 0.08, icon: 'ğŸ“•' },
    speed: { name: 'ÙƒØªØ§Ø¨ Ø§Ù„Ø³Ø±Ø¹Ø©', desc: 'ÙŠØ²ÙŠØ¯ Ø³Ø±Ø¹Ø© Ø§Ù„Ù‡Ø¬ÙˆÙ…', stat: 'atkSpd', val: 0.06, icon: 'ğŸ“—' },
    wind: { name: 'ÙƒØªØ§Ø¨ Ø§Ù„Ø±ÙŠØ­', desc: 'ÙŠØ²ÙŠØ¯ Ø³Ø±Ø¹Ø© Ø§Ù„Ø­Ø±ÙƒØ©', stat: 'moveSpd', val: 0.05, icon: 'ğŸ“˜' },
    wisdom: { name: 'ÙƒØªØ§Ø¨ Ø§Ù„Ø­ÙƒÙ…Ø©', desc: 'ÙŠØ²ÙŠØ¯ Ø§Ù„Ø®Ø¨Ø±Ø© Ø§Ù„Ù…ÙƒØªØ³Ø¨Ø©', stat: 'xp', val: 0.10, icon: 'ğŸ“™' },
    life: { name: 'ÙƒØªØ§Ø¨ Ø§Ù„Ø­ÙŠØ§Ø©', desc: 'ÙŠØ²ÙŠØ¯ Ø§Ù„ØµØ­Ø© Ø§Ù„Ù‚ØµÙˆÙ‰', stat: 'maxHp', val: 0.08, icon: 'ğŸ““' },
    armor: { name: 'ÙƒØªØ§Ø¨ Ø§Ù„Ø¯Ø±Ø¹', desc: 'ÙŠÙ‚Ù„Ù„ Ø§Ù„Ø¶Ø±Ø± Ø§Ù„Ù…Ø³ØªÙ„Ù…', stat: 'armor', val: 0.04, icon: 'ğŸ“”' },
    magnet: { name: 'ÙƒØªØ§Ø¨ Ø§Ù„Ù…ØºÙ†Ø§Ø·ÙŠØ³', desc: 'ÙŠØ²ÙŠØ¯ Ù…Ø¯Ù‰ Ø¬Ù…Ø¹ Ø§Ù„Ø£ÙŠØªÙ…Ø§Øª', stat: 'pickup', val: 0.12, icon: 'ğŸ“’' },
    luck: { name: 'ÙƒØªØ§Ø¨ Ø§Ù„Ø­Ø¸', desc: 'ÙŠØ²ÙŠØ¯ Ø­Ø¸ Ø¯Ø±ÙˆØ¨ Ø§Ù„Ø£ÙŠØªÙ…Ø§Øª', stat: 'luck', val: 0.06, icon: 'ğŸ“š' },
    curse: { name: 'ÙƒØªØ§Ø¨ Ø§Ù„Ù„Ø¹Ù†Ø©', desc: 'Ø£Ø¹Ø¯Ø§Ø¡ Ø£ÙƒØ«Ø±ØŒ Ø®Ø¨Ø±Ø© Ø£ÙƒØ«Ø±', stat: 'curse', val: 0.15, icon: 'ğŸ“–' },
    regen: { name: 'ÙƒØªØ§Ø¨ Ø§Ù„ØªØ¬Ø¯ÙŠØ¯', desc: 'Ø´ÙØ§Ø¡ Ù…Ø³ØªÙ…Ø± ÙƒÙ„ Ø«Ø§Ù†ÙŠØ©', stat: 'regen', val: 0.8, icon: 'ğŸ“œ' }
};

// ==================== ITEMS ====================
const ITEMS = {
    // Common (Ø´Ø§Ø¦Ø¹) - iconPos: {row, col} in IconSet.png (24x24 grid)
    mirinda: { name: 'Ø­Ù…Ø¶ÙŠØ§Øª', desc: 'Ø­Ø§Ø± ÙŠÙ„Ø¯ .. ÙŠÙ†Ø¹Ù†Ø´ ÙˆÙŠØ±Ø¬Ø¹ Ù„Ùƒ 10 Ù‡ÙŠÙ„', rarity: 'COMMON', effect: 'heal', val: 10, icon: 'ğŸŠ', sprite: 'item_mirinda' },
    dalla: { name: 'Ø¯Ù„Ù‡ Ù‚Ù‡ÙˆÙ‡', desc: 'Ø§Ù„Ù…Ù‡ÙŠÙ„Ù‡ ØªØ®Ù„ÙŠÙƒ Ù†Ø´ÙŠØ· ÙˆØ§Ø³Ø±Ø¹ 10 Ø«ÙˆØ§Ù†ÙŠ', rarity: 'COMMON', effect: 'tempSpeed', val: 0.15, dur: 10, icon: 'â˜•', sprite: 'item_dalla' },
    pebble: { name: 'Ø­Ø¨ Ø´Ù…Ø³ÙŠ', desc: '+10% Ø¶Ø±Ø± Ù„Ù…Ø¯Ø© 12 Ø«Ø§Ù†ÙŠØ©', rarity: 'COMMON', effect: 'tempDmg', val: 0.1, dur: 12, icon: 'ğŸŒ»', sprite: 'item_pebble' },
    klega: { name: 'ÙƒÙ„ÙŠØ¬Ù‡', desc: 'Ø§ÙˆÙ„Ø§Ùˆ Ù…Ù† Ø­Ù„Ø§ØªÙ‡ ØªÙ‡ÙŠÙ„Ùƒ 5', rarity: 'COMMON', effect: 'heal', val: 5, icon: 'ğŸª', sprite: 'item_klega' },
    copper: { name: 'Ù†Ø­Ø§Ø³', desc: '+5 Ø°Ù‡Ø¨', rarity: 'COMMON', effect: 'gold', val: 5, icon: 'ğŸª™', iconPos: {row: 11, col: 0} },
    
    // Rare (Ù†Ø§Ø¯Ø±)
    redPotion: { name: 'Ø¬Ø±Ø¹Ø© Ø­Ù…Ø±Ø§Ø¡', desc: 'ÙŠØ³ØªØ¹ÙŠØ¯ 30 ØµØ­Ø©', rarity: 'RARE', effect: 'heal', val: 30, icon: 'ğŸ§ª', iconPos: {row: 0, col: 0} },
    bluePotion: { name: 'Ø¬Ø±Ø¹Ø© Ø²Ø±Ù‚Ø§Ø¡', desc: '+30% Ø³Ø±Ø¹Ø© Ù‡Ø¬ÙˆÙ… Ù„Ù…Ø¯Ø© 15 Ø«Ø§Ù†ÙŠØ©', rarity: 'RARE', effect: 'tempAtkSpd', val: 0.3, dur: 15, icon: 'ğŸ§´', iconPos: {row: 0, col: 1} },
    amulet: { name: 'ØªÙ…ÙŠÙ…Ø©', desc: 'Ø¯Ø±Ø¹ ÙŠÙ…ØªØµ 20 Ø¶Ø±Ø±', rarity: 'RARE', effect: 'shield', val: 20, icon: 'ğŸ“¿', iconPos: {row: 12, col: 8} },
    hourglass: { name: 'Ø³Ø§Ø¹Ø© Ø±Ù…Ù„ÙŠØ©', desc: 'ÙŠØ¨Ø·Ø¦ Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡ 50% Ù„Ù…Ø¯Ø© 5 Ø«ÙˆØ§Ù†ÙŠ', rarity: 'RARE', effect: 'slow', val: 0.5, dur: 5, icon: 'â³', iconPos: {row: 9, col: 7} },
    silver: { name: 'ÙØ¶Ø©', desc: '+25 Ø°Ù‡Ø¨', rarity: 'RARE', effect: 'gold', val: 25, icon: 'ğŸ¥ˆ', iconPos: {row: 11, col: 1} },
    
    // Legendary (Ø£Ø³Ø·ÙˆØ±ÙŠ)
    elixir: { name: 'Ø¥ÙƒØ³ÙŠØ±', desc: 'ÙŠØ³ØªØ¹ÙŠØ¯ ÙƒÙ„ Ø§Ù„ØµØ­Ø© ÙˆÙŠØ²ÙŠØ¯ Ø§Ù„ØµØ­Ø© Ø§Ù„Ù‚ØµÙˆÙ‰ 20', rarity: 'LEGENDARY', effect: 'fullHeal', val: 20, icon: 'âš—ï¸', iconPos: {row: 0, col: 4} },
    dragonHeart: { name: 'Ù‚Ù„Ø¨ Ø§Ù„ØªÙ†ÙŠÙ†', desc: '+50% Ø¶Ø±Ø± Ù„Ù…Ø¯Ø© 25 Ø«Ø§Ù†ÙŠØ©', rarity: 'LEGENDARY', effect: 'tempDmg', val: 0.5, dur: 25, icon: 'â¤ï¸â€ğŸ”¥', iconPos: {row: 10, col: 0} },
    arika: { name: 'Ø¹Ø±ÙŠÙƒÙ‡', desc: 'Ø¥Ø°Ø§ Ù…ØªØŒ ØªØ¹ÙˆØ¯ Ù„Ù„Ø­ÙŠØ§Ø© Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø©', rarity: 'LEGENDARY', effect: 'revive', val: 1, icon: 'ğŸš', sprite: 'item_arika' },
    crown: { name: 'ØªØ§Ø¬ Ø°Ù‡Ø¨ÙŠ', desc: '+50% Ø°Ù‡Ø¨ Ø¨Ø´ÙƒÙ„ Ø¯Ø§Ø¦Ù…', rarity: 'LEGENDARY', effect: 'permGold', val: 0.5, icon: 'ğŸ‘‘', iconPos: {row: 12, col: 0} },
    star: { name: 'Ù†Ø¬Ù…Ø© Ø§Ù„ØµØ­Ø±Ø§Ø¡', desc: 'ØªØ­ØµÙ„ Ø¹Ù„Ù‰ Ø³Ù„Ø§Ø­ Ø£Ùˆ ÙƒØªØ§Ø¨ Ø¹Ø´ÙˆØ§Ø¦ÙŠ', rarity: 'LEGENDARY', effect: 'randomEquip', val: 1, icon: 'â­', iconPos: {row: 10, col: 8} },
    khazouq: { name: 'Ø®Ø§Ø²ÙˆÙ‚', desc: 'ÙŠØ²ÙŠØ¯ Ù†Ø³Ø¨Ø© Ø¸Ù‡ÙˆØ± Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡ 10%ØŒ Ø£Ù†Øª ØºØ¨ÙŠ Ù„ÙŠØ´ Ø£Ø®Ø°ØªÙ‡ØŸ', rarity: 'LEGENDARY', effect: 'moreEnemies', val: 0.10, icon: 'ğŸ†', iconPos: {row: 2, col: 5} }
};

// ==================== ENEMIES ====================
const ENEMIES = {
    // Speed reduced by 30% (multiply by 0.7)
    wolf: { name: 'Ø°Ø¦Ø¨', hpM: 1, atkM: 1, spdM: 0.84, xp: 2, time: 0, color: '#6a6a6a' },
    scorpion: { name: 'Ø¹Ù‚Ø±Ø¨', hpM: 0.7, atkM: 0.8, spdM: 1.05, xp: 2, time: 0, color: '#ffa500' },
    dhub: { name: 'Ø¶Ø¨', hpM: 2, atkM: 1.2, spdM: 0.42, xp: 4, time: 60, color: '#5a8a5a', zig: true },
    snake: { name: 'Ø«Ø¹Ø¨Ø§Ù†', hpM: 1.2, atkM: 1, spdM: 0.7, xp: 3, time: 120, color: '#2d5a27', ranged: true },
    hyena: { name: 'Ø¶Ø¨Ø¹', hpM: 0.8, atkM: 0.9, spdM: 0.91, xp: 2, time: 180, color: '#8b7355', pack: true },
    eagle: { name: 'Ù†Ø³Ø±', hpM: 1, atkM: 1.3, spdM: 1.12, xp: 4, time: 240, color: '#4a3728' },
    lion: { name: 'Ø£Ø³Ø¯', hpM: 3, atkM: 2, spdM: 0.56, xp: 8, time: 300, color: '#c4a35a' },
    djinn: { name: 'Ø¬Ù†ÙŠ', hpM: 1.5, atkM: 1.5, spdM: 0.98, xp: 6, time: 360, color: '#4a0080', tp: true },
    ghoul: { name: 'ØºÙˆÙ„', hpM: 5, atkM: 2.5, spdM: 0.35, xp: 12, time: 420, color: '#2a2a2a' },
    knight: { name: 'ÙØ§Ø±Ø³', hpM: 2.5, atkM: 1.8, spdM: 0.7, xp: 10, time: 480, color: '#1a1a1a' }
};

const BOSS = { name: 'Ø§Ø¨Ùˆ Ø­Ù„Ø²Ù‡', hp: 8000, atk: 35, spd: 55, color: '#8b0000' };

// ==================== ASSET LOADER ====================
class AssetLoader {
    constructor() {
        this.images = {};
        this.loaded = false;
    }
    
    loadImage(name, src) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => { this.images[name] = img; resolve(img); };
            img.onerror = reject;
            img.src = src;
        });
    }
    
    // Remove white background from enemy sprites
    removeWhiteBackground(name) {
        const img = this.images[name];
        if (!img) return;
        
        const canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0);
        
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Make white/near-white pixels transparent
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i], g = data[i + 1], b = data[i + 2];
            // If pixel is white or near-white (threshold 240)
            if (r > 240 && g > 240 && b > 240) {
                data[i + 3] = 0; // Set alpha to 0 (transparent)
            }
            // Also handle light gray backgrounds
            else if (r > 220 && g > 220 && b > 220 && Math.abs(r - g) < 15 && Math.abs(g - b) < 15) {
                data[i + 3] = 0;
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
        
        // Create new image from processed canvas
        const newImg = new Image();
        newImg.src = canvas.toDataURL();
        this.images[name] = newImg;
    }
    
    async loadAll() {
        const assets = [
            // Characters
            ['char_001', 'assets/characters/Char_001.png'],
            ['char_001_idle', 'assets/characters/Char_001_Idle.png'],
            ['char_002', 'assets/characters/Char_002.png'],
            ['char_002_idle', 'assets/characters/Char_002_Idle.png'],
            ['char_003', 'assets/characters/Char_003.png'],
            ['char_003_idle', 'assets/characters/Char_003_Idle.png'],
            ['char_004', 'assets/characters/Char_004.png'],
            ['char_004_idle', 'assets/characters/Char_004_Idle.png'],
            ['char_005', 'assets/characters/Char_005.png'],
            ['char_005_idle', 'assets/characters/Char_005_Idle.png'],
            ['char_006', 'assets/characters/Char_006.png'],
            ['char_006_idle', 'assets/characters/Char_006_Idle.png'],
            
            // Desert Rogue (Bedouin) sprite
            ['desert_rogue', 'assets/characters/DesertRogue.png'],
            
            // Boss sprite (Abu Halza)
            ['boss_halza', 'assets/characters/1769115033155(1).png'],
            
            // Enemies - New monster sprites
            ['enemy_wolf', 'assets/enemies/NB_01.png'],
            ['enemy_scorpion', 'assets/enemies/NB_09.png'],
            ['enemy_dhub', 'assets/enemies/NB_03.png'],
            ['enemy_snake', 'assets/enemies/NB_06.png'],
            ['enemy_hyena', 'assets/enemies/NB_02.png'],
            ['enemy_eagle', 'assets/enemies/NB_29.png'],
            ['enemy_lion', 'assets/enemies/NB_26.png'],
            ['enemy_djinn', 'assets/enemies/NB_05.png'],
            ['enemy_ghoul', 'assets/enemies/NB_08.png'],
            ['enemy_knight', 'assets/enemies/NB_16.png'],
            
            // Pickups
            ['gold_coin', 'assets/pickups/gold_coin.png'],
            ['xp_gem', 'assets/pickups/xp_gem.png'],
            
            // Item Icons
            ['item_mirinda', 'assets/New Items Icon/mirinda.png'],
            ['item_dalla', 'assets/New Items Icon/dalla.png'],
            ['item_klega', 'assets/New Items Icon/klega.png'],
            ['item_arika', 'assets/New Items Icon/arika.png'],
            ['item_pebble', 'assets/New Items Icon/pebble.png'],
            
            // IconSet sprite sheet (24x24 icons)
            ['iconset', 'assets/IconSet.png'],
            
            // Desert Map
            ['desert_tiles', 'assets/New Maps/DesertTileset16x16/Tileset16x16/DesertTilemap16x16.png'],
            
            // Arab Town Tileset (main map)
            ['arabtown', 'assets/New Maps/arabtown-tile.png'],
            
            // Forest Map (Baghdad)
            ['forest_tiles', 'assets/New Maps/gentle sheets/gentle forest v01.png'],
            
            // Buildings
            ['building_house', 'assets/Yellow Buildings/House1.png'],
            ['building_castle', 'assets/Yellow Buildings/Castle.png'],
            ['building_tower', 'assets/Yellow Buildings/Tower.png'],
            ['building_house2', 'assets/Yellow Buildings/House2.png'],
            ['building_house3', 'assets/Yellow Buildings/House3.png'],
            
            // Decorations
            ['rock1', 'assets/Terrain/Decorations/Rocks/Rock1.png'],
            ['rock2', 'assets/Terrain/Decorations/Rocks/Rock2.png'],
            ['rock3', 'assets/Terrain/Decorations/Rocks/Rock3.png'],
            ['bush1', 'assets/Terrain/Decorations/Bushes/Bushe1.png'],
            ['bush2', 'assets/Terrain/Decorations/Bushes/Bushe2.png'],
            ['trees', 'assets/New Maps/gentle sheets/gentle trees 80x96 v01.png'],
            
            // UI Elements
            ['ui_bar_base', 'assets/UI Elements/UI Elements/Bars/BigBar_Base.png'],
            ['ui_bar_fill', 'assets/UI Elements/UI Elements/Bars/BigBar_Fill.png'],
            
            // Backgrounds
            ['sand_tile', 'assets/backgrounds/sand_tile.png'],
            ['tiles', 'assets/tiles-all-32x32.png'],
            
            // Effects
            ['fx_spark', 'assets/01.png'],
            ['fx_fire_small', 'assets/02.png'],
            ['fx_explosion', 'assets/03.png'],
            ['fx_fireball', 'assets/04.png'],
            ['fx_flames', 'assets/05.png'],
            ['fx_ice', 'assets/10.png'],
            ['fx_magic', 'assets/15.png'],
            ['fx_heal', 'assets/20.png'],
            ['fx_dust', 'assets/25.png'],
            ['fx_circle', 'assets/30.png'],
            ['fx_water', 'assets/35.png']
        ];
        
        try {
            await Promise.all(assets.map(([name, src]) => this.loadImage(name, src)));
            
            // Remove white background from enemy sprites
            const enemySprites = ['enemy_wolf', 'enemy_scorpion', 'enemy_dhub', 'enemy_snake', 
                                  'enemy_hyena', 'enemy_eagle', 'enemy_lion', 'enemy_djinn', 
                                  'enemy_ghoul', 'enemy_knight', 'wolf', 'scorpion', 'dhub'];
            
            // Small delay to ensure images are fully loaded before processing
            await new Promise(resolve => setTimeout(resolve, 100));
            
            enemySprites.forEach(name => {
                if (this.images[name]) this.removeWhiteBackground(name);
            });
            
            this.loaded = true;
            console.log('All assets loaded!');
        } catch (e) {
            console.warn('Some assets failed to load, using fallback rendering');
            this.loaded = false;
        }
    }
    
    get(name) {
        return this.images[name];
    }
    
    // Get icon position from IconSet (24x24 grid)
    // Row and col are 0-indexed
    getIconRect(row, col, size = 24) {
        return { x: col * size, y: row * size, w: size, h: size };
    }
}

// Character sprite mappings
const CHAR_SPRITES = {
    abuSulaiman: { sprite: 'char_003', idle: 'char_003_idle', frameWidth: 48, frameHeight: 48, frames: 4 },
    jayzen: { sprite: 'char_006', idle: 'char_006_idle', frameWidth: 48, frameHeight: 48, frames: 4 },
    noura: { sprite: 'char_005', idle: 'char_005_idle', frameWidth: 48, frameHeight: 48, frames: 4 },
    bedouin: { sprite: 'desert_rogue', idle: 'desert_rogue', frameWidth: 40, frameHeight: 40, frames: 8, rows: 4 },
    hawshabi: { sprite: 'char_004', idle: 'char_004_idle', frameWidth: 48, frameHeight: 48, frames: 4 },
    layla: { sprite: 'char_001', idle: 'char_001_idle', frameWidth: 48, frameHeight: 48, frames: 4 }
};

// Enemy sprite mappings - using new monster sprites
const ENEMY_SPRITES = {
    wolf: { sprite: 'enemy_wolf', width: 80, height: 80 },
    scorpion: { sprite: 'enemy_scorpion', width: 80, height: 80 },
    dhub: { sprite: 'enemy_dhub', width: 80, height: 80 },
    snake: { sprite: 'enemy_snake', width: 80, height: 80 },
    hyena: { sprite: 'enemy_hyena', width: 80, height: 80 },
    eagle: { sprite: 'enemy_eagle', width: 80, height: 80 },
    lion: { sprite: 'enemy_lion', width: 80, height: 80 },
    djinn: { sprite: 'enemy_djinn', width: 80, height: 80 },
    ghoul: { sprite: 'enemy_ghoul', width: 80, height: 80 },
    knight: { sprite: 'enemy_knight', width: 80, height: 80 }
};

// ==================== AUDIO ====================
class Audio {
    constructor() { 
        this.ctx = null; 
        this.bgm = null;
        this.bgmPlaying = false;
        this.musicVolume = 0.5;
        this.sfxVolume = 0.7;
    }
    
    init() { 
        if (!this.ctx) {
            try { 
                this.ctx = new (window.AudioContext || window.webkitAudioContext)(); 
            } catch(e) {} 
        }
        
        // Load background music
        if (!this.bgm) {
            this.bgm = new window.Audio('assets/8-bit Desert Tune [7CaoOAgagxM].mp3');
            this.bgm.loop = true;
            this.bgm.volume = this.musicVolume;
        }
    }
    
    setMusicVolume(vol) {
        this.musicVolume = vol;
        if (this.bgm) this.bgm.volume = vol;
    }
    
    setSfxVolume(vol) {
        this.sfxVolume = vol;
    }
    
    tone(f, d, t='square', v=0.12) {
        if (!this.ctx) return;
        const actualVol = v * this.sfxVolume;
        if (actualVol < 0.01) return;
        
        const o = this.ctx.createOscillator(), g = this.ctx.createGain();
        o.type = t; o.frequency.value = f; o.connect(g); g.connect(this.ctx.destination);
        g.gain.setValueAtTime(actualVol, this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + d);
        o.start(); o.stop(this.ctx.currentTime + d);
    }
    
    startBGM() {
        if (this.bgmPlaying || !this.bgm) return;
        this.bgm.currentTime = 0;
        this.bgm.play().catch(e => console.log('BGM autoplay blocked'));
        this.bgmPlaying = true;
    }
    
    stopBGM() {
        if (this.bgm) {
            this.bgm.pause();
            this.bgm.currentTime = 0;
        }
        this.bgmPlaying = false;
    }
    
    pauseBGM() {
        if (this.bgm && this.bgmPlaying) {
            this.bgm.pause();
        }
    }
    
    resumeBGM() {
        if (this.bgm && this.bgmPlaying) {
            this.bgm.play().catch(e => {});
        }
    }
    
    hit() { this.tone(150, 0.1, 'sawtooth', 0.15); }
    shoot() { this.tone(320, 0.03); }
    pickup() { this.tone(520, 0.04, 'sine'); }
    levelUp() { [523,659,784,1047].forEach((f,i) => setTimeout(() => this.tone(f,0.1,'sine',0.15), i*60)); }
    victory() { [523,659,784,880,1047].forEach((f,i) => setTimeout(() => this.tone(f,0.18,'sine',0.2), i*100)); }
    death() { this.tone(160, 0.2, 'sawtooth'); this.tone(80, 0.25, 'sawtooth'); }
    bossWarn() { this.tone(80, 0.35, 'sawtooth', 0.25); setTimeout(() => this.tone(60, 0.35, 'sawtooth', 0.25), 400); }
    itemDrop() { this.tone(700, 0.08, 'sine', 0.2); this.tone(900, 0.12, 'sine', 0.15); }
}

// ==================== PARTICLES ====================
class Particles {
    constructor() { this.list = []; this.stains = []; }
    
    emit(x, y, n, opt = {}) {
        for (let i = 0; i < n; i++) {
            const a = Math.random() * Math.PI * 2, s = (opt.minS || 35) + Math.random() * ((opt.maxS || 100) - (opt.minS || 35));
            this.list.push({ 
                x, y, 
                vx: Math.cos(a) * s, vy: Math.sin(a) * s, 
                color: opt.color || '#fff', 
                size: opt.size || (2 + Math.random() * 2.5), 
                life: opt.life || 0.6, 
                maxLife: opt.life || 0.6, 
                gravity: opt.gravity || 0,
                type: opt.type || 'circle',
                shrink: opt.shrink !== false
            });
        }
    }
    
    blood(x, y) { 
        this.emit(x, y, 10, { color: '#8b0000', minS: 35, maxS: 130, gravity: 160 }); 
        this.stains.push({ x, y, size: 5 + Math.random() * 8, alpha: 0.4 }); 
        if (this.stains.length > 100) this.stains.shift(); 
    }
    
    spark(x, y, color = '#ffff00') {
        this.emit(x, y, 5, { color, minS: 80, maxS: 180, size: 3, life: 0.25, type: 'spark' });
    }
    
    dust(x, y) {
        this.emit(x, y, 6, { color: '#a08060', minS: 20, maxS: 60, size: 4, life: 0.5, gravity: -30, shrink: true });
    }
    
    heal(x, y) {
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            this.list.push({ 
                x: x + Math.cos(angle) * 20, 
                y: y + Math.sin(angle) * 20, 
                vx: Math.cos(angle) * -30, vy: -50 + Math.random() * 20, 
                color: '#44ff44', size: 4, life: 0.6, maxLife: 0.6, gravity: -50, type: 'circle', shrink: true
            });
        }
    }
    
    gold(x, y) {
        for (let i = 0; i < 6; i++) {
            const angle = Math.random() * Math.PI * 2;
            this.list.push({ 
                x, y, 
                vx: Math.cos(angle) * 60, vy: -80 + Math.random() * 40, 
                color: '#ffd700', size: 3, life: 0.5, maxLife: 0.5, gravity: 100, type: 'star', shrink: false
            });
        }
    }
    
    update(dt) { 
        this.list = this.list.filter(p => { 
            p.x += p.vx * dt; 
            p.y += p.vy * dt; 
            p.vy += p.gravity * dt; 
            p.life -= dt; 
            return p.life > 0; 
        }); 
    }
    
    draw(ctx, cam) {
        // Draw stains
        for (const s of this.stains) { 
            ctx.globalAlpha = s.alpha || 0.3; 
            ctx.fillStyle = '#4a0000';
            ctx.beginPath(); 
            ctx.arc(s.x - cam.x, s.y - cam.y, s.size, 0, Math.PI * 2); 
            ctx.fill(); 
        }
        
        // Draw particles
        for (const p of this.list) { 
            const alpha = p.life / p.maxLife;
            ctx.globalAlpha = alpha;
            ctx.fillStyle = p.color;
            
            const sx = p.x - cam.x, sy = p.y - cam.y;
            const size = p.shrink ? p.size * alpha : p.size;
            
            if (p.type === 'spark') {
                // Draw spark as line
                ctx.strokeStyle = p.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(sx - p.vx * 0.02, sy - p.vy * 0.02);
                ctx.lineTo(sx, sy);
                ctx.stroke();
            } else if (p.type === 'star') {
                // Draw small star shape
                ctx.beginPath();
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2;
                    ctx.moveTo(sx, sy);
                    ctx.lineTo(sx + Math.cos(angle) * size * 2, sy + Math.sin(angle) * size * 2);
                }
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(sx, sy, size, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // Default circle
                ctx.beginPath(); 
                ctx.arc(sx, sy, size, 0, Math.PI * 2); 
                ctx.fill();
            }
        }
        ctx.globalAlpha = 1;
    }
}

// ==================== FLOAT TEXT ====================
class FloatText {
    constructor(x, y, text, color = '#fff', size = 14) { this.x = x; this.y = y; this.text = text; this.color = color; this.size = size; this.life = 0.7; this.vy = -45; }
    update(dt) { this.y += this.vy * dt; this.life -= dt; }
    draw(ctx, cam) { ctx.globalAlpha = this.life / 0.7; ctx.fillStyle = this.color; ctx.font = `bold ${this.size}px Cairo`; ctx.textAlign = 'center'; ctx.fillText(this.text, this.x - cam.x, this.y - cam.y); ctx.globalAlpha = 1; }
}

// ==================== SPRITE EFFECTS ====================
class SpriteEffect {
    constructor(x, y, spriteKey, frameWidth, frameHeight, totalFrames, duration, scale = 1) {
        this.x = x; 
        this.y = y;
        this.spriteKey = spriteKey;
        this.frameWidth = frameWidth;
        this.frameHeight = frameHeight;
        this.totalFrames = totalFrames;
        this.duration = duration;
        this.scale = scale;
        this.time = 0;
        this.done = false;
    }
    
    update(dt) {
        this.time += dt;
        if (this.time >= this.duration) this.done = true;
    }
    
    draw(ctx, cam, assets) {
        if (this.done) return;
        const sprite = assets && assets.get(this.spriteKey);
        if (!sprite) return;
        
        const progress = this.time / this.duration;
        const frame = Math.min(Math.floor(progress * this.totalFrames), this.totalFrames - 1);
        const sx = this.x - cam.x, sy = this.y - cam.y;
        
        ctx.imageSmoothingEnabled = false;
        ctx.globalAlpha = 1 - progress * 0.3;
        
        const drawW = this.frameWidth * this.scale;
        const drawH = this.frameHeight * this.scale;
        
        // Calculate frame position (assuming horizontal strip)
        const frameX = frame * this.frameWidth;
        
        ctx.drawImage(
            sprite,
            frameX, 0, this.frameWidth, this.frameHeight,
            sx - drawW / 2, sy - drawH / 2, drawW, drawH
        );
        
        ctx.globalAlpha = 1;
    }
}

// ==================== PLAYER ====================
class Player {
    constructor(x, y, charId) {
        this.x = x; this.y = y; this.charId = charId;
        const c = CHARACTERS[charId];
        this.maxHp = c.stats.hp || 100; this.hp = this.maxHp;
        this.speed = c.stats.speed || 200;
        this.dmgMult = 1; this.atkSpd = 1;
        this.pickupRange = 40 * (c.stats.pickup || 1);
        this.xpMult = c.stats.xpMult || 1;
        this.goldMult = c.stats.gold || 1;
        this.dmgReduce = c.stats.dmgReduce || 0;
        this.luck = c.stats.luck || 1;
        this.crit = c.stats.crit || 0;
        this.enemyBuff = c.stats.enemyBuff || 0;
        this.extraEnemySpawn = 0;
        this.armor = 0; this.regen = 0; this.curse = 0;
        this.range = c.stats.range || 1;
        this.cdMult = c.stats.cooldown || 1;
        
        this.weapons = [{ id: c.weapon, level: 1, upgrades: [] }];
        this.books = [];
        this.xp = 0; this.level = 1; this.gold = 0; this.kills = 0;
        this.invuln = 0; this.facing = 1; this.vx = 0; this.vy = 0; this.anim = 0;
        this.shield = 0; this.hasRevive = false; this.tempBuffs = [];
        this.wTimers = {};
        this.width = 32; this.height = 45;
    }
    
    getDmg(w) {
        let d = CONFIG.WEAPON_BASE_DMG + (w.level - 1) * 0.5;
        // Each upgrade adds damage based on rarity: Common +1, Uncommon +2, Rare +3, Epic +4, Legendary +5
        w.upgrades.forEach(u => d += u.rarity.bonus * 1.2);
        d *= this.dmgMult;
        this.tempBuffs.filter(b => b.type === 'dmg').forEach(b => d *= (1 + b.val));
        if (this.crit > 0 && Math.random() < this.crit) d *= 2;
        return d;
    }
    getCD(w) { let m = this.cdMult / this.atkSpd; this.tempBuffs.filter(b => b.type === 'atkSpd').forEach(b => m /= (1 + b.val)); return Math.max(0.08, WEAPONS[w.id].cd * m * (1 - (w.level - 1) * 0.015)); }
    getRange(w) { return WEAPONS[w.id].range * this.range * (1 + (w.level - 1) * 0.025); }
    
    findNearest(game, maxD = 450) {
        let near = null, minD = maxD;
        for (const e of game.enemies) { const d = Math.hypot(e.x - this.x, e.y - this.y); if (d < minD) { minD = d; near = e; } }
        if (game.boss) { const d = Math.hypot(game.boss.x - this.x, game.boss.y - this.y); if (d < minD) near = game.boss; }
        return near;
    }
    
    update(dt, input, game) {
        let dx = 0, dy = 0;
        if (input.left) dx -= 1; if (input.right) dx += 1; if (input.up) dy -= 1; if (input.down) dy += 1;
        if (input.joy) { dx += input.joy.x; dy += input.joy.y; }
        const mag = Math.hypot(dx, dy);
        if (mag > 0) {
            dx /= mag; dy /= mag;
            let spd = this.speed; this.tempBuffs.filter(b => b.type === 'speed').forEach(b => spd *= (1 + b.val));
            this.vx = dx * spd; this.vy = dy * spd;
            if (dx !== 0) this.facing = dx > 0 ? 1 : -1;
        } else { this.vx = 0; this.vy = 0; }
        
        // Try to move, check collision with map obstacles
        const newX = this.x + this.vx * dt;
        const newY = this.y + this.vy * dt;
        
        // Check X movement
        if (!game.map.checkCollision(newX, this.y, this.width, this.height)) {
            this.x = newX;
        }
        // Check Y movement
        if (!game.map.checkCollision(this.x, newY, this.width, this.height)) {
            this.y = newY;
        }
        
        // Keep within world bounds
        this.x = Math.max(-CONFIG.WORLD_SIZE/2, Math.min(CONFIG.WORLD_SIZE/2, this.x));
        this.y = Math.max(-CONFIG.WORLD_SIZE/2, Math.min(CONFIG.WORLD_SIZE/2, this.y));
        if (this.invuln > 0) this.invuln -= dt;
        this.anim += dt;
        if (this.regen > 0) this.hp = Math.min(this.maxHp, this.hp + this.regen * dt);
        this.tempBuffs = this.tempBuffs.filter(b => { b.dur -= dt; return b.dur > 0; });
        
        const target = this.findNearest(game);
        this.weapons.forEach(w => {
            if (!this.wTimers[w.id]) this.wTimers[w.id] = 0;
            this.wTimers[w.id] -= dt;
            if (this.wTimers[w.id] <= 0) { this.fire(w, game, target); this.wTimers[w.id] = this.getCD(w); }
        });
    }
    
    fire(w, game, target) {
        const data = WEAPONS[w.id], dmg = this.getDmg(w), range = this.getRange(w);
        switch(data.type) {
            case 'projectile':
                if (target && Math.hypot(target.x - this.x, target.y - this.y) < range) {
                    const a = Math.atan2(target.y - this.y, target.x - this.x);
                    const isFlame = w.id === 'flame';
                    const isBlueFlame = this.charId === 'layla' && isFlame;
                    const isRock = w.id === 'rock';
                    const isSpear = w.id === 'spear';
                    
                    let projType = 'normal';
                    if (isBlueFlame) projType = 'blue_fire';
                    else if (isFlame) projType = 'fire';
                    else if (isRock) projType = 'rock';
                    else if (isSpear) projType = 'spear';
                    
                    game.proj.push({ 
                        x: this.x, y: this.y, 
                        vx: Math.cos(a) * 360, vy: Math.sin(a) * 360, 
                        dmg, life: 2.2, size: isFlame ? 10 : (isSpear ? 8 : 6), 
                        color: isBlueFlame ? '#00aaff' : (isFlame ? '#ff4500' : '#8b4513'), 
                        pierce: w.level > 10 ? 2 : 1,
                        type: projType,
                        iconPos: data.projectileIcon
                    });
                    game.audio.shoot();
                    // Muzzle flash effect
                    if (isFlame) {
                        game.spriteEffects.push(new SpriteEffect(this.x, this.y, 'fx_fire_small', 24, 24, 6, 0.2, 1.2));
                    }
                }
                break;
            case 'radial': {
                const n = 4 + Math.floor(w.level / 4);
                for (let i = 0; i < n; i++) { 
                    const a = (i / n) * Math.PI * 2; 
                    game.proj.push({ 
                        x: this.x, y: this.y, 
                        vx: Math.cos(a) * 300, vy: Math.sin(a) * 300, 
                        dmg: dmg * 0.65, life: 1.8, size: 6, 
                        color: '#8B4513', type: 'arrow',
                        iconPos: data.projectileIcon
                    }); 
                }
                game.audio.shoot();
                break;
            }
            case 'lightning': {
                const ts = game.enemies.filter(e => Math.hypot(e.x - this.x, e.y - this.y) < range);
                if (ts.length > 0) { 
                    const t = ts[Math.floor(Math.random() * ts.length)]; 
                    game.fx.push({ type: 'lightning', x: t.x, y: t.y, life: 0.25 }); 
                    // Add spark and electric effects
                    game.spriteEffects.push(new SpriteEffect(t.x, t.y, 'fx_spark', 24, 24, 5, 0.3, 1.5));
                    game.particles.spark(t.x, t.y, '#ffff88');
                    game.particles.spark(t.x, t.y, '#ffffff');
                    if (t.takeDmg(dmg, game)) game.killEnemy(t); 
                    game.audio.tone(650, 0.06, 'sawtooth'); 
                }
                break;
            }
            case 'meteor': {
                const n = 1 + Math.floor(w.level / 4);
                for (let i = 0; i < n; i++) {
                    const mx = this.x + (Math.random() - 0.5) * range * 2;
                    const my = this.y + (Math.random() - 0.5) * range * 2;
                    game.fx.push({ type: 'meteor', x: mx, y: my, dmg, radius: 55, life: 0.75, delay: i * 0.12, hit: false });
                }
                game.audio.tone(200, 0.1, 'sawtooth');
                break;
            }
            case 'tornado':
                game.fx.push({ type: 'tornado', x: this.x + this.facing * 35, y: this.y, vx: this.facing * 85, vy: 0, dmg: dmg * 0.35, slow: 0.5, life: 3.2 + w.level * 0.12, radius: 35 });
                // Dust effect
                game.spriteEffects.push(new SpriteEffect(this.x + this.facing * 35, this.y, 'fx_dust', 24, 24, 5, 0.4, 1.2));
                break;
        }
    }
    
    takeDmg(amt, game) {
        if (this.invuln > 0) return;
        if (this.shield > 0) { const ab = Math.min(this.shield, amt); this.shield -= ab; amt -= ab; if (amt <= 0) return; }
        const actual = amt * (1 - this.dmgReduce) * (1 - Math.min(0.65, this.armor * 0.025));
        this.hp -= actual; this.invuln = 0.35;
        game.audio.hit(); game.shake = 0.12;
        game.texts.push(new FloatText(this.x, this.y - 20, `-${Math.round(actual)}`, '#f00'));
        if (this.hp <= 0) {
            if (this.hasRevive) { this.hasRevive = false; this.hp = this.maxHp * 0.5; this.invuln = 1.2; game.texts.push(new FloatText(this.x, this.y - 35, 'Ø¥Ø­ÙŠØ§Ø¡!', '#ffd700', 18)); }
            else game.over(false);
        }
    }
    
    draw(ctx, cam, assets) {
        const sx = this.x - cam.x, sy = this.y - cam.y;
        
        // Draw shadow under player
        ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
        ctx.beginPath();
        ctx.ellipse(sx, sy + 20, 18, 8, 0, 0, Math.PI * 2);
        ctx.fill();
        
        if (this.invuln > 0 && Math.floor(this.invuln * 12) % 2 === 0) ctx.globalAlpha = 0.35;
        
        // Draw character sprite
        const c = CHARACTERS[this.charId].colors;
        ctx.save();
        
        // Try to draw sprite if available
        const spriteInfo = CHAR_SPRITES[this.charId];
        const isMoving = Math.abs(this.vx) > 10 || Math.abs(this.vy) > 10;
        const spriteKey = isMoving ? spriteInfo.sprite : spriteInfo.idle;
        const sprite = assets && assets.get(spriteKey);
        
        if (sprite && spriteInfo) {
            // Calculate animation frame
            const frameTime = 0.15;
            const totalFrames = spriteInfo.frames;
            const currentFrame = Math.floor(this.anim / frameTime) % totalFrames;
            
            // Determine direction row (0=down, 1=left, 2=right, 3=up)
            let row = 0;
            if (isMoving) {
                if (Math.abs(this.vx) > Math.abs(this.vy)) {
                    row = this.vx > 0 ? 2 : 1; // right or left
                } else {
                    row = this.vy > 0 ? 0 : 3; // down or up
                }
            } else {
                row = this.facing > 0 ? 2 : 1;
            }
            
            // Clamp row to available rows
            if (spriteInfo.rows) {
                row = Math.min(row, spriteInfo.rows - 1);
            }
            
            const frameX = currentFrame * spriteInfo.frameWidth;
            const frameY = row * spriteInfo.frameHeight;
            
            // Draw sprite
            const scale = 1.5;
            const drawW = spriteInfo.frameWidth * scale;
            const drawH = spriteInfo.frameHeight * scale;
            
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(
                sprite,
                frameX, frameY, spriteInfo.frameWidth, spriteInfo.frameHeight,
                sx - drawW / 2, sy - drawH / 2, drawW, drawH
            );
        } else {
            // Fallback to simple rendering
            const c = CHARACTERS[this.charId].colors;
            if (this.facing < 0) { ctx.translate(sx, sy); ctx.scale(-1, 1); ctx.translate(-sx, sy); }
            
            ctx.fillStyle = c.body;
            ctx.fillRect(sx - 10, sy - 8, 20, 26);
            ctx.fillStyle = c.head;
            ctx.fillRect(sx - 8, sy - 24, 16, 8);
            ctx.fillStyle = c.skin;
            ctx.fillRect(sx - 7, sy - 16, 14, 10);
            ctx.fillStyle = '#000';
            ctx.fillRect(sx - 4, sy - 13, 2, 2);
            ctx.fillRect(sx + 2, sy - 13, 2, 2);
            ctx.fillStyle = c.legs;
            ctx.fillRect(sx - 6, sy + 18, 5, 8);
            ctx.fillRect(sx + 1, sy + 18, 5, 8);
        }
        
        ctx.restore();
        ctx.globalAlpha = 1;
        
        // Weapon visuals
        this.weapons.forEach(w => {
            const data = WEAPONS[w.id], range = this.getRange(w);
            if (data.type === 'orbit') {
                const n = 4 + Math.floor(w.level / 5);
                ctx.fillStyle = '#333';
                for (let i = 0; i < n; i++) {
                    const a = this.anim * 2 + (i / n) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.arc(sx + Math.cos(a) * range, sy + Math.sin(a) * range, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (data.type === 'melee') {
                const timer = this.wTimers[w.id] || 0, cd = this.getCD(w);
                if (timer > cd * 0.8) {
                    ctx.strokeStyle = 'rgba(150, 150, 150, 0.4)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(sx, sy, range, -0.5 * this.facing, 0.5 * this.facing);
                    ctx.stroke();
                }
            }
            if (data.type === 'aura') {
                ctx.strokeStyle = 'rgba(100, 50, 150, 0.2)';
                ctx.lineWidth = 2;
                ctx.setLineDash([4, 6]);
                ctx.beginPath();
                ctx.arc(sx, sy, range, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        });
        
        // Shield indicator
        if (this.shield > 0) {
            ctx.strokeStyle = 'rgba(80, 160, 255, 0.5)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(sx, sy, 30, 0, Math.PI * 2);
            ctx.stroke();
        }
    }
}

// ==================== ENEMY ====================
class Enemy {
    constructor(x, y, type, gameTime, buff = 0) {
        this.x = x; this.y = y; this.type = type;
        const e = ENEMIES[type];
        const scale = 1 + (gameTime / 60) * CONFIG.SCALING_PER_MIN;
        const buffScale = 1 + buff;
        this.maxHp = Math.round(CONFIG.ENEMY_BASE_HP * e.hpM * scale * buffScale);
        this.hp = this.maxHp;
        this.atk = CONFIG.ENEMY_BASE_ATK * e.atkM * scale * buffScale;
        this.spd = CONFIG.ENEMY_BASE_SPEED * e.spdM;
        this.xp = e.xp; this.color = e.color;
        this.vx = 0; this.vy = 0; this.hitFlash = 0; this.slow = 1; this.slowT = 0;
        this.zigT = 0; this.zigD = 1; this.tpT = 0; this.atkT = 0;
        this.width = 28; this.height = 28;
        this.zig = e.zig; this.ranged = e.ranged; this.tp = e.tp;
        this.animTime = Math.random() * 2; // Random start for animation variety
    }
    
    update(dt, player, enemies, game) {
        const dx = player.x - this.x, dy = player.y - this.y, dist = Math.hypot(dx, dy);
        if (this.slowT > 0) { this.slowT -= dt; if (this.slowT <= 0) this.slow = 1; }
        if (dist > 0) {
            let mx = dx / dist, my = dy / dist;
            if (this.zig) { this.zigT += dt; if (this.zigT > 0.35) { this.zigT = 0; this.zigD *= -1; } mx = mx * 0.7 + (-my * this.zigD) * 0.3; my = my * 0.7 + (mx * this.zigD) * 0.3; }
            if (this.tp) { this.tpT += dt; if (this.tpT > 1.5 && dist > 70) { this.tpT = 0; const a = Math.random() * Math.PI * 2; this.x = player.x + Math.cos(a) * 100; this.y = player.y + Math.sin(a) * 100; game.particles.emit(this.x, this.y, 6, { color: '#4a0080' }); } }
            if (this.ranged && dist < 220 && dist > 50) { this.atkT -= dt; if (this.atkT <= 0) { this.atkT = 1.2; const a = Math.atan2(dy, dx); game.eProj.push({ x: this.x, y: this.y, vx: Math.cos(a) * 160, vy: Math.sin(a) * 160, dmg: this.atk * 0.4, life: 2.2, size: 3, color: this.color }); } }
            let sepX = 0, sepY = 0;
            for (const o of enemies) { if (o === this) continue; const ox = this.x - o.x, oy = this.y - o.y, od = Math.hypot(ox, oy); if (od < 25 && od > 0) { sepX += ox / od * (25 - od) / 25; sepY += oy / od * (25 - od) / 25; } }
            mx += sepX * 0.35; my += sepY * 0.35;
            const m = Math.hypot(mx, my); if (m > 0) { this.vx = (mx / m) * this.spd * this.slow; this.vy = (my / m) * this.spd * this.slow; }
        }
        this.x += this.vx * dt; this.y += this.vy * dt;
        if (this.hitFlash > 0) this.hitFlash -= dt;
        this.animTime += dt; // Update animation
    }
    
    takeDmg(amt, game) { this.hp -= amt; this.hitFlash = 0.06; game.texts.push(new FloatText(this.x + (Math.random() - 0.5) * 12, this.y - 12, Math.round(amt).toString(), '#ff0')); return this.hp <= 0; }
    
    draw(ctx, cam, assets) {
        const sx = this.x - cam.x, sy = this.y - cam.y;
        if (this.hitFlash > 0) ctx.globalAlpha = 0.55;
        
        // Try to draw sprite if available
        const spriteInfo = ENEMY_SPRITES[this.type];
        const sprite = assets && spriteInfo && assets.get(spriteInfo.sprite);
        
        if (sprite) {
            ctx.save();
            ctx.imageSmoothingEnabled = false;
            
            const scale = 0.6; // Scale down the large sprites
            const drawW = spriteInfo.width * scale;
            const drawH = spriteInfo.height * scale;
            
            // Flip based on movement direction
            if (this.vx < 0) {
                ctx.translate(sx, sy);
                ctx.scale(-1, 1);
                ctx.drawImage(sprite, -drawW / 2, -drawH / 2, drawW, drawH);
            } else {
                ctx.drawImage(sprite, sx - drawW / 2, sy - drawH / 2, drawW, drawH);
            }
            
            ctx.restore();
        } else {
            // Fallback to colored circle
            ctx.fillStyle = this.color;
            ctx.beginPath(); 
            ctx.arc(sx, sy, 14, 0, Math.PI * 2); 
            ctx.fill();
            // Eyes
            ctx.fillStyle = '#ff0';
            ctx.fillRect(sx - 4, sy - 3, 3, 3); 
            ctx.fillRect(sx + 1, sy - 3, 3, 3);
        }
        
        ctx.globalAlpha = 1;
        
        // Health bar with better styling
        if (this.hp < this.maxHp) { 
            const barWidth = 36;
            const barHeight = 5;
            const barX = sx - barWidth / 2;
            const barY = sy - 30;
            const hpPercent = this.hp / this.maxHp;
            
            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; 
            ctx.fillRect(barX - 1, barY - 1, barWidth + 2, barHeight + 2); 
            
            // Health color based on percentage
            let hpColor;
            if (hpPercent > 0.5) hpColor = '#00ff00';
            else if (hpPercent > 0.25) hpColor = '#ffff00';
            else hpColor = '#ff0000';
            
            ctx.fillStyle = hpColor; 
            ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);
            
            // Border
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.strokeRect(barX - 1, barY - 1, barWidth + 2, barHeight + 2);
        }
        
        // Shadow under enemy
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.beginPath();
        ctx.ellipse(sx, sy + 18, 16, 6, 0, 0, Math.PI * 2);
        ctx.fill();
    }
}

// ==================== BOSS ====================
class Boss {
    constructor(x, y, buff = 0) {
        this.x = x; this.y = y;
        this.maxHp = BOSS.hp * (1 + buff); this.hp = this.maxHp;
        this.atk = BOSS.atk * (1 + buff); this.spd = BOSS.spd;
        this.phase = 1; this.atkT = 0; this.specT = 0; this.hitFlash = 0;
        this.gasT = 0; // Gas attack timer
        this.width = 100; this.height = 120;
        this.facing = 1;
    }
    update(dt, player, game) {
        const pct = this.hp / this.maxHp; this.phase = pct < 0.33 ? 3 : pct < 0.66 ? 2 : 1;
        const dx = player.x - this.x, dy = player.y - this.y, dist = Math.hypot(dx, dy);
        
        // Update facing direction
        if (dx !== 0) this.facing = dx > 0 ? 1 : -1;
        
        if (dist > 0) { const s = this.spd * (1 + (3 - this.phase) * 0.12); this.x += (dx / dist) * s * dt; this.y += (dy / dist) * s * dt; }
        
        // Green gas attack
        this.atkT -= dt;
        if (this.atkT <= 0) { 
            this.atkT = 1.8 / this.phase; 
            const a = Math.atan2(dy, dx); 
            // Shoot green gas projectiles
            for (let i = -3; i <= 3; i++) {
                game.eProj.push({ 
                    x: this.x, y: this.y, 
                    vx: Math.cos(a + i * 0.15) * 180, 
                    vy: Math.sin(a + i * 0.15) * 180, 
                    dmg: this.atk * 0.7, life: 2.5, size: 12, 
                    color: '#44ff44', type: 'gas'
                }); 
            }
            game.audio.tone(150, 0.15, 'sawtooth');
        }
        
        // Poison cloud special attack
        this.gasT -= dt;
        if (this.gasT <= 0 && this.phase >= 2) {
            this.gasT = 4 / this.phase;
            // Create poison cloud around boss
            for (let i = 0; i < 8; i++) {
                const a = (i / 8) * Math.PI * 2;
                game.eProj.push({
                    x: this.x + Math.cos(a) * 50, y: this.y + Math.sin(a) * 50,
                    vx: Math.cos(a) * 60, vy: Math.sin(a) * 60,
                    dmg: this.atk * 0.4, life: 3, size: 18,
                    color: '#22aa22', type: 'gas'
                });
            }
        }
        
        // Summon minions
        if (this.phase >= 2) { 
            this.specT -= dt; 
            if (this.specT <= 0) { 
                this.specT = 4; 
                const types = ['wolf', 'scorpion']; 
                for (let i = 0; i < this.phase * 2; i++) { 
                    const a = Math.random() * Math.PI * 2; 
                    game.enemies.push(new Enemy(this.x + Math.cos(a) * 80, this.y + Math.sin(a) * 80, types[Math.floor(Math.random() * types.length)], game.time, player.enemyBuff)); 
                } 
            } 
        }
        if (this.hitFlash > 0) this.hitFlash -= dt;
    }
    takeDmg(amt, game) { this.hp -= amt; this.hitFlash = 0.06; game.texts.push(new FloatText(this.x + (Math.random() - 0.5) * 25, this.y - 25, Math.round(amt).toString(), '#ff0', 16)); return this.hp <= 0; }
    draw(ctx, cam, assets) {
        const sx = this.x - cam.x, sy = this.y - cam.y;
        
        // Draw shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.beginPath();
        ctx.ellipse(sx, sy + 55, 45, 15, 0, 0, Math.PI * 2);
        ctx.fill();
        
        if (this.hitFlash > 0) ctx.globalAlpha = 0.55;
        
        // Try to draw boss sprite
        const sprite = assets && assets.get('boss_halza');
        if (sprite) {
            ctx.save();
            ctx.imageSmoothingEnabled = false;
            
            // Flip based on facing direction
            if (this.facing < 0) {
                ctx.translate(sx, sy);
                ctx.scale(-1, 1);
                ctx.drawImage(sprite, -60, -70, 120, 140);
            } else {
                ctx.drawImage(sprite, sx - 60, sy - 70, 120, 140);
            }
            ctx.restore();
        } else {
            // Fallback to simple drawing
            ctx.fillStyle = '#6a0dad';
            ctx.beginPath(); ctx.ellipse(sx, sy, 40, 35, 0, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(sx, sy - 35, 25, 18, 0, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#ff0';
            ctx.fillRect(sx - 12, sy - 40, 6, 6); ctx.fillRect(sx + 6, sy - 40, 6, 6);
        }
        
        ctx.globalAlpha = 1;
        
        // Phase indicator glow
        if (this.phase >= 2) {
            ctx.strokeStyle = this.phase === 3 ? 'rgba(255, 0, 0, 0.5)' : 'rgba(255, 165, 0, 0.5)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(sx, sy, 65, 0, Math.PI * 2);
            ctx.stroke();
        }
    }
}

// ==================== PICKUPS ====================
class Pickup {
    constructor(x, y, type, val) { this.x = x; this.y = y; this.type = type; this.val = val; this.bob = Math.random() * Math.PI * 2; }
    update(dt) { this.bob += dt * 3.5; }
    draw(ctx, cam, assets) {
        const sx = this.x - cam.x, sy = this.y - cam.y + Math.sin(this.bob) * 3;
        
        const sprite = this.type === 'xp' ? assets && assets.get('xp_gem') : assets && assets.get('gold_coin');
        
        if (sprite) {
            ctx.imageSmoothingEnabled = false;
            const size = this.type === 'xp' ? 18 : 16;
            ctx.drawImage(sprite, sx - size / 2, sy - size / 2, size, size);
        } else {
            // Fallback
            if (this.type === 'xp') { 
                ctx.fillStyle = '#0f0'; 
                ctx.beginPath(); 
                ctx.moveTo(sx, sy - 6); 
                ctx.lineTo(sx + 6, sy); 
                ctx.lineTo(sx, sy + 6); 
                ctx.lineTo(sx - 6, sy); 
                ctx.fill(); 
            } else { 
                ctx.fillStyle = '#ffd700'; 
                ctx.beginPath(); 
                ctx.arc(sx, sy, 5, 0, Math.PI * 2); 
                ctx.fill(); 
            }
        }
    }
}

class ItemDrop {
    constructor(x, y, id) { this.x = x; this.y = y; this.id = id; this.bob = Math.random() * Math.PI * 2; this.glow = 0; }
    update(dt) { this.bob += dt * 3.5; this.glow += dt * 4; }
    draw(ctx, cam, assets) {
        const sx = this.x - cam.x, sy = this.y - cam.y + Math.sin(this.bob) * 4;
        const item = ITEMS[this.id];
        const rarityColor = RARITY[item.rarity].color;
        
        // Glowing background circle
        const glowSize = 22 + Math.sin(this.glow) * 4;
        ctx.fillStyle = rarityColor + '50';
        ctx.beginPath(); 
        ctx.arc(sx, sy, glowSize, 0, Math.PI * 2); 
        ctx.fill();
        
        // Inner circle
        ctx.fillStyle = '#000000cc';
        ctx.beginPath(); 
        ctx.arc(sx, sy, 18, 0, Math.PI * 2); 
        ctx.fill();
        
        // Border
        ctx.strokeStyle = rarityColor;
        ctx.lineWidth = 3;
        ctx.beginPath(); 
        ctx.arc(sx, sy, 18, 0, Math.PI * 2); 
        ctx.stroke();
        
        // Try to draw sprite if available
        const sprite = item.sprite && assets && assets.get(item.sprite);
        const iconset = assets && assets.get('iconset');
        
        if (sprite) {
            ctx.imageSmoothingEnabled = false;
            const size = 28;
            ctx.drawImage(sprite, sx - size/2, sy - size/2, size, size);
        } else if (item.iconPos && iconset) {
            // Draw from IconSet sprite sheet
            ctx.imageSmoothingEnabled = false;
            const iconSize = 24;
            const drawSize = 28;
            ctx.drawImage(
                iconset,
                item.iconPos.col * iconSize, item.iconPos.row * iconSize,
                iconSize, iconSize,
                sx - drawSize/2, sy - drawSize/2, drawSize, drawSize
            );
        } else {
            // Fallback to emoji icon
            ctx.font = 'bold 20px Arial'; 
            ctx.textAlign = 'center'; 
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#fff';
            ctx.fillText(item.icon, sx, sy);
        }
    }
}

// ==================== GAME ====================
// ==================== MAP SYSTEM ====================
class MapSystem {
    constructor() {
        this.obstacles = []; // {x, y, w, h} - collision boxes
        this.decorations = []; // {x, y, tile} - visual only
        this.generated = false;
    }
    
    generate(worldSize) {
        this.obstacles = [];
        this.decorations = [];
        this.walls = []; // Border walls
        
        const halfWorld = worldSize / 2;
        const wallThickness = 40;
        
        // Create visible border walls around the map
        // Top wall
        for (let x = -halfWorld; x < halfWorld; x += 120) {
            this.walls.push({
                x: x + 60, y: -halfWorld + 20,
                w: 130, h: wallThickness,
                tile: 'fence_top'
            });
        }
        // Bottom wall
        for (let x = -halfWorld; x < halfWorld; x += 120) {
            this.walls.push({
                x: x + 60, y: halfWorld - 20,
                w: 130, h: wallThickness,
                tile: 'fence_top'
            });
        }
        // Left wall
        for (let y = -halfWorld; y < halfWorld; y += 80) {
            this.walls.push({
                x: -halfWorld + 20, y: y + 40,
                w: wallThickness, h: 90,
                tile: 'fence_top',
                vertical: true
            });
        }
        // Right wall
        for (let y = -halfWorld; y < halfWorld; y += 80) {
            this.walls.push({
                x: halfWorld - 20, y: y + 40,
                w: wallThickness, h: 90,
                tile: 'fence_top',
                vertical: true
            });
        }
        
        // Add corner towers
        const corners = [
            { x: -halfWorld + 40, y: -halfWorld + 40 },
            { x: halfWorld - 40, y: -halfWorld + 40 },
            { x: -halfWorld + 40, y: halfWorld - 40 },
            { x: halfWorld - 40, y: halfWorld - 40 }
        ];
        for (const corner of corners) {
            this.walls.push({
                x: corner.x, y: corner.y,
                w: 60, h: 80,
                tile: 'tower'
            });
        }
        
        const buildingTypes = ['gate_large', 'dome', 'tower', 'building_tall', 'house_small', 'shop1', 'shop2'];
        
        // Generate buildings in a grid pattern with some randomness
        const gridSize = 300;
        for (let gx = -halfWorld + 100; gx < halfWorld - 100; gx += gridSize) {
            for (let gy = -halfWorld + 100; gy < halfWorld - 100; gy += gridSize) {
                // Skip center area (player spawn)
                if (Math.abs(gx) < 200 && Math.abs(gy) < 200) continue;
                
                // Random chance to place a building
                if (Math.random() < 0.4) {
                    const type = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
                    const tile = ARABTOWN_TILES[type];
                    const x = gx + (Math.random() - 0.5) * 100;
                    const y = gy + (Math.random() - 0.5) * 100;
                    
                    this.obstacles.push({
                        x: x, y: y,
                        w: tile.w * 2, h: tile.h * 2,
                        tile: type
                    });
                }
                
                // Palm trees
                if (Math.random() < 0.3) {
                    const px = gx + (Math.random() - 0.5) * 150;
                    const py = gy + (Math.random() - 0.5) * 150;
                    const palmTile = ARABTOWN_TILES.palm;
                    this.obstacles.push({
                        x: px, y: py,
                        w: palmTile.w * 2, h: palmTile.h * 2,
                        tile: 'palm'
                    });
                }
                
                // Fence sections
                if (Math.random() < 0.15) {
                    const fx = gx + (Math.random() - 0.5) * 120;
                    const fy = gy + (Math.random() - 0.5) * 120;
                    const fenceTile = ARABTOWN_TILES.fence_small;
                    this.obstacles.push({
                        x: fx, y: fy,
                        w: fenceTile.w * 2, h: fenceTile.h * 2,
                        tile: 'fence_small'
                    });
                }
            }
        }
        
        // Add random rocks (decorations, no collision)
        for (let i = 0; i < 100; i++) {
            this.decorations.push({
                x: (Math.random() - 0.5) * worldSize * 0.9,
                y: (Math.random() - 0.5) * worldSize * 0.9,
                tile: ['rock1', 'rock2', 'rock3'][Math.floor(Math.random() * 3)]
            });
        }
        
        this.generated = true;
    }
    
    checkCollision(x, y, w, h) {
        // Check obstacles (buildings, palms, etc.)
        for (const obs of this.obstacles) {
            if (x + w/2 > obs.x - obs.w/2 && 
                x - w/2 < obs.x + obs.w/2 &&
                y + h/2 > obs.y - obs.h/2 && 
                y - h/2 < obs.y + obs.h/2) {
                return true;
            }
        }
        // Check border walls
        for (const wall of this.walls) {
            if (x + w/2 > wall.x - wall.w/2 && 
                x - w/2 < wall.x + wall.w/2 &&
                y + h/2 > wall.y - wall.h/2 && 
                y - h/2 < wall.y + wall.h/2) {
                return true;
            }
        }
        return false;
    }
    
    draw(ctx, cam, assets) {
        const tileset = assets.get('arabtown');
        if (!tileset) return;
        
        ctx.imageSmoothingEnabled = false;
        
        // Draw border walls first
        for (const wall of this.walls) {
            const sx = wall.x - cam.x, sy = wall.y - cam.y;
            if (sx < -200 || sx > ctx.canvas.width + 200 || sy < -200 || sy > ctx.canvas.height + 200) continue;
            
            const tile = ARABTOWN_TILES[wall.tile];
            if (tile) {
                const scale = 2;
                ctx.save();
                if (wall.vertical) {
                    // Rotate for vertical walls
                    ctx.translate(sx, sy);
                    ctx.rotate(Math.PI / 2);
                    ctx.drawImage(tileset, tile.x, tile.y, tile.w, tile.h,
                        -tile.w * scale / 2, -tile.h * scale / 2, tile.w * scale, tile.h * scale);
                } else {
                    ctx.drawImage(tileset, tile.x, tile.y, tile.w, tile.h,
                        sx - tile.w * scale / 2, sy - tile.h * scale / 2, tile.w * scale, tile.h * scale);
                }
                ctx.restore();
            }
        }
        
        // Draw decorations (rocks)
        for (const dec of this.decorations) {
            const sx = dec.x - cam.x, sy = dec.y - cam.y;
            if (sx < -50 || sx > ctx.canvas.width + 50 || sy < -50 || sy > ctx.canvas.height + 50) continue;
            
            const tile = ARABTOWN_TILES[dec.tile];
            if (tile) {
                const scale = 2;
                ctx.drawImage(tileset, tile.x, tile.y, tile.w, tile.h, 
                    sx - tile.w * scale / 2, sy - tile.h * scale / 2, tile.w * scale, tile.h * scale);
            }
        }
        
        // Draw obstacles (buildings, palms, fences)
        for (const obs of this.obstacles) {
            const sx = obs.x - cam.x, sy = obs.y - cam.y;
            if (sx < -150 || sx > ctx.canvas.width + 150 || sy < -150 || sy > ctx.canvas.height + 150) continue;
            
            const tile = ARABTOWN_TILES[obs.tile];
            if (tile) {
                const scale = 2;
                const drawW = tile.w * scale;
                const drawH = tile.h * scale;
                // Draw centered on position, with bottom at y position
                ctx.drawImage(tileset, tile.x, tile.y, tile.w, tile.h,
                    sx - drawW/2, sy - drawH + 10, 
                    drawW, drawH);
            }
        }
    }
}

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.audio = new Audio();
        this.particles = new Particles();
        this.assets = new AssetLoader();
        this.map = new MapSystem();
        
        this.state = 'loading';
        this.charIdx = 0;
        this.charIds = Object.keys(CHARACTERS);
        this.city = 'badaya';
        
        this.player = null;
        this.enemies = [];
        this.boss = null;
        this.proj = [];
        this.eProj = [];
        this.pickups = [];
        this.items = [];
        this.texts = [];
        this.fx = [];
        this.spriteEffects = [];
        
        this.cam = { x: 0, y: 0 };
        this.shake = 0;
        this.input = { up: false, down: false, left: false, right: false, joy: null };
        
        this.spawnT = 0; this.time = 0;
        this.bossSpawned = false; this.bossWarnShown = false;
        this.globalSlow = 0;
        
        this.pendingItem = null;
        
        this.highScore = parseInt(localStorage.getItem('goldBloodHighScore') || '0');
        this.baghdadUnlocked = localStorage.getItem('baghdadUnlocked') === 'true';
        
        // Cached tile image
        this.sandTilePattern = null;
        
        this.lastTime = 0;
        this.init();
    }
    
    async init() {
        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.setupInput();
        
        // Show loading screen
        this.drawLoading();
        
        // Load assets
        await this.assets.loadAll();
        
        // Create sand tile pattern if loaded
        if (this.assets.get('sand_tile')) {
            this.sandTilePattern = this.ctx.createPattern(this.assets.get('sand_tile'), 'repeat');
        }
        
        this.state = 'menu';
        this.setupMenu();
        requestAnimationFrame(t => this.loop(t));
    }
    
    drawLoading() {
        const ctx = this.ctx;
        const cx = this.canvas.width / 2, cy = this.canvas.height / 2;
        const time = Date.now() / 1000;
        
        // Dark gradient background
        const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, Math.max(this.canvas.width, this.canvas.height));
        gradient.addColorStop(0, '#1a1a2e');
        gradient.addColorStop(1, '#0a0a0f');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Animated particles in background
        for (let i = 0; i < 20; i++) {
            const angle = (time * 0.5 + i * 0.3) % (Math.PI * 2);
            const dist = 80 + Math.sin(time * 2 + i) * 20;
            const x = cx + Math.cos(angle) * dist;
            const y = cy + Math.sin(angle) * dist;
            ctx.fillStyle = `rgba(255, 215, 0, ${0.3 + Math.sin(time * 3 + i) * 0.2})`;
            ctx.beginPath();
            ctx.arc(x, y, 3, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Game title
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 32px Cairo';
        ctx.textAlign = 'center';
        ctx.fillText('Ø°Ù‡Ø¨ Ø£ØµÙØ± Ø£Ùˆ Ø¯Ù… Ø£Ø­Ù…Ø±', cx, cy - 60);
        
        // Loading text with animation
        const dots = '.'.repeat(Math.floor(time * 2) % 4);
        ctx.fillStyle = '#ffffff';
        ctx.font = '20px Cairo';
        ctx.fillText('Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù„Ø¹Ø¨Ø©' + dots, cx, cy);
        
        // Loading bar
        const barWidth = 200, barHeight = 8;
        const progress = (Math.sin(time * 3) + 1) / 2; // Animated progress
        
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(cx - barWidth / 2, cy + 30, barWidth, barHeight);
        
        const loadGradient = ctx.createLinearGradient(cx - barWidth / 2, 0, cx + barWidth / 2, 0);
        loadGradient.addColorStop(0, '#ff8c00');
        loadGradient.addColorStop(0.5, '#ffd700');
        loadGradient.addColorStop(1, '#ff8c00');
        ctx.fillStyle = loadGradient;
        ctx.fillRect(cx - barWidth / 2, cy + 30, barWidth * progress, barHeight);
        
        ctx.strokeStyle = 'rgba(255, 215, 0, 0.5)';
        ctx.lineWidth = 1;
        ctx.strokeRect(cx - barWidth / 2, cy + 30, barWidth, barHeight);
        
        // Sub text
        ctx.fillStyle = '#666';
        ctx.font = '14px Cairo';
        ctx.fillText('Loading game assets...', cx, cy + 60);
    }
    
    resize() { this.canvas.width = window.innerWidth; this.canvas.height = window.innerHeight; }
    
    setupMenu() {
        document.getElementById('highScore').textContent = this.highScore;
        if (this.baghdadUnlocked) { document.getElementById('cityBaghdad').classList.remove('locked'); document.getElementById('cityBaghdad').querySelector('.city-locked').style.display = 'none'; }
        this.updateCharDisplay();
        document.getElementById('charPrev').onclick = () => { this.charIdx = (this.charIdx - 1 + this.charIds.length) % this.charIds.length; this.updateCharDisplay(); };
        document.getElementById('charNext').onclick = () => { this.charIdx = (this.charIdx + 1) % this.charIds.length; this.updateCharDisplay(); };
        document.querySelectorAll('.city-card').forEach(card => { card.onclick = () => { if (card.classList.contains('locked')) return; document.querySelectorAll('.city-card').forEach(c => c.classList.remove('selected')); card.classList.add('selected'); this.city = card.dataset.city; }; });
        document.getElementById('startBtn').onclick = () => this.start();
        document.getElementById('restartBtn').onclick = () => this.restart();
        document.getElementById('itemContinueBtn').onclick = () => this.continueFromItem();
        
        // Pause button
        document.getElementById('pauseBtn').onclick = () => this.pause();
        document.getElementById('resumeBtn').onclick = () => this.pause();
        document.getElementById('quitBtn').onclick = () => this.quitToMenu();
        
        // Volume controls
        document.getElementById('musicVolume').oninput = (e) => {
            const vol = e.target.value / 100;
            this.audio.setMusicVolume(vol);
            document.getElementById('musicVolText').textContent = e.target.value + '%';
        };
        document.getElementById('sfxVolume').oninput = (e) => {
            const vol = e.target.value / 100;
            this.audio.setSfxVolume(vol);
            document.getElementById('sfxVolText').textContent = e.target.value + '%';
        };
    }
    
    updateCharDisplay() {
        const id = this.charIds[this.charIdx], c = CHARACTERS[id];
        document.getElementById('charName').textContent = c.name;
        document.getElementById('charTitle').textContent = c.title;
        document.getElementById('charDesc').textContent = c.desc;
        document.getElementById('charWeapon').innerHTML = `ğŸ—¡ï¸ ${WEAPONS[c.weapon].name}`;
        let html = '';
        c.passiveText.forEach(p => { const neg = p.includes('Ù‚ÙˆØ© Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡'); html += `<div class="char-stat"><span class="char-stat-label">â€¢</span><span class="${neg ? 'char-stat-negative' : 'char-stat-value'}">${p}</span></div>`; });
        document.getElementById('charStats').innerHTML = html;
        
        const canvas = document.getElementById('charPreview'), ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, 120, 120);
        
        // Try to draw sprite
        const spriteInfo = CHAR_SPRITES[id];
        const sprite = this.assets && this.assets.get(spriteInfo.idle);
        
        if (sprite) {
            ctx.imageSmoothingEnabled = false;
            const scale = 2;
            const drawW = spriteInfo.frameWidth * scale;
            const drawH = spriteInfo.frameHeight * scale;
            // Draw idle frame (row 0, frame 0)
            ctx.drawImage(
                sprite,
                0, 0, spriteInfo.frameWidth, spriteInfo.frameHeight,
                (120 - drawW) / 2, (120 - drawH) / 2, drawW, drawH
            );
        } else {
            // Fallback to simple drawing
            const col = c.colors;
            ctx.fillStyle = col.body; ctx.fillRect(42, 42, 36, 45);
            ctx.fillStyle = col.head; ctx.fillRect(45, 18, 30, 14);
            ctx.fillStyle = col.skin; ctx.fillRect(48, 32, 24, 16);
            ctx.fillStyle = '#000'; ctx.fillRect(52, 38, 4, 4); ctx.fillRect(64, 38, 4, 4);
            ctx.fillStyle = col.legs; ctx.fillRect(45, 87, 10, 15); ctx.fillRect(65, 87, 10, 15);
        }
    }
    
    setupInput() {
        window.addEventListener('keydown', e => {
            if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') this.input.up = true;
            if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') this.input.down = true;
            if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') this.input.left = true;
            if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') this.input.right = true;
            if ((e.key === 'Escape' || e.key === 'p') && this.state === 'playing') this.pause();
        });
        window.addEventListener('keyup', e => {
            if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') this.input.up = false;
            if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') this.input.down = false;
            if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') this.input.left = false;
            if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') this.input.right = false;
        });
        let touchStart = null;
        this.canvas.addEventListener('touchstart', e => { if (this.state !== 'playing') return; e.preventDefault(); touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY }; this.input.joy = { x: 0, y: 0 }; }, { passive: false });
        this.canvas.addEventListener('touchmove', e => { if (this.state !== 'playing' || !touchStart) return; e.preventDefault(); const dx = e.touches[0].clientX - touchStart.x, dy = e.touches[0].clientY - touchStart.y; const d = Math.min(Math.hypot(dx, dy), 60), a = Math.atan2(dy, dx); this.input.joy = { x: Math.cos(a) * d / 60, y: Math.sin(a) * d / 60 }; }, { passive: false });
        this.canvas.addEventListener('touchend', () => { touchStart = null; this.input.joy = null; });
    }
    
    setupSlots() {
        const ws = document.getElementById('weaponSlots'), bs = document.getElementById('bookSlots');
        ws.innerHTML = ''; bs.innerHTML = '';
        for (let i = 0; i < CONFIG.MAX_WEAPONS; i++) ws.innerHTML += `<div class="equipment-slot" id="ws${i}"></div>`;
        for (let i = 0; i < CONFIG.MAX_BOOKS; i++) bs.innerHTML += `<div class="equipment-slot" id="bs${i}"></div>`;
    }
    
    updateSlots() {
        for (let i = 0; i < CONFIG.MAX_WEAPONS; i++) {
            const slot = document.getElementById(`ws${i}`);
            if (this.player.weapons[i]) { const w = this.player.weapons[i]; slot.innerHTML = `<span style="font-size:1.1rem">${WEAPONS[w.id].icon}</span><span class="slot-level">${w.level}</span>`; slot.style.borderColor = w.upgrades.length > 0 ? w.upgrades[w.upgrades.length - 1].rarity.color : '#444'; }
            else slot.innerHTML = '';
        }
        for (let i = 0; i < CONFIG.MAX_BOOKS; i++) {
            const slot = document.getElementById(`bs${i}`);
            if (this.player.books[i]) { const b = this.player.books[i]; slot.innerHTML = `<span style="font-size:1.1rem">${BOOKS[b.id].icon}</span><span class="slot-level">${b.level}</span>`; slot.style.borderColor = b.upgrades.length > 0 ? b.upgrades[b.upgrades.length - 1].rarity.color : '#444'; }
            else slot.innerHTML = '';
        }
    }
    
    start() {
        this.audio.init();
        this.audio.startBGM(); // Start background music
        this.state = 'playing';
        document.getElementById('mainMenu').style.display = 'none';
        document.getElementById('hud').style.display = 'flex';
        document.getElementById('equipmentSlots').style.display = 'flex';
        document.getElementById('miniMap').style.display = 'block';
        document.getElementById('pauseBtn').style.display = 'block';
        document.getElementById('pauseBtn').textContent = 'â¸ï¸';
        
        // Generate map with buildings and obstacles
        this.map.generate(CONFIG.WORLD_SIZE);
        
        this.player = new Player(0, 0, this.charIds[this.charIdx]);
        this.enemies = []; this.boss = null; this.proj = []; this.eProj = []; this.pickups = []; this.items = []; this.texts = []; this.fx = []; this.spriteEffects = [];
        this.particles.list = []; this.particles.stains = [];
        this.time = 0; this.spawnT = 0; this.bossSpawned = false; this.bossWarnShown = false;
        this.setupSlots(); this.updateSlots();
    }
    
    restart() {
        document.getElementById('gameOverScreen').style.display = 'none';
        document.getElementById('mainMenu').style.display = 'flex';
        document.getElementById('hud').style.display = 'none';
        document.getElementById('equipmentSlots').style.display = 'none';
        document.getElementById('pauseBtn').style.display = 'none';
        this.state = 'menu';
        if (this.baghdadUnlocked) { document.getElementById('cityBaghdad').classList.remove('locked'); document.getElementById('cityBaghdad').querySelector('.city-locked').style.display = 'none'; }
    }
    
    pause() {
        if (this.state === 'playing') { 
            this.state = 'paused'; 
            document.getElementById('pauseMenu').style.display = 'flex';
            document.getElementById('pauseBtn').textContent = 'â–¶ï¸';
            this.audio.pauseBGM();
        }
        else if (this.state === 'paused') { 
            this.state = 'playing'; 
            document.getElementById('pauseMenu').style.display = 'none';
            document.getElementById('pauseBtn').textContent = 'â¸ï¸';
            this.audio.resumeBGM();
        }
    }
    
    quitToMenu() {
        this.state = 'menu';
        this.audio.stopBGM();
        document.getElementById('pauseMenu').style.display = 'none';
        document.getElementById('pauseBtn').style.display = 'none';
        document.getElementById('hud').style.display = 'none';
        document.getElementById('equipmentSlots').style.display = 'none';
        document.getElementById('miniMap').style.display = 'none';
        document.getElementById('mainMenu').style.display = 'flex';
        if (this.baghdadUnlocked) { 
            document.getElementById('cityBaghdad').classList.remove('locked'); 
            document.getElementById('cityBaghdad').querySelector('.city-locked').style.display = 'none'; 
        }
    }
    
    loop(t) {
        const dt = Math.min((t - this.lastTime) / 1000, 0.07);
        this.lastTime = t;
        if (this.state === 'loading') {
            this.drawLoading();
        } else {
            if (this.state === 'playing') this.update(dt);
            this.draw();
        }
        requestAnimationFrame(t => this.loop(t));
    }
    
    update(dt) {
        this.time += dt;
        
        if (this.time >= CONFIG.BOSS_TIME - 30 && !this.bossWarnShown) {
            this.bossWarnShown = true;
            document.getElementById('bossWarning').style.display = 'block';
            this.audio.bossWarn();
            setTimeout(() => document.getElementById('bossWarning').style.display = 'none', 2500);
        }
        
        if (this.time >= CONFIG.BOSS_TIME && !this.bossSpawned) {
            this.bossSpawned = true;
            const a = Math.random() * Math.PI * 2;
            this.boss = new Boss(this.player.x + Math.cos(a) * 320, this.player.y + Math.sin(a) * 320, this.player.enemyBuff);
        }
        
        if (this.globalSlow > 0) this.globalSlow -= dt;
        this.player.update(dt, this.input, this);
        
        this.cam.x = this.player.x - this.canvas.width / 2;
        this.cam.y = this.player.y - this.canvas.height / 2;
        if (this.shake > 0) { this.shake -= dt; this.cam.x += (Math.random() - 0.5) * 6; this.cam.y += (Math.random() - 0.5) * 6; }
        
        // Spawn enemies
        if (!this.bossSpawned) {
            this.spawnT -= dt;
            const spawnMult = 1 + this.player.curse * 0.35 + this.player.extraEnemySpawn;
            let rate = 1.2 / spawnMult;
            
            // Reduce spawn rate by 60% after the last enemy type appears (knight at 480s = 8 min)
            if (this.time >= 480) {
                rate *= 2.5; // 60% slower = rate * 2.5
            }
            
            const maxE = Math.floor((55 + this.player.curse * 12) * spawnMult);
            if (this.spawnT <= 0 && this.enemies.length < maxE) { this.spawnEnemy(); this.spawnT = rate / (1 + this.time / 100); }
        }
        
        const eDt = this.globalSlow > 0 ? dt * 0.5 : dt;
        for (const e of this.enemies) {
            e.update(eDt, this.player, this.enemies, this);
            if (Math.hypot(e.x - this.player.x, e.y - this.player.y) < (e.width + this.player.width) / 2) this.player.takeDmg(e.atk, this);
            
            // Aura/orbit/melee dmg
            for (const w of this.player.weapons) {
                const data = WEAPONS[w.id], range = this.player.getRange(w);
                if (data.type === 'orbit' || data.type === 'aura') {
                    if (Math.hypot(e.x - this.player.x, e.y - this.player.y) < range + e.width / 2) {
                        const dps = this.player.getDmg(w) * (data.type === 'aura' ? 0.7 : 1.3);
                        if (e.takeDmg(dps * dt, this)) this.killEnemy(e);
                    }
                } else if (data.type === 'melee') {
                    const dist = Math.hypot(e.x - this.player.x, e.y - this.player.y);
                    const ang = Math.atan2(e.y - this.player.y, e.x - this.player.x);
                    const pAng = this.player.facing > 0 ? 0 : Math.PI;
                    if (dist < range + e.width / 2 && Math.abs(ang - pAng) < Math.PI / 2) {
                        const timer = this.player.wTimers[w.id] || 0, cd = this.player.getCD(w);
                        if (timer > cd * 0.82 && timer < cd * 0.95) { if (e.takeDmg(this.player.getDmg(w), this)) this.killEnemy(e); }
                    }
                }
            }
        }
        this.enemies = this.enemies.filter(e => e.hp > 0);
        
        // Boss
        if (this.boss) {
            this.boss.update(dt, this.player, this);
            if (Math.hypot(this.boss.x - this.player.x, this.boss.y - this.player.y) < (this.boss.width + this.player.width) / 2) this.player.takeDmg(this.boss.atk, this);
            for (const w of this.player.weapons) {
                const data = WEAPONS[w.id];
                if (data.type === 'orbit' || data.type === 'aura') {
                    if (Math.hypot(this.boss.x - this.player.x, this.boss.y - this.player.y) < this.player.getRange(w) + this.boss.width / 2)
                        this.boss.takeDmg(this.player.getDmg(w) * dt, this);
                }
            }
            if (this.boss.hp <= 0) this.over(true);
        }
        
        // Projectiles
        for (let i = this.proj.length - 1; i >= 0; i--) {
            const p = this.proj[i];
            p.x += p.vx * dt; p.y += p.vy * dt; p.life -= dt;
            if (p.life <= 0) { this.proj.splice(i, 1); continue; }
            for (const e of this.enemies) {
                if (Math.hypot(p.x - e.x, p.y - e.y) < p.size + e.width / 2) {
                    if (e.takeDmg(p.dmg, this)) this.killEnemy(e);
                    p.pierce = (p.pierce || 1) - 1;
                    if (p.pierce <= 0) this.proj.splice(i, 1);
                    break;
                }
            }
            if (this.boss && Math.hypot(p.x - this.boss.x, p.y - this.boss.y) < p.size + this.boss.width / 2) { this.boss.takeDmg(p.dmg, this); this.proj.splice(i, 1); }
        }
        
        // Enemy projectiles
        for (let i = this.eProj.length - 1; i >= 0; i--) {
            const p = this.eProj[i];
            p.x += p.vx * dt; p.y += p.vy * dt; p.life -= dt;
            if (p.life <= 0) { this.eProj.splice(i, 1); continue; }
            if (Math.hypot(p.x - this.player.x, p.y - this.player.y) < p.size + this.player.width / 2) { this.player.takeDmg(p.dmg, this); this.eProj.splice(i, 1); }
        }
        
        // Effects
        for (let i = this.fx.length - 1; i >= 0; i--) {
            const f = this.fx[i];
            if (f.type === 'lightning') { f.life -= dt; if (f.life <= 0) this.fx.splice(i, 1); }
            else if (f.type === 'meteor') {
                if (f.delay > 0) { f.delay -= dt; continue; }
                f.life -= dt;
                if (f.life <= 0.35 && !f.hit) { f.hit = true; this.particles.emit(f.x, f.y, 10, { color: '#ff4500', minS: 50, maxS: 140 }); for (const e of this.enemies) { if (Math.hypot(f.x - e.x, f.y - e.y) < f.radius) { if (e.takeDmg(f.dmg, this)) this.killEnemy(e); } } }
                if (f.life <= 0) this.fx.splice(i, 1);
            }
            else if (f.type === 'tornado') {
                f.x += f.vx * dt; f.y += f.vy * dt; f.life -= dt;
                for (const e of this.enemies) { if (Math.hypot(f.x - e.x, f.y - e.y) < f.radius + e.width / 2) { e.takeDmg(f.dmg * dt, this); e.slow = f.slow; e.slowT = 0.35; } }
                if (f.life <= 0) this.fx.splice(i, 1);
            }
        }
        
        // Pickups
        for (let i = this.pickups.length - 1; i >= 0; i--) {
            const p = this.pickups[i];
            p.update(dt);
            const d = Math.hypot(p.x - this.player.x, p.y - this.player.y);
            if (d < this.player.pickupRange * 1.8) { const a = Math.atan2(this.player.y - p.y, this.player.x - p.x); const s = 200 * (1 - d / (this.player.pickupRange * 1.8)); p.x += Math.cos(a) * s * dt; p.y += Math.sin(a) * s * dt; }
            if (d < this.player.pickupRange) {
                if (p.type === 'xp') { 
                    this.player.xp += p.val * this.player.xpMult * (1 + this.player.curse * 0.4); 
                    this.audio.pickup(); 
                    this.checkLevelUp(); 
                    // XP pickup effect
                    this.particles.emit(p.x, p.y, 3, { color: '#44ff44', minS: 30, maxS: 60, size: 2, life: 0.3 });
                } else { 
                    this.player.gold += Math.round(p.val * this.player.goldMult); 
                    this.audio.pickup();
                    // Gold pickup effect
                    this.particles.gold(p.x, p.y);
                }
                this.pickups.splice(i, 1);
            }
        }
        
        // Item drops
        for (let i = this.items.length - 1; i >= 0; i--) {
            const item = this.items[i];
            item.update(dt);
            if (Math.hypot(item.x - this.player.x, item.y - this.player.y) < 22) {
                this.showItemPickup(item);
                this.items.splice(i, 1);
            }
        }
        
        this.texts = this.texts.filter(t => { t.update(dt); return t.life > 0; });
        this.particles.update(dt);
        
        // Update sprite effects
        this.spriteEffects = this.spriteEffects.filter(e => { e.update(dt); return !e.done; });
        
        this.updateHUD();
        this.updateSlots();
        this.drawMiniMap();
    }
    
    spawnEnemy() {
        // Spawn enemies OUTSIDE the screen, not inside
        // Calculate screen bounds
        const screenW = this.canvas.width / 2 + 80;
        const screenH = this.canvas.height / 2 + 80;
        
        // Random position on the edge of the screen (outside view)
        const side = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
        let x, y;
        
        switch(side) {
            case 0: // Top
                x = this.player.x + (Math.random() - 0.5) * screenW * 2;
                y = this.player.y - screenH - Math.random() * 50;
                break;
            case 1: // Right
                x = this.player.x + screenW + Math.random() * 50;
                y = this.player.y + (Math.random() - 0.5) * screenH * 2;
                break;
            case 2: // Bottom
                x = this.player.x + (Math.random() - 0.5) * screenW * 2;
                y = this.player.y + screenH + Math.random() * 50;
                break;
            case 3: // Left
                x = this.player.x - screenW - Math.random() * 50;
                y = this.player.y + (Math.random() - 0.5) * screenH * 2;
                break;
        }
        
        const avail = Object.entries(ENEMIES).filter(([, e]) => this.time >= e.time);
        const weights = avail.map((_, i) => Math.pow(1.7, i)), total = weights.reduce((s, w) => s + w, 0);
        let r = Math.random() * total, type = avail[0][0];
        for (let i = 0; i < weights.length; i++) { r -= weights[i]; if (r <= 0) { type = avail[i][0]; break; } }
        this.enemies.push(new Enemy(x, y, type, this.time, this.player.enemyBuff));
        if (ENEMIES[type].pack) for (let i = 0; i < 2; i++) this.enemies.push(new Enemy(x + (Math.random() - 0.5) * 35, y + (Math.random() - 0.5) * 35, type, this.time, this.player.enemyBuff));
    }
    
    killEnemy(enemy) {
        this.player.kills++;
        this.audio.pickup();
        this.particles.blood(enemy.x, enemy.y);
        
        // Add death effect with sparks
        this.spriteEffects.push(new SpriteEffect(enemy.x, enemy.y, 'fx_explosion', 32, 32, 7, 0.4, 1.5));
        this.particles.spark(enemy.x, enemy.y, '#ff6600');
        
        // Add floating kill text
        this.texts.push(new FloatText(enemy.x, enemy.y - 10, '+' + enemy.xp + ' XP', '#44ff44', 12));
        
        this.pickups.push(new Pickup(enemy.x, enemy.y, 'xp', enemy.xp));
        if (Math.random() < 0.18) {
            this.pickups.push(new Pickup(enemy.x + (Math.random() - 0.5) * 12, enemy.y + (Math.random() - 0.5) * 12, 'gold', 1 + Math.floor(this.time / 55)));
            this.particles.gold(enemy.x, enemy.y);
        }
        if (Math.random() < 0.012 * this.player.luck) this.dropItem(enemy.x, enemy.y);
    }
    
    dropItem(x, y) {
        const r = Math.random() * 100 / this.player.luck;
        let rarity = r < 5 ? 'LEGENDARY' : r < 16 ? 'RARE' : 'COMMON';
        const pool = Object.entries(ITEMS).filter(([, i]) => i.rarity === rarity);
        if (pool.length > 0) { const [id] = pool[Math.floor(Math.random() * pool.length)]; this.items.push(new ItemDrop(x, y, id)); }
    }
    
    showItemPickup(drop) {
        this.state = 'itemPickup';
        this.pendingItem = drop;
        const item = ITEMS[drop.id];
        const rar = RARITY[item.rarity];
        
        // Show sprite image if available, otherwise show emoji
        const iconEl = document.getElementById('itemIcon');
        const sprite = item.sprite && this.assets.get(item.sprite);
        const iconset = this.assets.get('iconset');
        
        if (sprite) {
            iconEl.innerHTML = `<img src="${sprite.src}" style="width: 64px; height: 64px; image-rendering: pixelated;">`;
        } else if (item.iconPos && iconset) {
            // Create canvas to extract icon from sprite sheet
            const canvas = document.createElement('canvas');
            canvas.width = 24;
            canvas.height = 24;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(iconset, item.iconPos.col * 24, item.iconPos.row * 24, 24, 24, 0, 0, 24, 24);
            iconEl.innerHTML = `<img src="${canvas.toDataURL()}" style="width: 64px; height: 64px; image-rendering: pixelated;">`;
        } else {
            iconEl.textContent = item.icon;
        }
        
        document.getElementById('itemName').textContent = item.name;
        document.getElementById('itemName').style.color = rar.color;
        document.getElementById('itemRarity').textContent = rar.name;
        document.getElementById('itemRarity').style.background = rar.color + '30';
        document.getElementById('itemRarity').style.color = rar.color;
        document.getElementById('itemDesc').textContent = item.desc;
        
        document.getElementById('itemPickupModal').style.display = 'flex';
        this.audio.itemDrop();
    }
    
    continueFromItem() {
        document.getElementById('itemPickupModal').style.display = 'none';
        if (this.pendingItem) {
            this.collectItem(this.pendingItem);
            this.pendingItem = null;
        }
        this.state = 'playing';
    }
    
    collectItem(drop) {
        const item = ITEMS[drop.id];
        switch (item.effect) {
            case 'heal': 
                this.player.hp = Math.min(this.player.maxHp, this.player.hp + item.val); 
                this.texts.push(new FloatText(this.player.x, this.player.y - 18, `+${item.val} HP`, '#0f0')); 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_heal', 24, 24, 6, 0.5, 2));
                this.particles.heal(this.player.x, this.player.y);
                break;
            case 'fullHeal': 
                this.player.maxHp += item.val; 
                this.player.hp = this.player.maxHp; 
                this.texts.push(new FloatText(this.player.x, this.player.y - 18, 'Ø´ÙØ§Ø¡ ÙƒØ§Ù…Ù„!', '#0f0', 16)); 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_heal', 24, 24, 6, 0.6, 2.5));
                this.particles.heal(this.player.x, this.player.y);
                this.particles.heal(this.player.x, this.player.y);
                break;
            case 'gold': 
                this.player.gold += Math.round(item.val * this.player.goldMult); 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_spark', 24, 24, 5, 0.3, 1.5));
                this.particles.gold(this.player.x, this.player.y);
                this.texts.push(new FloatText(this.player.x, this.player.y - 18, `+${item.val} Ø°Ù‡Ø¨`, '#ffd700'));
                break;
            case 'tempSpeed': 
                this.player.tempBuffs.push({ type: 'speed', val: item.val, dur: item.dur }); 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_magic', 24, 24, 5, 0.4, 1.8));
                break;
            case 'tempDmg': 
                this.player.tempBuffs.push({ type: 'dmg', val: item.val, dur: item.dur }); 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_fire_small', 24, 24, 6, 0.4, 1.8));
                break;
            case 'tempAtkSpd': 
                this.player.tempBuffs.push({ type: 'atkSpd', val: item.val, dur: item.dur }); 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_spark', 24, 24, 5, 0.4, 1.8));
                break;
            case 'shield': 
                this.player.shield += item.val; 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_circle', 24, 24, 5, 0.5, 2));
                break;
            case 'slow': 
                this.globalSlow = item.dur; 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_ice', 24, 24, 5, 0.5, 2));
                break;
            case 'revive': 
                this.player.hasRevive = true; 
                this.texts.push(new FloatText(this.player.x, this.player.y - 18, 'Ø¥Ø­ÙŠØ§Ø¡ Ù…Ø­ÙÙˆØ¸!', '#ffd700')); 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_magic', 24, 24, 5, 0.6, 2.5));
                break;
            case 'permGold': 
                this.player.goldMult += item.val; 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_spark', 24, 24, 5, 0.4, 2));
                break;
            case 'randomEquip': 
                this.giveRandomEquip(); 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_magic', 24, 24, 5, 0.5, 2.5));
                break;
            case 'moreEnemies': 
                this.player.extraEnemySpawn += item.val; 
                this.texts.push(new FloatText(this.player.x, this.player.y - 18, 'Ø£Ø¹Ø¯Ø§Ø¡ Ø£ÙƒØ«Ø±!', '#f44')); 
                break;
        }
    }
    
    giveRandomEquip() {
        if (Math.random() < 0.5 && this.player.weapons.length < CONFIG.MAX_WEAPONS) {
            const avail = Object.keys(WEAPONS).filter(w => !this.player.weapons.find(pw => pw.id === w));
            if (avail.length > 0) { const id = avail[Math.floor(Math.random() * avail.length)]; this.player.weapons.push({ id, level: 1, upgrades: [] }); this.texts.push(new FloatText(this.player.x, this.player.y - 30, `${WEAPONS[id].name}!`, '#ffd700', 16)); }
        } else if (this.player.books.length < CONFIG.MAX_BOOKS) {
            const avail = Object.keys(BOOKS).filter(b => !this.player.books.find(pb => pb.id === b));
            if (avail.length > 0) { const id = avail[Math.floor(Math.random() * avail.length)]; this.player.books.push({ id, level: 1, upgrades: [] }); this.applyBook(id, 1, RARITY.COMMON); this.texts.push(new FloatText(this.player.x, this.player.y - 30, `${BOOKS[id].name}!`, '#ffd700', 16)); }
        }
    }
    
    checkLevelUp() {
        const req = Math.floor(10 * Math.pow(1.35, this.player.level - 1));
        if (this.player.xp >= req) { this.player.xp -= req; this.player.level++; this.player.hp = Math.min(this.player.maxHp, this.player.hp + this.player.maxHp * 0.12); this.audio.levelUp(); this.showLevelUp(); }
    }
    
    showLevelUp() {
        this.state = 'levelup';
        const modal = document.getElementById('levelUpModal'), opts = document.getElementById('upgradeOptions');
        const choices = [];
        const aw = []; for (const w of this.player.weapons) { if (w.level < CONFIG.MAX_UPGRADE_LEVEL) aw.push({ type: 'weapon', id: w.id, isNew: false }); }
        if (this.player.weapons.length < CONFIG.MAX_WEAPONS) Object.keys(WEAPONS).filter(w => !this.player.weapons.find(pw => pw.id === w)).forEach(w => aw.push({ type: 'weapon', id: w, isNew: true }));
        const ab = []; for (const b of this.player.books) { if (b.level < CONFIG.MAX_UPGRADE_LEVEL) ab.push({ type: 'book', id: b.id, isNew: false }); }
        if (this.player.books.length < CONFIG.MAX_BOOKS) Object.keys(BOOKS).filter(b => !this.player.books.find(pb => pb.id === b)).forEach(b => ab.push({ type: 'book', id: b, isNew: true }));
        const all = [...aw, ...ab];
        while (choices.length < 3 && all.length > 0) choices.push(all.splice(Math.floor(Math.random() * all.length), 1)[0]);
        opts.innerHTML = '';
        choices.forEach(c => {
            const rar = getRandomRarity(this.player.luck);
            const card = document.createElement('div');
            card.className = 'upgrade-card';
            card.style.borderColor = rar.color;
            card.style.boxShadow = `0 0 12px ${rar.color}35`;
            const data = c.type === 'weapon' ? WEAPONS[c.id] : BOOKS[c.id];
            const lvl = c.isNew ? 0 : (c.type === 'weapon' ? this.player.weapons : this.player.books).find(x => x.id === c.id).level;
            card.innerHTML = `<div class="upgrade-icon">${data.icon}</div><div class="upgrade-name" style="color:${rar.color}">${data.name}</div><div class="upgrade-type">${c.type === 'weapon' ? 'Ø³Ù„Ø§Ø­' : 'ÙƒØªØ§Ø¨'}</div><div class="upgrade-level">${c.isNew ? 'Ø¬Ø¯ÙŠØ¯!' : `${lvl} â†’ ${lvl + 1}`}</div><div class="upgrade-desc">${data.desc}</div><div class="upgrade-rarity" style="background:${rar.color}20;color:${rar.color}">${rar.name} (+${rar.bonus})</div>`;
            card.onclick = () => { this.selectUpgrade(c, rar); modal.style.display = 'none'; this.state = 'playing'; };
            opts.appendChild(card);
        });
        modal.style.display = 'flex';
    }
    
    selectUpgrade(c, rar) {
        if (c.type === 'weapon') {
            if (c.isNew) this.player.weapons.push({ id: c.id, level: 1, upgrades: [{ rarity: rar }] });
            else { const w = this.player.weapons.find(x => x.id === c.id); w.level++; w.upgrades.push({ rarity: rar }); }
        } else {
            if (c.isNew) { this.player.books.push({ id: c.id, level: 1, upgrades: [{ rarity: rar }] }); this.applyBook(c.id, 1, rar); }
            else { const b = this.player.books.find(x => x.id === c.id); b.level++; b.upgrades.push({ rarity: rar }); this.applyBook(c.id, b.level, rar); }
        }
        this.updateSlots();
    }
    
    applyBook(id, level, rar) {
        const book = BOOKS[id], v = book.val * (1 + rar.bonus * 0.12);
        switch (book.stat) {
            case 'damage': this.player.dmgMult += v; break;
            case 'atkSpd': this.player.atkSpd += v; break;
            case 'moveSpd': this.player.speed += this.player.speed * v; break;
            case 'xp': this.player.xpMult += v; break;
            case 'maxHp': const inc = this.player.maxHp * v; this.player.maxHp += inc; this.player.hp += inc; break;
            case 'armor': this.player.armor += v * 6; break;
            case 'pickup': this.player.pickupRange += this.player.pickupRange * v; break;
            case 'luck': this.player.luck += v; break;
            case 'curse': this.player.curse += v; break;
            case 'regen': this.player.regen += v; break;
        }
    }
    
    over(victory) {
        this.state = 'gameover';
        this.audio.stopBGM(); // Stop background music
        document.getElementById('hud').style.display = 'none';
        document.getElementById('equipmentSlots').style.display = 'none';
        document.getElementById('miniMap').style.display = 'none';
        document.getElementById('pauseBtn').style.display = 'none';
        const title = document.getElementById('gameOverTitle'), unlock = document.getElementById('unlockMessage');
        if (victory) { this.audio.victory(); title.textContent = 'ğŸ‰ Ø§Ù†ØªØµØ§Ø±! ğŸ‰'; title.className = 'game-over-title victory-title'; if (!this.baghdadUnlocked) { this.baghdadUnlocked = true; localStorage.setItem('baghdadUnlocked', 'true'); unlock.textContent = 'ğŸ”“ ØªÙ… ÙØªØ­ Ø®Ø±ÙŠØ·Ø© Ø¨ØºØ¯Ø§Ø¯!'; unlock.style.display = 'block'; } else unlock.style.display = 'none'; }
        else { this.audio.death(); title.textContent = 'Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©'; title.className = 'game-over-title'; unlock.style.display = 'none'; }
        if (this.player.kills > this.highScore) { this.highScore = this.player.kills; localStorage.setItem('goldBloodHighScore', this.highScore.toString()); document.getElementById('highScore').textContent = this.highScore; }
        const m = Math.floor(this.time / 60), s = Math.floor(this.time % 60);
        document.getElementById('finalStats').innerHTML = `<p>â±ï¸ ${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}</p><p>â­ Ø§Ù„Ù…Ø³ØªÙˆÙ‰: ${this.player.level}</p><p>ğŸ’€ Ø§Ù„Ù‚ØªÙ„Ù‰: ${this.player.kills}</p><p>ğŸ’° Ø§Ù„Ø°Ù‡Ø¨: ${this.player.gold}</p>`;
        document.getElementById('gameOverScreen').style.display = 'flex';
    }
    
    updateHUD() {
        const healthPercent = (this.player.hp / this.player.maxHp) * 100;
        document.getElementById('healthBar').style.width = `${healthPercent}%`;
        document.getElementById('healthText').textContent = `${Math.ceil(this.player.hp)}/${Math.ceil(this.player.maxHp)}`;
        
        // Flash health bar when low
        const healthBar = document.getElementById('healthBar');
        if (healthPercent < 25) {
            healthBar.style.animation = 'pulse 0.5s ease-in-out infinite';
        } else {
            healthBar.style.animation = '';
        }
        
        const req = Math.floor(10 * Math.pow(1.35, this.player.level - 1));
        document.getElementById('xpBar').style.width = `${(this.player.xp / req) * 100}%`;
        document.getElementById('xpText').textContent = `${Math.floor(this.player.xp)}/${req}`;
        document.getElementById('levelText').textContent = `Ø§Ù„Ù…Ø³ØªÙˆÙ‰: ${this.player.level}`;
        document.getElementById('goldText').textContent = this.player.gold;
        document.getElementById('killText').textContent = this.player.kills;
        const m = Math.floor(this.time / 60), s = Math.floor(this.time % 60);
        document.getElementById('timerText').textContent = `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    }
    
    draw() {
        const ctx = this.ctx;
        ctx.fillStyle = this.city === 'baghdad' ? '#7a9a7a' : '#d4b896';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        if (this.state === 'menu') { this.drawMenuBg(); return; }
        if (['playing', 'paused', 'levelup', 'itemPickup', 'gameover'].includes(this.state)) this.drawGame();
    }
    
    drawMenuBg() {
        const ctx = this.ctx, t = Date.now() / 1000;
        const w = this.canvas.width, h = this.canvas.height;
        
        // Gradient background
        const gradient = ctx.createLinearGradient(0, 0, 0, h);
        gradient.addColorStop(0, '#0a0a15');
        gradient.addColorStop(0.5, '#1a1a2e');
        gradient.addColorStop(1, '#0f0f1a');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, w, h);
        
        // Animated sand dunes
        for (let i = 0; i < 5; i++) { 
            const y = h * 0.4 + i * 50; 
            const alpha = 0.15 + i * 0.05;
            ctx.fillStyle = `rgba(${80 + i * 15}, ${60 + i * 10}, ${40 + i * 5}, ${alpha})`; 
            ctx.beginPath(); 
            ctx.moveTo(0, y); 
            for (let x = 0; x <= w; x += 30) {
                ctx.lineTo(x, y + Math.sin(x * 0.006 + t * 0.5 + i * 0.5) * 15);
            }
            ctx.lineTo(w, h); 
            ctx.lineTo(0, h); 
            ctx.fill(); 
        }
        
        // Floating particles
        ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
        for (let i = 0; i < 15; i++) {
            const x = (t * 20 + i * 100) % w;
            const y = h * 0.3 + Math.sin(t * 2 + i) * 30 + i * 20;
            const size = 1 + Math.sin(t * 3 + i * 0.5) * 0.5;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Subtle stars
        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
        for (let i = 0; i < 30; i++) {
            const x = (i * 67) % w;
            const y = (i * 43) % (h * 0.4);
            const size = 0.5 + Math.sin(t * 2 + i) * 0.3;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    drawGame() {
        const ctx = this.ctx;
        this.drawBg();
        this.particles.draw(ctx, this.cam);
        for (const p of this.pickups) p.draw(ctx, this.cam, this.assets);
        for (const i of this.items) i.draw(ctx, this.cam, this.assets);
        
        // Draw effects
        for (const f of this.fx) {
            const sx = f.x - this.cam.x, sy = f.y - this.cam.y;
            if (f.type === 'lightning') { 
                // Outer glow
                ctx.fillStyle = `rgba(255, 255, 100, ${f.life / 0.25 * 0.3})`;
                ctx.beginPath();
                ctx.arc(sx, sy, 45, 0, Math.PI * 2);
                ctx.fill();
                
                // Multiple lightning bolts
                for (let b = 0; b < 3; b++) {
                    ctx.strokeStyle = `rgba(255, 255, ${150 + b * 35}, ${f.life / 0.25})`; 
                    ctx.lineWidth = 4 - b; 
                    ctx.beginPath(); 
                    ctx.moveTo(sx + (b - 1) * 8, sy - 400); 
                    let lx = sx + (b - 1) * 8;
                    for (let i = 0; i < 12; i++) {
                        lx += (Math.random() - 0.5) * 25;
                        ctx.lineTo(lx, sy - 400 + i * 35);
                    }
                    ctx.lineTo(sx, sy); 
                    ctx.stroke();
                }
                
                // Impact glow
                ctx.fillStyle = `rgba(255, 255, 200, ${f.life / 0.25 * 0.6})`; 
                ctx.beginPath(); 
                ctx.arc(sx, sy, 30, 0, Math.PI * 2); 
                ctx.fill();
                ctx.fillStyle = `rgba(255, 255, 255, ${f.life / 0.25 * 0.8})`; 
                ctx.beginPath(); 
                ctx.arc(sx, sy, 15, 0, Math.PI * 2); 
                ctx.fill();
            }
            else if (f.type === 'meteor' && f.delay <= 0) { 
                if (f.life > 0.35) { 
                    // Target indicator
                    ctx.strokeStyle = 'rgba(255, 70, 0, 0.5)'; 
                    ctx.lineWidth = 3; 
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath(); 
                    ctx.arc(sx, sy, f.radius, 0, Math.PI * 2); 
                    ctx.stroke(); 
                    ctx.setLineDash([]);
                    
                    // Incoming meteor with trail
                    const meteorY = sy - (f.life - 0.35) * 280;
                    // Trail
                    ctx.fillStyle = 'rgba(255, 100, 0, 0.3)';
                    ctx.beginPath();
                    ctx.moveTo(sx - 10, meteorY);
                    ctx.lineTo(sx, meteorY - 60);
                    ctx.lineTo(sx + 10, meteorY);
                    ctx.fill();
                    // Meteor
                    ctx.fillStyle = '#ff4400';
                    ctx.beginPath();
                    ctx.arc(sx, meteorY, 16, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    ctx.arc(sx, meteorY, 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(sx, meteorY, 5, 0, Math.PI * 2);
                    ctx.fill();
                } else { 
                    // Explosion
                    const progress = 1 - f.life / 0.35;
                    ctx.fillStyle = `rgba(255, 100, 0, ${0.5 - progress * 0.4})`; 
                    ctx.beginPath(); 
                    ctx.arc(sx, sy, f.radius * progress, 0, Math.PI * 2); 
                    ctx.fill(); 
                    ctx.fillStyle = `rgba(255, 200, 0, ${0.6 - progress * 0.5})`; 
                    ctx.beginPath(); 
                    ctx.arc(sx, sy, f.radius * progress * 0.6, 0, Math.PI * 2); 
                    ctx.fill(); 
                } 
            }
            else if (f.type === 'tornado') { 
                // Animated tornado
                const time = Date.now() * 0.003;
                ctx.save();
                ctx.translate(sx, sy);
                
                // Outer dust clouds
                ctx.fillStyle = 'rgba(160, 140, 100, 0.3)';
                for (let i = 0; i < 6; i++) {
                    const angle = time + i * Math.PI / 3;
                    const dist = f.radius * 0.9;
                    ctx.beginPath();
                    ctx.arc(Math.cos(angle) * dist, Math.sin(angle) * dist, 8, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Spiral lines
                ctx.strokeStyle = 'rgba(180, 160, 120, 0.6)';
                ctx.lineWidth = 3;
                for (let spiral = 0; spiral < 3; spiral++) {
                    ctx.beginPath();
                    for (let i = 0; i < 20; i++) {
                        const angle = time * 2 + i * 0.3 + spiral * 2;
                        const r = f.radius * (1 - i / 25);
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r * 0.4 - i * 2;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                
                // Center column
                ctx.fillStyle = 'rgba(140, 120, 90, 0.5)';
                ctx.fillRect(-8, -f.radius * 0.8, 16, f.radius * 1.2);
                
                ctx.restore();
            }
        }
        
        // Draw enemies with sprites
        for (const e of this.enemies) e.draw(ctx, this.cam, this.assets);
        if (this.boss) this.boss.draw(ctx, this.cam, this.assets);
        
        // Draw player with sprite
        this.player.draw(ctx, this.cam, this.assets);
        
        // Draw projectiles with IconSet sprites
        const iconset = this.assets.get('iconset');
        for (const p of this.proj) { 
            const px = p.x - this.cam.x, py = p.y - this.cam.y;
            const angle = Math.atan2(p.vy, p.vx);
            
            // Try to draw from IconSet if projectile has iconPos
            if (p.iconPos && iconset) {
                ctx.save();
                ctx.translate(px, py);
                ctx.rotate(angle);
                ctx.imageSmoothingEnabled = false;
                const iconSize = 24;
                const drawSize = p.size * 3;
                ctx.drawImage(
                    iconset,
                    p.iconPos.col * iconSize, p.iconPos.row * iconSize,
                    iconSize, iconSize,
                    -drawSize/2, -drawSize/2, drawSize, drawSize
                );
                ctx.restore();
            } else if (p.type === 'fire') {
                // Fire projectile with outer glow
                ctx.fillStyle = 'rgba(255, 69, 0, 0.4)';
                ctx.beginPath();
                ctx.arc(px, py, p.size + 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ff4500';
                ctx.beginPath();
                ctx.arc(px, py, p.size + 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ff6600';
                ctx.beginPath();
                ctx.arc(px, py, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(px, py, p.size * 0.4, 0, Math.PI * 2);
                ctx.fill();
            } else if (p.type === 'arrow') {
                // Arrow projectile from IconSet
                if (iconset) {
                    ctx.save();
                    ctx.translate(px, py);
                    ctx.rotate(angle);
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(iconset, 30 * 24, 6 * 24, 24, 24, -16, -8, 32, 16);
                    ctx.restore();
                } else {
                    ctx.save();
                    ctx.translate(px, py);
                    ctx.rotate(angle);
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(-12, -2, 20, 4);
                    ctx.fillStyle = '#C0C0C0';
                    ctx.beginPath();
                    ctx.moveTo(8, -5);
                    ctx.lineTo(14, 0);
                    ctx.lineTo(8, 5);
                    ctx.fill();
                    ctx.restore();
                }
            } else if (p.type === 'rock') {
                // Rock projectile from IconSet
                if (iconset) {
                    ctx.save();
                    ctx.translate(px, py);
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(iconset, 9 * 24, 3 * 24, 24, 24, -12, -12, 24, 24);
                    ctx.restore();
                } else {
                    ctx.fillStyle = '#5a5a5a';
                    ctx.beginPath();
                    ctx.arc(px, py, p.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (p.type === 'spear') {
                // Spear projectile from IconSet
                if (iconset) {
                    ctx.save();
                    ctx.translate(px, py);
                    ctx.rotate(angle);
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(iconset, 4 * 24, 29 * 24, 24, 24, -18, -9, 36, 18);
                    ctx.restore();
                } else {
                    ctx.save();
                    ctx.translate(px, py);
                    ctx.rotate(angle);
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(-15, -2, 30, 4);
                    ctx.fillStyle = '#C0C0C0';
                    ctx.beginPath();
                    ctx.moveTo(15, 0);
                    ctx.lineTo(10, -4);
                    ctx.lineTo(10, 4);
                    ctx.fill();
                    ctx.restore();
                }
            } else if (p.type === 'blue_fire') {
                // Blue fire (for Layla)
                ctx.fillStyle = 'rgba(0, 100, 255, 0.4)';
                ctx.beginPath();
                ctx.arc(px, py, p.size + 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#0066ff';
                ctx.beginPath();
                ctx.arc(px, py, p.size + 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#00aaff';
                ctx.beginPath();
                ctx.arc(px, py, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#aaeeff';
                ctx.beginPath();
                ctx.arc(px, py, p.size * 0.4, 0, Math.PI * 2);
                ctx.fill();
            } else {
                ctx.fillStyle = p.color; 
                ctx.beginPath(); 
                ctx.arc(px, py, p.size, 0, Math.PI * 2); 
                ctx.fill();
            }
            
            // Trail effect
            ctx.globalAlpha = 0.35;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(px - p.vx * 0.015, py - p.vy * 0.015, p.size * 0.65, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 0.2;
            ctx.beginPath();
            ctx.arc(px - p.vx * 0.03, py - p.vy * 0.03, p.size * 0.4, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
        for (const p of this.eProj) { 
            const px = p.x - this.cam.x, py = p.y - this.cam.y;
            
            if (p.type === 'gas') {
                // Green gas effect
                ctx.fillStyle = 'rgba(34, 170, 34, 0.3)';
                ctx.beginPath();
                ctx.arc(px, py, p.size * 1.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'rgba(68, 255, 68, 0.5)';
                ctx.beginPath();
                ctx.arc(px, py, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'rgba(150, 255, 150, 0.7)';
                ctx.beginPath();
                ctx.arc(px, py, p.size * 0.5, 0, Math.PI * 2);
                ctx.fill();
            } else {
                ctx.fillStyle = p.color; 
                ctx.beginPath(); 
                ctx.arc(px, py, p.size, 0, Math.PI * 2); 
                ctx.fill(); 
            }
        }
        for (const t of this.texts) t.draw(ctx, this.cam);
        
        // Draw sprite effects
        for (const e of this.spriteEffects) e.draw(ctx, this.cam, this.assets);
        
        this.drawLighting();
        
        // Virtual joystick for mobile
        if (this.input.joy) { 
            ctx.fillStyle = 'rgba(255, 255, 255, 0.12)'; 
            ctx.beginPath(); 
            ctx.arc(80, this.canvas.height - 80, 55, 0, Math.PI * 2); 
            ctx.fill(); 
            ctx.fillStyle = 'rgba(255, 215, 0, 0.35)'; 
            ctx.beginPath(); 
            ctx.arc(80 + this.input.joy.x * 35, this.canvas.height - 80 + this.input.joy.y * 35, 20, 0, Math.PI * 2); 
            ctx.fill(); 
        }
        
        // Boss health bar
        if (this.boss) {
            const bw = Math.min(350, this.canvas.width * 0.8), bx = (this.canvas.width - bw) / 2;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; 
            ctx.fillRect(bx - 3, 44, bw + 6, 26);
            ctx.fillStyle = '#222'; 
            ctx.fillRect(bx, 47, bw, 20);
            const hpColor = this.boss.phase === 3 ? '#ff0000' : this.boss.phase === 2 ? '#ff6600' : '#ffcc00';
            ctx.fillStyle = hpColor;
            ctx.fillRect(bx, 47, bw * (this.boss.hp / this.boss.maxHp), 20);
            ctx.fillStyle = '#fff'; 
            ctx.font = 'bold 12px Cairo'; 
            ctx.textAlign = 'center';
            ctx.fillText(`ğŸ‘¹ ${BOSS.name} - Ø§Ù„Ù…Ø±Ø­Ù„Ø© ${this.boss.phase}`, this.canvas.width / 2, 42);
        }
    }
    
    drawBg() {
        const ctx = this.ctx;
        
        // Draw sand/ground color background
        if (this.city === 'badaya') {
            ctx.fillStyle = '#c9a66b'; // Arab town sand color
        } else {
            ctx.fillStyle = '#5a8a5a'; // Baghdad green
        }
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Add subtle noise/variation to ground
        const ts = 64;
        const sx = Math.floor(this.cam.x / ts) - 1;
        const sy = Math.floor(this.cam.y / ts) - 1;
        const ex = Math.ceil((this.cam.x + this.canvas.width) / ts) + 1;
        const ey = Math.ceil((this.cam.y + this.canvas.height) / ts) + 1;
        
        for (let y = sy; y <= ey; y++) {
            for (let x = sx; x <= ex; x++) {
                const px = x * ts - this.cam.x, py = y * ts - this.cam.y;
                const seed = Math.abs(Math.sin(x * 12.9898 + y * 78.233) * 43758.5453) % 1;
                
                // Subtle ground variation
                if (seed < 0.1) {
                    ctx.fillStyle = this.city === 'badaya' ? 'rgba(180, 150, 100, 0.15)' : 'rgba(70, 110, 70, 0.15)';
                    ctx.fillRect(px, py, ts, ts);
                }
                
                // Small ground details
                if (seed > 0.95) {
                    ctx.fillStyle = this.city === 'badaya' ? '#b89a5a' : '#4a7a4a';
                    ctx.beginPath();
                    ctx.arc(px + ts/2, py + ts/2, 2 + seed * 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        // Draw map obstacles and decorations using MapSystem
        if (this.map.generated) {
            this.map.draw(ctx, this.cam, this.assets);
        }
    }
    
    drawLighting() {
        // Subtle vignette effect only - no heavy darkness
        const ctx = this.ctx;
        const cx = this.canvas.width / 2, cy = this.canvas.height / 2;
        const maxDist = Math.max(this.canvas.width, this.canvas.height) * 0.7;
        
        // Very subtle edge darkening (vignette)
        const vignette = ctx.createRadialGradient(cx, cy, maxDist * 0.5, cx, cy, maxDist);
        vignette.addColorStop(0, 'rgba(0, 0, 0, 0)');
        vignette.addColorStop(1, 'rgba(0, 0, 0, 0.15)');
        ctx.fillStyle = vignette;
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Warm tint overlay
        ctx.fillStyle = 'rgba(255, 200, 100, 0.02)';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }
    
    drawMiniMap() {
        const miniMapEl = document.getElementById('miniMap');
        const canvas = document.getElementById('miniMapCanvas');
        if (!canvas || !miniMapEl) return;
        
        const ctx = canvas.getContext('2d');
        const w = canvas.width, h = canvas.height;
        const scale = 0.015; // Scale factor for mini map
        const range = 600; // How far to show on mini map
        
        // Clear
        ctx.fillStyle = this.city === 'baghdad' ? 'rgba(60, 90, 60, 0.9)' : 'rgba(80, 70, 50, 0.9)';
        ctx.fillRect(0, 0, w, h);
        
        // Draw grid
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 0.5;
        for (let i = 0; i < 5; i++) {
            ctx.beginPath();
            ctx.moveTo(i * w / 4, 0);
            ctx.lineTo(i * w / 4, h);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, i * h / 4);
            ctx.lineTo(w, i * h / 4);
            ctx.stroke();
        }
        
        const cx = w / 2, cy = h / 2;
        
        // Draw pickups (small green dots)
        ctx.fillStyle = '#44ff44';
        for (const p of this.pickups) {
            const dx = (p.x - this.player.x) * scale;
            const dy = (p.y - this.player.y) * scale;
            if (Math.abs(dx) < range * scale && Math.abs(dy) < range * scale) {
                ctx.beginPath();
                ctx.arc(cx + dx, cy + dy, 1.5, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Draw items (yellow dots)
        ctx.fillStyle = '#ffd700';
        for (const i of this.items) {
            const dx = (i.x - this.player.x) * scale;
            const dy = (i.y - this.player.y) * scale;
            if (Math.abs(dx) < range * scale && Math.abs(dy) < range * scale) {
                ctx.beginPath();
                ctx.arc(cx + dx, cy + dy, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Draw enemies (red dots)
        ctx.fillStyle = '#ff4444';
        for (const e of this.enemies) {
            const dx = (e.x - this.player.x) * scale;
            const dy = (e.y - this.player.y) * scale;
            if (Math.abs(dx) < range * scale && Math.abs(dy) < range * scale) {
                ctx.beginPath();
                ctx.arc(cx + dx, cy + dy, 2.5, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Draw boss (large red dot)
        if (this.boss) {
            const dx = (this.boss.x - this.player.x) * scale;
            const dy = (this.boss.y - this.player.y) * scale;
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(cx + dx, cy + dy, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#ffff00';
            ctx.lineWidth = 1;
            ctx.stroke();
        }
        
        // Draw player (center, white with gold border)
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(cx, cy, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#ffd700';
        ctx.lineWidth = 1.5;
        ctx.stroke();
        
        // Draw direction indicator
        const angle = Math.atan2(this.player.vy, this.player.vx);
        if (Math.abs(this.player.vx) > 5 || Math.abs(this.player.vy) > 5) {
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.lineTo(cx + Math.cos(angle) * 8, cy + Math.sin(angle) * 8);
            ctx.stroke();
        }
        
        // Border
        ctx.strokeStyle = 'rgba(255, 215, 0, 0.5)';
        ctx.lineWidth = 2;
        ctx.strokeRect(1, 1, w - 2, h - 2);
    }
}

window.addEventListener('load', () => new Game());
    </script>
</body>
</html>
