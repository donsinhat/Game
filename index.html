<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>ÿ∞Ÿáÿ® ÿ£ÿµŸÅÿ± ÿ£Ÿà ÿØŸÖ ÿ£ÿ≠ŸÖÿ± - Gold or Blood</title>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700;900&family=Changa:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
        body { background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0f0f1a 100%); font-family: 'Cairo', 'Changa', sans-serif; overflow: hidden; min-height: 100vh; color: #fff; }
        #gameCanvas { display: block; position: absolute; top: 0; left: 0; }
        
        .rarity-common { color: #9d9d9d; }
        .rarity-uncommon { color: #1eff00; }
        .rarity-rare { color: #0070dd; }
        .rarity-epic { color: #a335ee; }
        .rarity-legendary { color: #ff8000; }
        
        #mainMenu { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; background: linear-gradient(180deg, rgba(10,10,15,0.97) 0%, rgba(26,26,46,0.98) 100%); padding: 20px; }
        .menu-title { font-size: clamp(1.5rem, 5vw, 2.5rem); font-weight: 900; text-align: center; margin-bottom: 5px; background: linear-gradient(135deg, #ffd700 0%, #ff8c00 50%, #ffd700 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
        .menu-subtitle { font-size: clamp(0.8rem, 2.5vw, 1rem); color: #888; margin-bottom: 20px; }
        
        .character-select { display: flex; align-items: center; gap: 15px; margin-bottom: 25px; }
        .char-arrow { width: 50px; height: 50px; background: rgba(255, 215, 0, 0.1); border: 2px solid rgba(255, 215, 0, 0.3); border-radius: 50%; color: #ffd700; font-size: 1.5rem; cursor: pointer; transition: all 0.3s; display: flex; align-items: center; justify-content: center; }
        .char-arrow:hover { background: rgba(255, 215, 0, 0.2); border-color: #ffd700; transform: scale(1.1); }
        
        .character-display { width: 280px; padding: 20px; background: rgba(30, 30, 40, 0.9); border: 2px solid rgba(255, 215, 0, 0.3); border-radius: 20px; text-align: center; }
        .char-preview { width: 120px; height: 120px; margin: 0 auto 15px; image-rendering: pixelated; border-radius: 10px; background: rgba(0,0,0,0.3); }
        .char-name { font-size: 1.4rem; font-weight: 900; color: #ffd700; margin-bottom: 5px; }
        .char-title { font-size: 0.85rem; color: #888; margin-bottom: 10px; }
        .char-desc { font-size: 0.8rem; color: #aaa; margin-bottom: 12px; line-height: 1.4; min-height: 40px; }
        .char-stats { background: rgba(0,0,0,0.3); padding: 10px; border-radius: 10px; margin-bottom: 10px; }
        .char-stat { display: flex; justify-content: space-between; font-size: 0.8rem; margin: 4px 0; }
        .char-stat-label { color: #888; }
        .char-stat-value { color: #4f4; font-weight: bold; }
        .char-stat-negative { color: #f44; }
        .char-weapon { font-size: 0.85rem; color: #ff8888; padding: 8px; background: rgba(255,0,0,0.1); border-radius: 8px; }
        
        .city-select { display: flex; gap: 15px; margin-bottom: 25px; }
        .city-card { width: 160px; padding: 15px; background: rgba(30, 30, 40, 0.9); border: 2px solid rgba(100, 100, 100, 0.3); border-radius: 15px; cursor: pointer; transition: all 0.3s; text-align: center; }
        .city-card:hover:not(.locked), .city-card.selected { border-color: #ffd700; background: rgba(255, 215, 0, 0.1); transform: translateY(-5px); }
        .city-card.locked { opacity: 0.5; cursor: not-allowed; }
        .city-icon { font-size: 2.5rem; margin-bottom: 8px; }
        .city-name { font-size: 1rem; font-weight: bold; color: #ffd700; margin-bottom: 5px; }
        .city-desc { font-size: 0.7rem; color: #888; }
        .city-locked { font-size: 0.7rem; color: #f44; margin-top: 8px; }
        
        .btn { padding: 12px 40px; font-size: 1.1rem; font-family: 'Cairo', sans-serif; font-weight: 700; border: none; border-radius: 50px; cursor: pointer; transition: all 0.3s ease; }
        .btn-primary { background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%); color: #000; box-shadow: 0 8px 25px rgba(255, 215, 0, 0.4); }
        .btn-primary:hover { transform: scale(1.05); box-shadow: 0 12px 35px rgba(255, 215, 0, 0.5); }
        .high-score { margin-top: 15px; font-size: 0.8rem; color: #666; }
        
        #hud { position: fixed; top: 0; left: 0; width: 100%; padding: 10px 15px; display: none; justify-content: space-between; align-items: flex-start; z-index: 50; pointer-events: none; }
        .hud-left, .hud-right { display: flex; flex-direction: column; gap: 6px; }
        .hud-bar { width: 160px; height: 20px; background: rgba(0, 0, 0, 0.7); border-radius: 10px; overflow: hidden; border: 2px solid rgba(255, 255, 255, 0.2); position: relative; }
        .hud-bar-fill { height: 100%; transition: width 0.3s ease; border-radius: 10px; }
        .hud-bar-text { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 0.65rem; font-weight: bold; text-shadow: 1px 1px 2px #000; }
        .health-fill { background: linear-gradient(90deg, #ff4444 0%, #ff0000 100%); }
        .xp-fill { background: linear-gradient(90deg, #44ff44 0%, #00ff00 100%); }
        .hud-stat { font-size: 0.85rem; font-weight: 700; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8); }
        .gold-text { color: #ffd700; }
        .kill-text { color: #ff4444; }
        .level-text { color: #44ff44; }
        
        .equipment-slots { position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); display: none; gap: 8px; z-index: 50; pointer-events: none; }
        .slot-group { display: flex; gap: 4px; padding: 6px; background: rgba(0, 0, 0, 0.7); border-radius: 8px; }
        .equipment-slot { width: 38px; height: 38px; background: rgba(50, 50, 50, 0.8); border: 2px solid #444; border-radius: 6px; display: flex; align-items: center; justify-content: center; position: relative; font-size: 1.2rem; }
        .slot-level { position: absolute; bottom: -2px; right: -2px; background: #000; color: #fff; font-size: 0.55rem; padding: 1px 3px; border-radius: 3px; font-weight: bold; }
        
        #levelUpModal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); display: none; justify-content: center; align-items: center; z-index: 200; }
        .level-up-content { text-align: center; padding: 25px; background: rgba(20, 20, 30, 0.95); border: 3px solid #ffd700; border-radius: 20px; max-width: 95%; max-height: 85vh; overflow-y: auto; }
        .level-up-title { font-size: 1.6rem; color: #ffd700; margin-bottom: 20px; }
        .upgrade-options { display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; }
        .upgrade-card { width: 150px; padding: 12px; background: rgba(30, 30, 40, 0.9); border: 3px solid #444; border-radius: 12px; cursor: pointer; transition: all 0.3s ease; text-align: center; }
        .upgrade-card:hover { transform: scale(1.05); }
        .upgrade-icon { font-size: 2rem; margin-bottom: 8px; }
        .upgrade-name { font-size: 0.9rem; font-weight: bold; margin-bottom: 4px; }
        .upgrade-type { font-size: 0.7rem; color: #888; margin-bottom: 4px; }
        .upgrade-level { font-size: 0.75rem; margin-bottom: 4px; }
        .upgrade-desc { font-size: 0.65rem; color: #aaa; }
        .upgrade-rarity { font-size: 0.65rem; font-weight: bold; margin-top: 6px; padding: 2px 6px; border-radius: 8px; display: inline-block; }
        
        /* Item Pickup Modal */
        #itemPickupModal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); display: none; justify-content: center; align-items: center; z-index: 250; }
        .item-pickup-content { text-align: center; padding: 30px; background: rgba(20, 20, 30, 0.95); border: 3px solid #ffd700; border-radius: 20px; max-width: 320px; }
        .item-pickup-icon { font-size: 4rem; margin-bottom: 15px; }
        .item-pickup-name { font-size: 1.4rem; font-weight: bold; margin-bottom: 8px; }
        .item-pickup-rarity { font-size: 0.85rem; margin-bottom: 12px; padding: 4px 12px; border-radius: 10px; display: inline-block; }
        .item-pickup-desc { font-size: 0.95rem; color: #ccc; margin-bottom: 20px; line-height: 1.5; }
        .item-pickup-btn { padding: 10px 30px; font-size: 1rem; font-family: 'Cairo', sans-serif; font-weight: 700; border: none; border-radius: 25px; cursor: pointer; background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%); color: #000; }
        
        #gameOverScreen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.9); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 300; }
        .game-over-title { font-size: 2rem; color: #ff0000; margin-bottom: 15px; text-shadow: 0 0 20px rgba(255, 0, 0, 0.8); }
        .victory-title { color: #ffd700 !important; text-shadow: 0 0 20px rgba(255, 215, 0, 0.8) !important; }
        .final-stats { margin-bottom: 20px; font-size: 1rem; line-height: 1.6; }
        .unlock-message { color: #ffd700; font-size: 1.1rem; margin-bottom: 15px; padding: 10px 20px; background: rgba(255, 215, 0, 0.1); border-radius: 10px; }
        
        #bossWarning { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 2rem; color: #ff0000; text-shadow: 0 0 30px rgba(255, 0, 0, 0.8); display: none; z-index: 150; text-align: center; animation: bossWarn 0.5s ease-in-out infinite alternate; }
        @keyframes bossWarn { from { transform: translate(-50%, -50%) scale(1); } to { transform: translate(-50%, -50%) scale(1.1); } }
        
        #pauseIndicator { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 2rem; color: #ffd700; display: none; z-index: 150; }
        
        @media (max-width: 600px) {
            .character-display { width: 240px; padding: 15px; }
            .char-preview { width: 90px; height: 90px; }
            .city-card { width: 130px; padding: 12px; }
            .upgrade-card { width: 130px; padding: 10px; }
            .hud-bar { width: 130px; height: 18px; }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="mainMenu">
        <h1 class="menu-title">ÿ∞Ÿáÿ® ÿ£ÿµŸÅÿ± ÿ£Ÿà ÿØŸÖ ÿ£ÿ≠ŸÖÿ±</h1>
        <p class="menu-subtitle">ÿßŸÇÿ™ŸÑ ÿßÿ®Ÿà ÿ≠ŸÑÿ≤Ÿá ŸÅŸä 10 ÿØŸÇÿßÿ¶ŸÇ!</p>
        <div class="character-select">
            <button class="char-arrow" id="charPrev">‚Üí</button>
            <div class="character-display">
                <canvas class="char-preview" id="charPreview" width="120" height="120"></canvas>
                <div class="char-name" id="charName">ÿ£ÿ®Ÿà ÿ≥ŸÑŸäŸÖÿßŸÜ</div>
                <div class="char-title" id="charTitle">ÿßŸÑÿ™ÿßÿ¨ÿ± ÿßŸÑÿ´ÿ±Ÿä</div>
                <div class="char-desc" id="charDesc">ÿ™ÿßÿ¨ÿ± ÿ´ÿ±Ÿä Ÿäÿ≠ÿ® ÿßŸÑÿ∞Ÿáÿ®</div>
                <div class="char-stats" id="charStats"></div>
                <div class="char-weapon" id="charWeapon">üó°Ô∏è ÿßŸÑÿπŸÇÿßŸÑ</div>
            </div>
            <button class="char-arrow" id="charNext">‚Üê</button>
        </div>
        <div class="city-select">
            <div class="city-card selected" id="cityBadaya" data-city="badaya">
                <div class="city-icon">üèúÔ∏è</div>
                <div class="city-name">ÿßŸÑÿ®ÿØÿßÿ¶ÿπ</div>
                <div class="city-desc">ÿµÿ≠ÿ±ÿßÿ° ŸàŸÜÿÆŸäŸÑ</div>
            </div>
            <div class="city-card locked" id="cityBaghdad" data-city="baghdad">
                <div class="city-icon">üèõÔ∏è</div>
                <div class="city-name">ÿ®ÿ∫ÿØÿßÿØ</div>
                <div class="city-desc">ŸÖÿØŸäŸÜÿ© ÿ≠ÿ∂ÿßÿ±Ÿäÿ©</div>
                <div class="city-locked">üîí ÿßŸÇÿ™ŸÑ ÿßÿ®Ÿà ÿ≠ŸÑÿ≤Ÿá ÿ£ŸàŸÑÿßŸã</div>
            </div>
        </div>
        <button class="btn btn-primary" id="startBtn">ÿßÿ®ÿØÿ£ ÿßŸÑŸÑÿπÿ®</button>
        <p class="high-score">ÿ£ÿπŸÑŸâ ŸÜÿ™Ÿäÿ¨ÿ©: <span id="highScore">0</span> ŸÇÿ™ŸäŸÑ</p>
    </div>
    
    <div id="hud">
        <div class="hud-left">
            <div class="hud-bar"><div class="hud-bar-fill health-fill" id="healthBar" style="width: 100%"></div><span class="hud-bar-text" id="healthText">100/100</span></div>
            <div class="hud-bar"><div class="hud-bar-fill xp-fill" id="xpBar" style="width: 0%"></div><span class="hud-bar-text" id="xpText">0/10</span></div>
            <span class="hud-stat level-text" id="levelText">ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ: 1</span>
        </div>
        <div class="hud-right">
            <span class="hud-stat gold-text">üí∞ <span id="goldText">0</span></span>
            <span class="hud-stat kill-text">üíÄ <span id="killText">0</span></span>
            <span class="hud-stat" id="timerText">‚è±Ô∏è 00:00</span>
        </div>
    </div>
    
    <div class="equipment-slots" id="equipmentSlots">
        <div class="slot-group" id="weaponSlots"></div>
        <div class="slot-group" id="bookSlots"></div>
    </div>
    
    <div id="levelUpModal">
        <div class="level-up-content">
            <h2 class="level-up-title">üéâ ŸÖÿ≥ÿ™ŸàŸâ ÿ¨ÿØŸäÿØ! üéâ</h2>
            <div class="upgrade-options" id="upgradeOptions"></div>
        </div>
    </div>
    
    <div id="itemPickupModal">
        <div class="item-pickup-content">
            <div class="item-pickup-icon" id="itemIcon">‚≠ê</div>
            <div class="item-pickup-name" id="itemName">ÿßÿ≥ŸÖ ÿßŸÑÿ£Ÿäÿ™ŸÖ</div>
            <div class="item-pickup-rarity" id="itemRarity">ÿ£ÿ≥ÿ∑Ÿàÿ±Ÿä</div>
            <div class="item-pickup-desc" id="itemDesc">ŸàÿµŸÅ ÿßŸÑÿ£Ÿäÿ™ŸÖ</div>
            <button class="item-pickup-btn" id="itemContinueBtn">ÿßÿ≥ÿ™ŸÖÿ±ÿßÿ±</button>
        </div>
    </div>
    
    <div id="gameOverScreen">
        <h1 class="game-over-title" id="gameOverTitle">ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑŸÑÿπÿ®ÿ©</h1>
        <div class="unlock-message" id="unlockMessage" style="display: none;"></div>
        <div class="final-stats" id="finalStats"></div>
        <button class="btn btn-primary" id="restartBtn">ÿßŸÑÿπÿ® ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ</button>
    </div>
    
    <div id="bossWarning">‚ö†Ô∏è ÿ™ÿ≠ÿ∞Ÿäÿ±! ‚ö†Ô∏è<br><span style="font-size: 1.2rem;">ÿßÿ®Ÿà ÿ≠ŸÑÿ≤Ÿá ŸÇÿßÿØŸÖ!</span></div>
    <div id="pauseIndicator">‚è∏Ô∏è ÿ•ŸäŸÇÿßŸÅ ŸÖÿ§ŸÇÿ™</div>

    <script>
// ==================== GAME CONFIG ====================
const CONFIG = {
    WORLD_SIZE: 4000,
    TILE_SIZE: 64,
    PLAYER_LIGHT_RADIUS: 300,
    MAX_WEAPONS: 4,
    MAX_BOOKS: 4,
    MAX_UPGRADE_LEVEL: 20,
    BOSS_TIME: 600, // 10 minutes
    
    // Enemy base stats
    ENEMY_BASE_HP: 8,
    ENEMY_BASE_ATK: 5,
    ENEMY_BASE_SPEED: 55,
    
    // Scaling +20% per minute
    SCALING_PER_MIN: 0.20,
    
    // Weapon base damage
    WEAPON_BASE_DMG: 5
};

// ==================== RARITY ====================
const RARITY = {
    COMMON: { name: 'ÿ¥ÿßÿ¶ÿπ', color: '#9d9d9d', bonus: 1, weight: 50 },
    UNCOMMON: { name: 'ÿ∫Ÿäÿ± ÿ¥ÿßÿ¶ÿπ', color: '#1eff00', bonus: 2, weight: 25 },
    RARE: { name: 'ŸÜÿßÿØÿ±', color: '#0070dd', bonus: 3, weight: 13 },
    EPIC: { name: 'ŸÖŸÑÿ≠ŸÖŸä', color: '#a335ee', bonus: 4, weight: 7 },
    LEGENDARY: { name: 'ÿ£ÿ≥ÿ∑Ÿàÿ±Ÿä', color: '#ff8000', bonus: 5, weight: 5 }
};

function getRandomRarity() {
    const total = Object.values(RARITY).reduce((s, r) => s + r.weight, 0);
    let r = Math.random() * total;
    for (const rar of Object.values(RARITY)) { r -= rar.weight; if (r <= 0) return rar; }
    return RARITY.COMMON;
}

// ==================== CHARACTERS ====================
const CHARACTERS = {
    abuSulaiman: {
        name: 'ÿ£ÿ®Ÿà ÿ≥ŸÑŸäŸÖÿßŸÜ', title: 'ÿßŸÑÿ™ÿßÿ¨ÿ± ÿßŸÑÿ´ÿ±Ÿä',
        desc: 'ÿ™ÿßÿ¨ÿ± ÿ´ÿ±Ÿä Ÿäÿ≠ÿ® ÿßŸÑÿ∞Ÿáÿ® ÿ£ŸÉÿ´ÿ± ŸÖŸÜ ÿ£Ÿä ÿ¥Ÿäÿ°',
        weapon: 'agal',
        stats: { gold: 1.25, luck: 1.1, hp: 100, speed: 200, crit: 0, enemyBuff: 0 },
        passiveText: ['+25% ÿ∞Ÿáÿ®', '+10% ÿ≠ÿ∏'],
        colors: { body: '#f5f5f5', head: '#cc0000', skin: '#d4a574', legs: '#2a2a2a' }
    },
    jayzen: {
        name: 'ÿ¨Ÿäÿ≤ÿßŸÜ', title: 'ÿßŸÑŸÖŸÇÿßÿ™ŸÑ ÿßŸÑÿ¥ÿ±ÿ≥',
        desc: 'ŸÖŸÇÿßÿ™ŸÑ ÿπŸÜŸäÿØ ŸÑÿß ŸäÿÆÿßŸÅ ÿßŸÑŸÖŸàÿ™',
        weapon: 'rock',
        stats: { gold: 1, luck: 1, hp: 115, speed: 200, dmgReduce: 0.3, crit: 0, enemyBuff: 0 },
        passiveText: ['-30% ÿ∂ÿ±ÿ± ŸÖÿ≥ÿ™ŸÑŸÖ', '+15% ÿµÿ≠ÿ©'],
        colors: { body: '#6a1b9a', head: '#cc3333', skin: '#d4a574', legs: '#333' }
    },
    noura: {
        name: 'ŸÜŸàÿ±ÿ©', title: 'ÿßŸÑŸÖÿ±ÿ£ÿ© ÿßŸÑŸÇŸàŸäÿ©',
        desc: 'ÿßŸÖÿ±ÿ£ÿ© ŸÇŸàŸäÿ© ÿ™ÿ¨ŸÖÿπ ŸÉŸÑ ÿ¥Ÿäÿ° ÿ≠ŸàŸÑŸáÿß',
        weapon: 'aura',
        stats: { gold: 1, luck: 1, hp: 100, speed: 200, pickup: 2.5, xpMult: 1.2, crit: 0, enemyBuff: 0 },
        passiveText: ['+150% ŸÖÿ∫ŸÜÿßÿ∑Ÿäÿ≥', '+20% ÿÆÿ®ÿ±ÿ©'],
        colors: { body: '#1e88e5', head: '#f5f5f5', skin: '#e8d5c4', legs: '#1565c0' }
    },
    bedouin: {
        name: 'ÿßŸÑÿßÿπÿ±ÿßÿ®Ÿä', title: 'ÿ®ÿØŸàŸä ÿ∫ÿØÿßÿ±',
        desc: 'ÿ®ÿØŸàŸä Ÿàÿ∫ÿØÿßÿ±ÿå ÿßŸÑŸÑŸá Ÿäÿ±ÿ≠ŸÖ ŸÖŸÜ ÿ∑ŸÑÿπŸáŸÖ ŸÖŸÜ ÿÆŸäÿßŸÖŸáŸÖ',
        weapon: 'spear',
        stats: { gold: 1, luck: 1, hp: 90, speed: 220, crit: 0.20, enemyBuff: 0 },
        passiveText: ['+20% ÿ∂ÿ±ÿ®ÿ© ÿ≠ÿ±ÿ¨ÿ©', '+10% ÿ≥ÿ±ÿπÿ©'],
        colors: { body: '#8b4513', head: '#d2691e', skin: '#c4956a', legs: '#2f1810' }
    },
    hawshabi: {
        name: 'ÿßŸÑÿ≠Ÿàÿ¥ÿ®Ÿä', title: 'ÿµÿπŸàÿ®ÿ© ŸÖÿ™ŸÇÿØŸÖÿ©',
        desc: 'ÿßÿ∞ÿß ÿ™ÿ®Ÿä ÿ™ÿµÿπÿ® ÿßŸÑŸàÿ∂ÿπ ÿπŸÑŸäŸÉ ÿßŸÑÿπÿ® ŸÅŸäŸá Ÿàÿßÿ≠ÿ™ÿ≥ÿ® ÿßŸÑÿßÿ¨ÿ±',
        weapon: 'sword',
        stats: { gold: 1.5, luck: 1.2, hp: 80, speed: 180, crit: 0, enemyBuff: 0.20 },
        passiveText: ['+20% ŸÇŸàÿ© ÿßŸÑÿ£ÿπÿØÿßÿ°', '+50% ÿ∞Ÿáÿ®', '+20% ÿ≠ÿ∏'],
        colors: { body: '#4a0000', head: '#1a1a1a', skin: '#d4a574', legs: '#222' }
    },
    layla: {
        name: 'ŸÑŸäŸÑŸâ', title: 'ÿßŸÑÿ≥ÿßÿ≠ÿ±ÿ©',
        desc: 'ÿ≥ÿßÿ≠ÿ±ÿ© ÿ∫ÿßŸÖÿ∂ÿ© ÿ™ÿ™ÿ≠ŸÉŸÖ ÿ®ÿßŸÑŸÜÿßÿ± ÿßŸÑÿ≤ÿ±ŸÇÿßÿ°',
        weapon: 'flame',
        stats: { gold: 1, luck: 1, hp: 85, speed: 210, cooldown: 0.8, range: 1.3, crit: 0, enemyBuff: 0 },
        passiveText: ['-20% ŸÉŸàŸÑÿØÿßŸàŸÜ', '+30% ŸÖÿØŸâ'],
        colors: { body: '#1a1a2e', head: '#4a0080', skin: '#e8d5c4', legs: '#0a0a15' }
    }
};

// ==================== WEAPONS ====================
const WEAPONS = {
    agal: { name: 'ÿßŸÑÿπŸÇÿßŸÑ', desc: 'ÿ≠ÿ®ŸÑ ŸäÿØŸàÿ± ÿ≠ŸàŸÑŸÉ ŸàŸäÿ∂ÿ±ÿ® ÿßŸÑÿ£ÿπÿØÿßÿ°', type: 'orbit', dmg: 5, cd: 0.1, range: 65, icon: '‚≠ï' },
    rock: { name: 'ÿßŸÑÿµÿÆÿ±ÿ©', desc: 'ŸÇÿ∞ŸäŸÅÿ© ÿ™ÿ≥ÿ™ŸáÿØŸÅ ÿ£ŸÇÿ±ÿ® ÿπÿØŸà', type: 'projectile', dmg: 5, cd: 0.9, range: 380, icon: 'ü™®' },
    aura: { name: 'ÿßŸÑŸáŸäÿ®ÿ©', desc: 'ŸáÿßŸÑÿ© ÿ∂ÿ±ÿ± ÿÆŸÅŸäŸÅÿ© ÿ≠ŸàŸÑŸÉ', type: 'aura', dmg: 4, cd: 0.5, range: 55, icon: 'üí´' },
    spear: { name: 'ÿßŸÑÿ±ŸÖÿ≠', desc: 'Ÿäÿ±ŸÖŸä ÿ±ŸÖÿ≠ ŸÑÿ£ŸÇÿ±ÿ® ÿπÿØŸà', type: 'projectile', dmg: 5, cd: 0.45, range: 340, icon: 'üî±' },
    sword: { name: 'ÿßŸÑÿ≥ŸäŸÅ', desc: 'ÿ∂ÿ±ÿ®ÿ© ŸÇŸàÿ≥Ÿäÿ© ÿ£ŸÖÿßŸÖŸÉ', type: 'melee', dmg: 5, cd: 0.65, range: 75, icon: '‚öîÔ∏è' },
    flame: { name: 'ÿßŸÑÿ¥ÿπŸÑÿ©', desc: 'ŸÉÿ±ÿßÿ™ ŸÜÿßÿ±Ÿäÿ© ŸÑÿ£ŸÇÿ±ÿ® ÿπÿØŸà', type: 'projectile', dmg: 5, cd: 0.3, range: 280, icon: 'üî•' },
    arrows: { name: 'ÿßŸÑÿ≥ŸáÿßŸÖ', desc: 'ÿ≥ŸáÿßŸÖ ÿ™ÿ∑ŸÑŸÇ ÿ®ŸÉŸÑ ÿßŸÑÿßÿ™ÿ¨ÿßŸáÿßÿ™', type: 'radial', dmg: 4, cd: 0.85, range: 320, icon: 'üèπ' },
    lightning: { name: 'ÿßŸÑÿ®ÿ±ŸÇ', desc: 'ÿµÿßÿπŸÇÿ© ÿπŸÑŸâ ÿπÿØŸà ÿπÿ¥Ÿàÿßÿ¶Ÿä', type: 'lightning', dmg: 5, cd: 1.8, range: 420, icon: '‚ö°' },
    tornado: { name: 'ÿßŸÑÿØŸàÿßŸÖÿ©', desc: 'ÿ•ÿπÿµÿßÿ± Ÿäÿ®ÿ∑ÿ¶ ÿßŸÑÿ£ÿπÿØÿßÿ°', type: 'tornado', dmg: 4, cd: 2.2, range: 160, icon: 'üå™Ô∏è' },
    meteor: { name: 'ÿßŸÑŸÜŸäÿ≤ŸÉ', desc: 'ÿµÿÆŸàÿ± ÿ™ÿ≥ŸÇÿ∑ ŸÖŸÜ ÿßŸÑÿ≥ŸÖÿßÿ°', type: 'meteor', dmg: 5, cd: 1.6, range: 90, icon: '‚òÑÔ∏è' }
};

// ==================== BOOKS ====================
const BOOKS = {
    power: { name: 'ŸÉÿ™ÿßÿ® ÿßŸÑŸÇŸàÿ©', desc: 'Ÿäÿ≤ŸäÿØ ŸÇŸàÿ© ÿßŸÑŸáÿ¨ŸàŸÖ', stat: 'damage', val: 0.08, icon: 'üìï' },
    speed: { name: 'ŸÉÿ™ÿßÿ® ÿßŸÑÿ≥ÿ±ÿπÿ©', desc: 'Ÿäÿ≤ŸäÿØ ÿ≥ÿ±ÿπÿ© ÿßŸÑŸáÿ¨ŸàŸÖ', stat: 'atkSpd', val: 0.06, icon: 'üìó' },
    wind: { name: 'ŸÉÿ™ÿßÿ® ÿßŸÑÿ±Ÿäÿ≠', desc: 'Ÿäÿ≤ŸäÿØ ÿ≥ÿ±ÿπÿ© ÿßŸÑÿ≠ÿ±ŸÉÿ©', stat: 'moveSpd', val: 0.05, icon: 'üìò' },
    wisdom: { name: 'ŸÉÿ™ÿßÿ® ÿßŸÑÿ≠ŸÉŸÖÿ©', desc: 'Ÿäÿ≤ŸäÿØ ÿßŸÑÿÆÿ®ÿ±ÿ© ÿßŸÑŸÖŸÉÿ™ÿ≥ÿ®ÿ©', stat: 'xp', val: 0.10, icon: 'üìô' },
    life: { name: 'ŸÉÿ™ÿßÿ® ÿßŸÑÿ≠Ÿäÿßÿ©', desc: 'Ÿäÿ≤ŸäÿØ ÿßŸÑÿµÿ≠ÿ© ÿßŸÑŸÇÿµŸàŸâ', stat: 'maxHp', val: 0.08, icon: 'üìì' },
    armor: { name: 'ŸÉÿ™ÿßÿ® ÿßŸÑÿØÿ±ÿπ', desc: 'ŸäŸÇŸÑŸÑ ÿßŸÑÿ∂ÿ±ÿ± ÿßŸÑŸÖÿ≥ÿ™ŸÑŸÖ', stat: 'armor', val: 0.04, icon: 'üìî' },
    magnet: { name: 'ŸÉÿ™ÿßÿ® ÿßŸÑŸÖÿ∫ŸÜÿßÿ∑Ÿäÿ≥', desc: 'Ÿäÿ≤ŸäÿØ ŸÖÿØŸâ ÿ¨ŸÖÿπ ÿßŸÑÿ£Ÿäÿ™ŸÖÿßÿ™', stat: 'pickup', val: 0.12, icon: 'üìí' },
    luck: { name: 'ŸÉÿ™ÿßÿ® ÿßŸÑÿ≠ÿ∏', desc: 'Ÿäÿ≤ŸäÿØ ÿ≠ÿ∏ ÿØÿ±Ÿàÿ® ÿßŸÑÿ£Ÿäÿ™ŸÖÿßÿ™', stat: 'luck', val: 0.06, icon: 'üìö' },
    curse: { name: 'ŸÉÿ™ÿßÿ® ÿßŸÑŸÑÿπŸÜÿ©', desc: 'ÿ£ÿπÿØÿßÿ° ÿ£ŸÉÿ´ÿ±ÿå ÿÆÿ®ÿ±ÿ© ÿ£ŸÉÿ´ÿ±', stat: 'curse', val: 0.15, icon: 'üìñ' },
    regen: { name: 'ŸÉÿ™ÿßÿ® ÿßŸÑÿ™ÿ¨ÿØŸäÿØ', desc: 'ÿ¥ŸÅÿßÿ° ŸÖÿ≥ÿ™ŸÖÿ± ŸÉŸÑ ÿ´ÿßŸÜŸäÿ©', stat: 'regen', val: 0.8, icon: 'üìú' }
};

// ==================== ITEMS ====================
const ITEMS = {
    // Common (ÿ¥ÿßÿ¶ÿπ)
    bread: { name: 'ÿÆÿ®ÿ≤', desc: 'Ÿäÿ≥ÿ™ÿπŸäÿØ 10 ÿµÿ≠ÿ©', rarity: 'COMMON', effect: 'heal', val: 10, icon: 'üçû' },
    feather: { name: 'ÿ±Ÿäÿ¥ÿ©', desc: '+15% ÿ≥ÿ±ÿπÿ© ÿ≠ÿ±ŸÉÿ© ŸÑŸÖÿØÿ© 10 ÿ´ŸàÿßŸÜŸä', rarity: 'COMMON', effect: 'tempSpeed', val: 0.15, dur: 10, icon: 'ü™∂' },
    pebble: { name: 'ÿ≠ÿµÿßÿ©', desc: '+10% ÿ∂ÿ±ÿ± ŸÑŸÖÿØÿ© 12 ÿ´ÿßŸÜŸäÿ©', rarity: 'COMMON', effect: 'tempDmg', val: 0.1, dur: 12, icon: 'ü™®' },
    herb: { name: 'ÿπÿ¥ÿ®ÿ©', desc: 'Ÿäÿ≥ÿ™ÿπŸäÿØ 5 ÿµÿ≠ÿ©', rarity: 'COMMON', effect: 'heal', val: 5, icon: 'üåø' },
    copper: { name: 'ŸÜÿ≠ÿßÿ≥', desc: '+5 ÿ∞Ÿáÿ®', rarity: 'COMMON', effect: 'gold', val: 5, icon: 'ü™ô' },
    
    // Rare (ŸÜÿßÿØÿ±)
    redPotion: { name: 'ÿ¨ÿ±ÿπÿ© ÿ≠ŸÖÿ±ÿßÿ°', desc: 'Ÿäÿ≥ÿ™ÿπŸäÿØ 30 ÿµÿ≠ÿ©', rarity: 'RARE', effect: 'heal', val: 30, icon: 'üß™' },
    bluePotion: { name: 'ÿ¨ÿ±ÿπÿ© ÿ≤ÿ±ŸÇÿßÿ°', desc: '+30% ÿ≥ÿ±ÿπÿ© Ÿáÿ¨ŸàŸÖ ŸÑŸÖÿØÿ© 15 ÿ´ÿßŸÜŸäÿ©', rarity: 'RARE', effect: 'tempAtkSpd', val: 0.3, dur: 15, icon: 'üß¥' },
    amulet: { name: 'ÿ™ŸÖŸäŸÖÿ©', desc: 'ÿØÿ±ÿπ ŸäŸÖÿ™ÿµ 20 ÿ∂ÿ±ÿ±', rarity: 'RARE', effect: 'shield', val: 20, icon: 'üìø' },
    hourglass: { name: 'ÿ≥ÿßÿπÿ© ÿ±ŸÖŸÑŸäÿ©', desc: 'Ÿäÿ®ÿ∑ÿ¶ ÿßŸÑÿ£ÿπÿØÿßÿ° 50% ŸÑŸÖÿØÿ© 5 ÿ´ŸàÿßŸÜŸä', rarity: 'RARE', effect: 'slow', val: 0.5, dur: 5, icon: '‚è≥' },
    silver: { name: 'ŸÅÿ∂ÿ©', desc: '+25 ÿ∞Ÿáÿ®', rarity: 'RARE', effect: 'gold', val: 25, icon: 'ü•à' },
    
    // Legendary (ÿ£ÿ≥ÿ∑Ÿàÿ±Ÿä)
    elixir: { name: 'ÿ•ŸÉÿ≥Ÿäÿ±', desc: 'Ÿäÿ≥ÿ™ÿπŸäÿØ ŸÉŸÑ ÿßŸÑÿµÿ≠ÿ© ŸàŸäÿ≤ŸäÿØ ÿßŸÑÿµÿ≠ÿ© ÿßŸÑŸÇÿµŸàŸâ 20', rarity: 'LEGENDARY', effect: 'fullHeal', val: 20, icon: '‚öóÔ∏è' },
    dragonHeart: { name: 'ŸÇŸÑÿ® ÿßŸÑÿ™ŸÜŸäŸÜ', desc: '+50% ÿ∂ÿ±ÿ± ŸÑŸÖÿØÿ© 25 ÿ´ÿßŸÜŸäÿ©', rarity: 'LEGENDARY', effect: 'tempDmg', val: 0.5, dur: 25, icon: '‚ù§Ô∏è‚Äçüî•' },
    phoenixEye: { name: 'ÿπŸäŸÜ ÿßŸÑÿπŸÜŸÇÿßÿ°', desc: 'ÿ•ÿ∞ÿß ŸÖÿ™ÿå ÿ™ÿπŸàÿØ ŸÑŸÑÿ≠Ÿäÿßÿ© ŸÖÿ±ÿ© Ÿàÿßÿ≠ÿØÿ©', rarity: 'LEGENDARY', effect: 'revive', val: 1, icon: 'üëÅÔ∏è' },
    crown: { name: 'ÿ™ÿßÿ¨ ÿ∞Ÿáÿ®Ÿä', desc: '+50% ÿ∞Ÿáÿ® ÿ®ÿ¥ŸÉŸÑ ÿØÿßÿ¶ŸÖ', rarity: 'LEGENDARY', effect: 'permGold', val: 0.5, icon: 'üëë' },
    star: { name: 'ŸÜÿ¨ŸÖÿ© ÿßŸÑÿµÿ≠ÿ±ÿßÿ°', desc: 'ÿ™ÿ≠ÿµŸÑ ÿπŸÑŸâ ÿ≥ŸÑÿßÿ≠ ÿ£Ÿà ŸÉÿ™ÿßÿ® ÿπÿ¥Ÿàÿßÿ¶Ÿä', rarity: 'LEGENDARY', effect: 'randomEquip', val: 1, icon: '‚≠ê' },
    khazouq: { name: 'ÿÆÿßÿ≤ŸàŸÇ', desc: 'Ÿäÿ≤ŸäÿØ ŸÜÿ≥ÿ®ÿ© ÿ∏ŸáŸàÿ± ÿßŸÑÿ£ÿπÿØÿßÿ° 10%ÿå ÿ£ŸÜÿ™ ÿ∫ÿ®Ÿä ŸÑŸäÿ¥ ÿ£ÿÆÿ∞ÿ™Ÿáÿü', rarity: 'LEGENDARY', effect: 'moreEnemies', val: 0.10, icon: 'üçÜ' }
};

// ==================== ENEMIES ====================
const ENEMIES = {
    wolf: { name: 'ÿ∞ÿ¶ÿ®', hpM: 1, atkM: 1, spdM: 1.2, xp: 2, time: 0, color: '#6a6a6a' },
    scorpion: { name: 'ÿπŸÇÿ±ÿ®', hpM: 0.7, atkM: 0.8, spdM: 1.5, xp: 2, time: 0, color: '#ffa500' },
    dhub: { name: 'ÿ∂ÿ®', hpM: 2, atkM: 1.2, spdM: 0.6, xp: 4, time: 60, color: '#5a8a5a', zig: true },
    snake: { name: 'ÿ´ÿπÿ®ÿßŸÜ', hpM: 1.2, atkM: 1, spdM: 1, xp: 3, time: 120, color: '#2d5a27', ranged: true },
    hyena: { name: 'ÿ∂ÿ®ÿπ', hpM: 0.8, atkM: 0.9, spdM: 1.3, xp: 2, time: 180, color: '#8b7355', pack: true },
    eagle: { name: 'ŸÜÿ≥ÿ±', hpM: 1, atkM: 1.3, spdM: 1.6, xp: 4, time: 240, color: '#4a3728' },
    lion: { name: 'ÿ£ÿ≥ÿØ', hpM: 3, atkM: 2, spdM: 0.8, xp: 8, time: 300, color: '#c4a35a' },
    djinn: { name: 'ÿ¨ŸÜŸä', hpM: 1.5, atkM: 1.5, spdM: 1.4, xp: 6, time: 360, color: '#4a0080', tp: true },
    ghoul: { name: 'ÿ∫ŸàŸÑ', hpM: 5, atkM: 2.5, spdM: 0.5, xp: 12, time: 420, color: '#2a2a2a' },
    knight: { name: 'ŸÅÿßÿ±ÿ≥', hpM: 2.5, atkM: 1.8, spdM: 1, xp: 10, time: 480, color: '#1a1a1a' }
};

const BOSS = { name: 'ÿßÿ®Ÿà ÿ≠ŸÑÿ≤Ÿá', hp: 8000, atk: 35, spd: 55, color: '#8b0000' };

// ==================== ASSET LOADER ====================
class AssetLoader {
    constructor() {
        this.images = {};
        this.loaded = false;
    }
    
    loadImage(name, src) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => { this.images[name] = img; resolve(img); };
            img.onerror = reject;
            img.src = src;
        });
    }
    
    async loadAll() {
        const assets = [
            // Characters
            ['char_001', 'assets/characters/Char_001.png'],
            ['char_001_idle', 'assets/characters/Char_001_Idle.png'],
            ['char_002', 'assets/characters/Char_002.png'],
            ['char_002_idle', 'assets/characters/Char_002_Idle.png'],
            ['char_003', 'assets/characters/Char_003.png'],
            ['char_003_idle', 'assets/characters/Char_003_Idle.png'],
            ['char_004', 'assets/characters/Char_004.png'],
            ['char_004_idle', 'assets/characters/Char_004_Idle.png'],
            ['char_005', 'assets/characters/Char_005.png'],
            ['char_005_idle', 'assets/characters/Char_005_Idle.png'],
            ['char_006', 'assets/characters/Char_006.png'],
            ['char_006_idle', 'assets/characters/Char_006_Idle.png'],
            
            // Enemies
            ['wolf', 'assets/enemies/wolf.png'],
            ['scorpion', 'assets/enemies/scorpion.png'],
            ['dhub', 'assets/enemies/dhub.png'],
            
            // Pickups
            ['gold_coin', 'assets/pickups/gold_coin.png'],
            ['xp_gem', 'assets/pickups/xp_gem.png'],
            
            // Backgrounds
            ['sand_tile', 'assets/backgrounds/sand_tile.png'],
            ['tiles', 'assets/tiles-all-32x32.png'],
            
            // Effects
            ['fx_spark', 'assets/01.png'],
            ['fx_fire_small', 'assets/02.png'],
            ['fx_explosion', 'assets/03.png'],
            ['fx_fireball', 'assets/04.png'],
            ['fx_flames', 'assets/05.png'],
            ['fx_ice', 'assets/10.png'],
            ['fx_magic', 'assets/15.png'],
            ['fx_heal', 'assets/20.png'],
            ['fx_dust', 'assets/25.png'],
            ['fx_circle', 'assets/30.png'],
            ['fx_water', 'assets/35.png']
        ];
        
        try {
            await Promise.all(assets.map(([name, src]) => this.loadImage(name, src)));
            this.loaded = true;
            console.log('All assets loaded!');
        } catch (e) {
            console.warn('Some assets failed to load, using fallback rendering');
            this.loaded = false;
        }
    }
    
    get(name) {
        return this.images[name];
    }
}

// Character sprite mappings
const CHAR_SPRITES = {
    abuSulaiman: { sprite: 'char_003', idle: 'char_003_idle', frameWidth: 48, frameHeight: 48, frames: 4 },
    jayzen: { sprite: 'char_006', idle: 'char_006_idle', frameWidth: 48, frameHeight: 48, frames: 4 },
    noura: { sprite: 'char_005', idle: 'char_005_idle', frameWidth: 48, frameHeight: 48, frames: 4 },
    bedouin: { sprite: 'char_002', idle: 'char_002_idle', frameWidth: 48, frameHeight: 48, frames: 4 },
    hawshabi: { sprite: 'char_004', idle: 'char_004_idle', frameWidth: 48, frameHeight: 48, frames: 4 },
    layla: { sprite: 'char_001', idle: 'char_001_idle', frameWidth: 48, frameHeight: 48, frames: 4 }
};

// Enemy sprite mappings
const ENEMY_SPRITES = {
    wolf: { sprite: 'wolf', width: 48, height: 48 },
    scorpion: { sprite: 'scorpion', width: 40, height: 40 },
    dhub: { sprite: 'dhub', width: 48, height: 48 },
    snake: { sprite: 'scorpion', width: 40, height: 40 },
    hyena: { sprite: 'wolf', width: 48, height: 48 },
    eagle: { sprite: 'wolf', width: 48, height: 48 },
    lion: { sprite: 'wolf', width: 48, height: 48 },
    djinn: { sprite: 'scorpion', width: 40, height: 40 },
    ghoul: { sprite: 'dhub', width: 48, height: 48 },
    knight: { sprite: 'wolf', width: 48, height: 48 }
};

// ==================== AUDIO ====================
class Audio {
    constructor() { this.ctx = null; }
    init() { if (!this.ctx) try { this.ctx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e) {} }
    tone(f, d, t='square', v=0.12) {
        if (!this.ctx) return;
        const o = this.ctx.createOscillator(), g = this.ctx.createGain();
        o.type = t; o.frequency.value = f; o.connect(g); g.connect(this.ctx.destination);
        g.gain.setValueAtTime(v, this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + d);
        o.start(); o.stop(this.ctx.currentTime + d);
    }
    hit() { this.tone(150, 0.1, 'sawtooth', 0.15); }
    shoot() { this.tone(320, 0.03); }
    pickup() { this.tone(520, 0.04, 'sine'); }
    levelUp() { [523,659,784,1047].forEach((f,i) => setTimeout(() => this.tone(f,0.1,'sine',0.15), i*60)); }
    victory() { [523,659,784,880,1047].forEach((f,i) => setTimeout(() => this.tone(f,0.18,'sine',0.2), i*100)); }
    death() { this.tone(160, 0.2, 'sawtooth'); this.tone(80, 0.25, 'sawtooth'); }
    bossWarn() { this.tone(80, 0.35, 'sawtooth', 0.25); setTimeout(() => this.tone(60, 0.35, 'sawtooth', 0.25), 400); }
    itemDrop() { this.tone(700, 0.08, 'sine', 0.2); this.tone(900, 0.12, 'sine', 0.15); }
}

// ==================== PARTICLES ====================
class Particles {
    constructor() { this.list = []; this.stains = []; }
    emit(x, y, n, opt = {}) {
        for (let i = 0; i < n; i++) {
            const a = Math.random() * Math.PI * 2, s = (opt.minS || 35) + Math.random() * ((opt.maxS || 100) - (opt.minS || 35));
            this.list.push({ x, y, vx: Math.cos(a) * s, vy: Math.sin(a) * s, color: opt.color || '#fff', size: 2 + Math.random() * 2.5, life: 0.6, maxLife: 0.6, gravity: opt.gravity || 0 });
        }
    }
    blood(x, y) { this.emit(x, y, 8, { color: '#8b0000', minS: 35, maxS: 130, gravity: 160 }); this.stains.push({ x, y, size: 5 + Math.random() * 8 }); if (this.stains.length > 100) this.stains.shift(); }
    update(dt) { this.list = this.list.filter(p => { p.x += p.vx * dt; p.y += p.vy * dt; p.vy += p.gravity * dt; p.life -= dt; return p.life > 0; }); }
    draw(ctx, cam) {
        ctx.fillStyle = '#4a0000';
        for (const s of this.stains) { ctx.globalAlpha = 0.3; ctx.beginPath(); ctx.arc(s.x - cam.x, s.y - cam.y, s.size, 0, Math.PI * 2); ctx.fill(); }
        for (const p of this.list) { ctx.globalAlpha = p.life / p.maxLife; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x - cam.x, p.y - cam.y, p.size, 0, Math.PI * 2); ctx.fill(); }
        ctx.globalAlpha = 1;
    }
}

// ==================== FLOAT TEXT ====================
class FloatText {
    constructor(x, y, text, color = '#fff', size = 14) { this.x = x; this.y = y; this.text = text; this.color = color; this.size = size; this.life = 0.7; this.vy = -45; }
    update(dt) { this.y += this.vy * dt; this.life -= dt; }
    draw(ctx, cam) { ctx.globalAlpha = this.life / 0.7; ctx.fillStyle = this.color; ctx.font = `bold ${this.size}px Cairo`; ctx.textAlign = 'center'; ctx.fillText(this.text, this.x - cam.x, this.y - cam.y); ctx.globalAlpha = 1; }
}

// ==================== SPRITE EFFECTS ====================
class SpriteEffect {
    constructor(x, y, spriteKey, frameWidth, frameHeight, totalFrames, duration, scale = 1) {
        this.x = x; 
        this.y = y;
        this.spriteKey = spriteKey;
        this.frameWidth = frameWidth;
        this.frameHeight = frameHeight;
        this.totalFrames = totalFrames;
        this.duration = duration;
        this.scale = scale;
        this.time = 0;
        this.done = false;
    }
    
    update(dt) {
        this.time += dt;
        if (this.time >= this.duration) this.done = true;
    }
    
    draw(ctx, cam, assets) {
        if (this.done) return;
        const sprite = assets && assets.get(this.spriteKey);
        if (!sprite) return;
        
        const progress = this.time / this.duration;
        const frame = Math.min(Math.floor(progress * this.totalFrames), this.totalFrames - 1);
        const sx = this.x - cam.x, sy = this.y - cam.y;
        
        ctx.imageSmoothingEnabled = false;
        ctx.globalAlpha = 1 - progress * 0.3;
        
        const drawW = this.frameWidth * this.scale;
        const drawH = this.frameHeight * this.scale;
        
        // Calculate frame position (assuming horizontal strip)
        const frameX = frame * this.frameWidth;
        
        ctx.drawImage(
            sprite,
            frameX, 0, this.frameWidth, this.frameHeight,
            sx - drawW / 2, sy - drawH / 2, drawW, drawH
        );
        
        ctx.globalAlpha = 1;
    }
}

// ==================== PLAYER ====================
class Player {
    constructor(x, y, charId) {
        this.x = x; this.y = y; this.charId = charId;
        const c = CHARACTERS[charId];
        this.maxHp = c.stats.hp || 100; this.hp = this.maxHp;
        this.speed = c.stats.speed || 200;
        this.dmgMult = 1; this.atkSpd = 1;
        this.pickupRange = 40 * (c.stats.pickup || 1);
        this.xpMult = c.stats.xpMult || 1;
        this.goldMult = c.stats.gold || 1;
        this.dmgReduce = c.stats.dmgReduce || 0;
        this.luck = c.stats.luck || 1;
        this.crit = c.stats.crit || 0;
        this.enemyBuff = c.stats.enemyBuff || 0;
        this.extraEnemySpawn = 0;
        this.armor = 0; this.regen = 0; this.curse = 0;
        this.range = c.stats.range || 1;
        this.cdMult = c.stats.cooldown || 1;
        
        this.weapons = [{ id: c.weapon, level: 1, upgrades: [] }];
        this.books = [];
        this.xp = 0; this.level = 1; this.gold = 0; this.kills = 0;
        this.invuln = 0; this.facing = 1; this.vx = 0; this.vy = 0; this.anim = 0;
        this.shield = 0; this.hasRevive = false; this.tempBuffs = [];
        this.wTimers = {};
        this.width = 32; this.height = 45;
    }
    
    getDmg(w) {
        let d = CONFIG.WEAPON_BASE_DMG + (w.level - 1) * 0.4;
        w.upgrades.forEach(u => d += u.rarity.bonus);
        d *= this.dmgMult;
        this.tempBuffs.filter(b => b.type === 'dmg').forEach(b => d *= (1 + b.val));
        if (this.crit > 0 && Math.random() < this.crit) d *= 2;
        return d;
    }
    getCD(w) { let m = this.cdMult / this.atkSpd; this.tempBuffs.filter(b => b.type === 'atkSpd').forEach(b => m /= (1 + b.val)); return Math.max(0.08, WEAPONS[w.id].cd * m * (1 - (w.level - 1) * 0.015)); }
    getRange(w) { return WEAPONS[w.id].range * this.range * (1 + (w.level - 1) * 0.025); }
    
    findNearest(game, maxD = 450) {
        let near = null, minD = maxD;
        for (const e of game.enemies) { const d = Math.hypot(e.x - this.x, e.y - this.y); if (d < minD) { minD = d; near = e; } }
        if (game.boss) { const d = Math.hypot(game.boss.x - this.x, game.boss.y - this.y); if (d < minD) near = game.boss; }
        return near;
    }
    
    update(dt, input, game) {
        let dx = 0, dy = 0;
        if (input.left) dx -= 1; if (input.right) dx += 1; if (input.up) dy -= 1; if (input.down) dy += 1;
        if (input.joy) { dx += input.joy.x; dy += input.joy.y; }
        const mag = Math.hypot(dx, dy);
        if (mag > 0) {
            dx /= mag; dy /= mag;
            let spd = this.speed; this.tempBuffs.filter(b => b.type === 'speed').forEach(b => spd *= (1 + b.val));
            this.vx = dx * spd; this.vy = dy * spd;
            if (dx !== 0) this.facing = dx > 0 ? 1 : -1;
        } else { this.vx = 0; this.vy = 0; }
        
        this.x += this.vx * dt; this.y += this.vy * dt;
        this.x = Math.max(-CONFIG.WORLD_SIZE/2, Math.min(CONFIG.WORLD_SIZE/2, this.x));
        this.y = Math.max(-CONFIG.WORLD_SIZE/2, Math.min(CONFIG.WORLD_SIZE/2, this.y));
        if (this.invuln > 0) this.invuln -= dt;
        this.anim += dt;
        if (this.regen > 0) this.hp = Math.min(this.maxHp, this.hp + this.regen * dt);
        this.tempBuffs = this.tempBuffs.filter(b => { b.dur -= dt; return b.dur > 0; });
        
        const target = this.findNearest(game);
        this.weapons.forEach(w => {
            if (!this.wTimers[w.id]) this.wTimers[w.id] = 0;
            this.wTimers[w.id] -= dt;
            if (this.wTimers[w.id] <= 0) { this.fire(w, game, target); this.wTimers[w.id] = this.getCD(w); }
        });
    }
    
    fire(w, game, target) {
        const data = WEAPONS[w.id], dmg = this.getDmg(w), range = this.getRange(w);
        switch(data.type) {
            case 'projectile':
                if (target && Math.hypot(target.x - this.x, target.y - this.y) < range) {
                    const a = Math.atan2(target.y - this.y, target.x - this.x);
                    const isFlame = data.icon === 'üî•';
                    game.proj.push({ 
                        x: this.x, y: this.y, 
                        vx: Math.cos(a) * 360, vy: Math.sin(a) * 360, 
                        dmg, life: 2.2, size: isFlame ? 8 : 6, 
                        color: isFlame ? '#ff4500' : '#8b4513', 
                        pierce: w.level > 10 ? 2 : 1,
                        type: isFlame ? 'fire' : 'normal'
                    });
                    game.audio.shoot();
                    // Muzzle flash effect
                    if (isFlame) {
                        game.spriteEffects.push(new SpriteEffect(this.x, this.y, 'fx_fire_small', 24, 24, 6, 0.2, 1.2));
                    }
                }
                break;
            case 'radial': {
                const n = 4 + Math.floor(w.level / 4);
                for (let i = 0; i < n; i++) { 
                    const a = (i / n) * Math.PI * 2; 
                    game.proj.push({ x: this.x, y: this.y, vx: Math.cos(a) * 300, vy: Math.sin(a) * 300, dmg: dmg * 0.65, life: 1.8, size: 5, color: '#6a4a20' }); 
                }
                game.audio.shoot();
                break;
            }
            case 'lightning': {
                const ts = game.enemies.filter(e => Math.hypot(e.x - this.x, e.y - this.y) < range);
                if (ts.length > 0) { 
                    const t = ts[Math.floor(Math.random() * ts.length)]; 
                    game.fx.push({ type: 'lightning', x: t.x, y: t.y, life: 0.25 }); 
                    // Add spark effect
                    game.spriteEffects.push(new SpriteEffect(t.x, t.y, 'fx_spark', 24, 24, 5, 0.3, 1.5));
                    if (t.takeDmg(dmg, game)) game.killEnemy(t); 
                    game.audio.tone(650, 0.06, 'sawtooth'); 
                }
                break;
            }
            case 'meteor': {
                const n = 1 + Math.floor(w.level / 4);
                for (let i = 0; i < n; i++) {
                    const mx = this.x + (Math.random() - 0.5) * range * 2;
                    const my = this.y + (Math.random() - 0.5) * range * 2;
                    game.fx.push({ type: 'meteor', x: mx, y: my, dmg, radius: 55, life: 0.75, delay: i * 0.12, hit: false });
                }
                break;
            }
            case 'tornado':
                game.fx.push({ type: 'tornado', x: this.x + this.facing * 35, y: this.y, vx: this.facing * 85, vy: 0, dmg: dmg * 0.35, slow: 0.5, life: 3.2 + w.level * 0.12, radius: 35 });
                // Dust effect
                game.spriteEffects.push(new SpriteEffect(this.x + this.facing * 35, this.y, 'fx_dust', 24, 24, 5, 0.4, 1.2));
                break;
        }
    }
    
    takeDmg(amt, game) {
        if (this.invuln > 0) return;
        if (this.shield > 0) { const ab = Math.min(this.shield, amt); this.shield -= ab; amt -= ab; if (amt <= 0) return; }
        const actual = amt * (1 - this.dmgReduce) * (1 - Math.min(0.65, this.armor * 0.025));
        this.hp -= actual; this.invuln = 0.35;
        game.audio.hit(); game.shake = 0.12;
        game.texts.push(new FloatText(this.x, this.y - 20, `-${Math.round(actual)}`, '#f00'));
        if (this.hp <= 0) {
            if (this.hasRevive) { this.hasRevive = false; this.hp = this.maxHp * 0.5; this.invuln = 1.2; game.texts.push(new FloatText(this.x, this.y - 35, 'ÿ•ÿ≠Ÿäÿßÿ°!', '#ffd700', 18)); }
            else game.over(false);
        }
    }
    
    draw(ctx, cam, assets) {
        const sx = this.x - cam.x, sy = this.y - cam.y;
        if (this.invuln > 0 && Math.floor(this.invuln * 12) % 2 === 0) ctx.globalAlpha = 0.35;
        
        ctx.save();
        
        // Try to draw sprite if available
        const spriteInfo = CHAR_SPRITES[this.charId];
        const isMoving = Math.abs(this.vx) > 10 || Math.abs(this.vy) > 10;
        const spriteKey = isMoving ? spriteInfo.sprite : spriteInfo.idle;
        const sprite = assets && assets.get(spriteKey);
        
        if (sprite && spriteInfo) {
            // Calculate animation frame
            const frameTime = 0.15;
            const totalFrames = spriteInfo.frames;
            const currentFrame = Math.floor(this.anim / frameTime) % totalFrames;
            
            // Determine direction row (0=down, 1=left, 2=right, 3=up based on typical RPG sprite sheets)
            let row = 0;
            if (isMoving) {
                if (Math.abs(this.vx) > Math.abs(this.vy)) {
                    row = this.vx > 0 ? 2 : 1; // right or left
                } else {
                    row = this.vy > 0 ? 0 : 3; // down or up
                }
            } else {
                row = this.facing > 0 ? 2 : 1;
            }
            
            const frameX = currentFrame * spriteInfo.frameWidth;
            const frameY = row * spriteInfo.frameHeight;
            
            // Draw sprite
            const scale = 1.5;
            const drawW = spriteInfo.frameWidth * scale;
            const drawH = spriteInfo.frameHeight * scale;
            
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(
                sprite,
                frameX, frameY, spriteInfo.frameWidth, spriteInfo.frameHeight,
                sx - drawW / 2, sy - drawH / 2, drawW, drawH
            );
        } else {
            // Fallback to simple rendering
            const c = CHARACTERS[this.charId].colors;
            if (this.facing < 0) { ctx.translate(sx, sy); ctx.scale(-1, 1); ctx.translate(-sx, sy); }
            
            ctx.fillStyle = c.body;
            ctx.fillRect(sx - 10, sy - 8, 20, 26);
            ctx.fillStyle = c.head;
            ctx.fillRect(sx - 8, sy - 24, 16, 8);
            ctx.fillStyle = c.skin;
            ctx.fillRect(sx - 7, sy - 16, 14, 10);
            ctx.fillStyle = '#000';
            ctx.fillRect(sx - 4, sy - 13, 2, 2);
            ctx.fillRect(sx + 2, sy - 13, 2, 2);
            ctx.fillStyle = c.legs;
            ctx.fillRect(sx - 6, sy + 18, 5, 8);
            ctx.fillRect(sx + 1, sy + 18, 5, 8);
        }
        
        ctx.restore();
        ctx.globalAlpha = 1;
        
        // Weapon visuals
        this.weapons.forEach(w => {
            const data = WEAPONS[w.id], range = this.getRange(w);
            if (data.type === 'orbit') {
                const n = 4 + Math.floor(w.level / 5);
                ctx.fillStyle = '#333';
                for (let i = 0; i < n; i++) {
                    const a = this.anim * 2 + (i / n) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.arc(sx + Math.cos(a) * range, sy + Math.sin(a) * range, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (data.type === 'melee') {
                const timer = this.wTimers[w.id] || 0, cd = this.getCD(w);
                if (timer > cd * 0.8) {
                    ctx.strokeStyle = 'rgba(150, 150, 150, 0.4)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(sx, sy, range, -0.5 * this.facing, 0.5 * this.facing);
                    ctx.stroke();
                }
            }
            if (data.type === 'aura') {
                ctx.strokeStyle = 'rgba(100, 50, 150, 0.2)';
                ctx.lineWidth = 2;
                ctx.setLineDash([4, 6]);
                ctx.beginPath();
                ctx.arc(sx, sy, range, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        });
        
        // Shield indicator
        if (this.shield > 0) {
            ctx.strokeStyle = 'rgba(80, 160, 255, 0.5)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(sx, sy, 30, 0, Math.PI * 2);
            ctx.stroke();
        }
    }
}

// ==================== ENEMY ====================
class Enemy {
    constructor(x, y, type, gameTime, buff = 0) {
        this.x = x; this.y = y; this.type = type;
        const e = ENEMIES[type];
        const scale = 1 + (gameTime / 60) * CONFIG.SCALING_PER_MIN;
        const buffScale = 1 + buff;
        this.maxHp = Math.round(CONFIG.ENEMY_BASE_HP * e.hpM * scale * buffScale);
        this.hp = this.maxHp;
        this.atk = CONFIG.ENEMY_BASE_ATK * e.atkM * scale * buffScale;
        this.spd = CONFIG.ENEMY_BASE_SPEED * e.spdM;
        this.xp = e.xp; this.color = e.color;
        this.vx = 0; this.vy = 0; this.hitFlash = 0; this.slow = 1; this.slowT = 0;
        this.zigT = 0; this.zigD = 1; this.tpT = 0; this.atkT = 0;
        this.width = 24; this.height = 24;
        this.zig = e.zig; this.ranged = e.ranged; this.tp = e.tp;
    }
    
    update(dt, player, enemies, game) {
        const dx = player.x - this.x, dy = player.y - this.y, dist = Math.hypot(dx, dy);
        if (this.slowT > 0) { this.slowT -= dt; if (this.slowT <= 0) this.slow = 1; }
        if (dist > 0) {
            let mx = dx / dist, my = dy / dist;
            if (this.zig) { this.zigT += dt; if (this.zigT > 0.35) { this.zigT = 0; this.zigD *= -1; } mx = mx * 0.7 + (-my * this.zigD) * 0.3; my = my * 0.7 + (mx * this.zigD) * 0.3; }
            if (this.tp) { this.tpT += dt; if (this.tpT > 1.5 && dist > 70) { this.tpT = 0; const a = Math.random() * Math.PI * 2; this.x = player.x + Math.cos(a) * 100; this.y = player.y + Math.sin(a) * 100; game.particles.emit(this.x, this.y, 6, { color: '#4a0080' }); } }
            if (this.ranged && dist < 220 && dist > 50) { this.atkT -= dt; if (this.atkT <= 0) { this.atkT = 1.2; const a = Math.atan2(dy, dx); game.eProj.push({ x: this.x, y: this.y, vx: Math.cos(a) * 160, vy: Math.sin(a) * 160, dmg: this.atk * 0.4, life: 2.2, size: 3, color: this.color }); } }
            let sepX = 0, sepY = 0;
            for (const o of enemies) { if (o === this) continue; const ox = this.x - o.x, oy = this.y - o.y, od = Math.hypot(ox, oy); if (od < 25 && od > 0) { sepX += ox / od * (25 - od) / 25; sepY += oy / od * (25 - od) / 25; } }
            mx += sepX * 0.35; my += sepY * 0.35;
            const m = Math.hypot(mx, my); if (m > 0) { this.vx = (mx / m) * this.spd * this.slow; this.vy = (my / m) * this.spd * this.slow; }
        }
        this.x += this.vx * dt; this.y += this.vy * dt;
        if (this.hitFlash > 0) this.hitFlash -= dt;
    }
    
    takeDmg(amt, game) { this.hp -= amt; this.hitFlash = 0.06; game.texts.push(new FloatText(this.x + (Math.random() - 0.5) * 12, this.y - 12, Math.round(amt).toString(), '#ff0')); return this.hp <= 0; }
    
    draw(ctx, cam, assets) {
        const sx = this.x - cam.x, sy = this.y - cam.y;
        if (this.hitFlash > 0) ctx.globalAlpha = 0.55;
        
        // Try to draw sprite if available
        const spriteInfo = ENEMY_SPRITES[this.type];
        const sprite = assets && spriteInfo && assets.get(spriteInfo.sprite);
        
        if (sprite) {
            ctx.save();
            ctx.imageSmoothingEnabled = false;
            
            const scale = 1.2;
            const drawW = spriteInfo.width * scale;
            const drawH = spriteInfo.height * scale;
            
            // Flip based on movement direction
            if (this.vx < 0) {
                ctx.translate(sx, sy);
                ctx.scale(-1, 1);
                ctx.drawImage(sprite, -drawW / 2, -drawH / 2, drawW, drawH);
            } else {
                ctx.drawImage(sprite, sx - drawW / 2, sy - drawH / 2, drawW, drawH);
            }
            
            ctx.restore();
        } else {
            // Fallback to simple circle
            ctx.fillStyle = this.color;
            ctx.beginPath(); 
            ctx.arc(sx, sy, 12, 0, Math.PI * 2); 
            ctx.fill();
            ctx.fillStyle = '#f00';
            ctx.fillRect(sx - 3, sy - 2, 2, 2); 
            ctx.fillRect(sx + 1, sy - 2, 2, 2);
        }
        
        ctx.globalAlpha = 1;
        
        // Health bar
        if (this.hp < this.maxHp) { 
            ctx.fillStyle = '#333'; 
            ctx.fillRect(sx - 15, sy - 22, 30, 4); 
            ctx.fillStyle = '#f00'; 
            ctx.fillRect(sx - 15, sy - 22, 30 * (this.hp / this.maxHp), 4); 
        }
    }
}

// ==================== BOSS ====================
class Boss {
    constructor(x, y, buff = 0) {
        this.x = x; this.y = y;
        this.maxHp = BOSS.hp * (1 + buff); this.hp = this.maxHp;
        this.atk = BOSS.atk * (1 + buff); this.spd = BOSS.spd;
        this.phase = 1; this.atkT = 0; this.specT = 0; this.hitFlash = 0;
        this.width = 70; this.height = 70;
    }
    update(dt, player, game) {
        const pct = this.hp / this.maxHp; this.phase = pct < 0.33 ? 3 : pct < 0.66 ? 2 : 1;
        const dx = player.x - this.x, dy = player.y - this.y, dist = Math.hypot(dx, dy);
        if (dist > 0) { const s = this.spd * (1 + (3 - this.phase) * 0.12); this.x += (dx / dist) * s * dt; this.y += (dy / dist) * s * dt; }
        this.atkT -= dt;
        if (this.atkT <= 0) { this.atkT = 1.6 / this.phase; const a = Math.atan2(dy, dx); for (let i = -2; i <= 2; i++) game.eProj.push({ x: this.x, y: this.y, vx: Math.cos(a + i * 0.12) * 200, vy: Math.sin(a + i * 0.12) * 200, dmg: this.atk, life: 2.2, size: 7, color: '#ff4500' }); }
        if (this.phase >= 2) { this.specT -= dt; if (this.specT <= 0) { this.specT = 3.5; const types = ['wolf', 'scorpion']; for (let i = 0; i < this.phase * 2; i++) { const a = Math.random() * Math.PI * 2; game.enemies.push(new Enemy(this.x + Math.cos(a) * 70, this.y + Math.sin(a) * 70, types[Math.floor(Math.random() * types.length)], game.time, player.enemyBuff)); } } }
        if (this.hitFlash > 0) this.hitFlash -= dt;
    }
    takeDmg(amt, game) { this.hp -= amt; this.hitFlash = 0.06; game.texts.push(new FloatText(this.x + (Math.random() - 0.5) * 25, this.y - 25, Math.round(amt).toString(), '#ff0', 16)); return this.hp <= 0; }
    draw(ctx, cam) {
        const sx = this.x - cam.x, sy = this.y - cam.y;
        if (this.hitFlash > 0) ctx.globalAlpha = 0.55;
        ctx.fillStyle = BOSS.color;
        ctx.beginPath(); ctx.ellipse(sx, sy, 35, 30, 0, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(sx, sy - 30, 22, 16, 0, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#ff0';
        ctx.fillRect(sx - 12, sy - 34, 5, 5); ctx.fillRect(sx + 7, sy - 34, 5, 5);
        ctx.fillStyle = '#5a0000';
        ctx.beginPath(); ctx.moveTo(sx - 30, sy - 8); ctx.lineTo(sx - 48, sy - 35); ctx.lineTo(sx - 18, sy - 4); ctx.fill();
        ctx.beginPath(); ctx.moveTo(sx + 30, sy - 8); ctx.lineTo(sx + 48, sy - 35); ctx.lineTo(sx + 18, sy - 4); ctx.fill();
        ctx.globalAlpha = 1;
    }
}

// ==================== PICKUPS ====================
class Pickup {
    constructor(x, y, type, val) { this.x = x; this.y = y; this.type = type; this.val = val; this.bob = Math.random() * Math.PI * 2; }
    update(dt) { this.bob += dt * 3.5; }
    draw(ctx, cam, assets) {
        const sx = this.x - cam.x, sy = this.y - cam.y + Math.sin(this.bob) * 3;
        
        const sprite = this.type === 'xp' ? assets && assets.get('xp_gem') : assets && assets.get('gold_coin');
        
        if (sprite) {
            ctx.imageSmoothingEnabled = false;
            const size = this.type === 'xp' ? 18 : 16;
            ctx.drawImage(sprite, sx - size / 2, sy - size / 2, size, size);
        } else {
            // Fallback
            if (this.type === 'xp') { 
                ctx.fillStyle = '#0f0'; 
                ctx.beginPath(); 
                ctx.moveTo(sx, sy - 6); 
                ctx.lineTo(sx + 6, sy); 
                ctx.lineTo(sx, sy + 6); 
                ctx.lineTo(sx - 6, sy); 
                ctx.fill(); 
            } else { 
                ctx.fillStyle = '#ffd700'; 
                ctx.beginPath(); 
                ctx.arc(sx, sy, 5, 0, Math.PI * 2); 
                ctx.fill(); 
            }
        }
    }
}

class ItemDrop {
    constructor(x, y, id) { this.x = x; this.y = y; this.id = id; this.bob = Math.random() * Math.PI * 2; }
    update(dt) { this.bob += dt * 3.5; }
    draw(ctx, cam) {
        const sx = this.x - cam.x, sy = this.y - cam.y + Math.sin(this.bob) * 3.5;
        const item = ITEMS[this.id];
        ctx.fillStyle = RARITY[item.rarity].color + '30';
        ctx.beginPath(); ctx.arc(sx, sy, 13, 0, Math.PI * 2); ctx.fill();
        ctx.font = '16px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(item.icon, sx, sy);
    }
}

// ==================== GAME ====================
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.audio = new Audio();
        this.particles = new Particles();
        this.assets = new AssetLoader();
        
        this.state = 'loading';
        this.charIdx = 0;
        this.charIds = Object.keys(CHARACTERS);
        this.city = 'badaya';
        
        this.player = null;
        this.enemies = [];
        this.boss = null;
        this.proj = [];
        this.eProj = [];
        this.pickups = [];
        this.items = [];
        this.texts = [];
        this.fx = [];
        this.spriteEffects = [];
        
        this.cam = { x: 0, y: 0 };
        this.shake = 0;
        this.input = { up: false, down: false, left: false, right: false, joy: null };
        
        this.spawnT = 0; this.time = 0;
        this.bossSpawned = false; this.bossWarnShown = false;
        this.globalSlow = 0;
        
        this.pendingItem = null;
        
        this.highScore = parseInt(localStorage.getItem('goldBloodHighScore') || '0');
        this.baghdadUnlocked = localStorage.getItem('baghdadUnlocked') === 'true';
        
        // Cached tile image
        this.sandTilePattern = null;
        
        this.lastTime = 0;
        this.init();
    }
    
    async init() {
        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.setupInput();
        
        // Show loading screen
        this.drawLoading();
        
        // Load assets
        await this.assets.loadAll();
        
        // Create sand tile pattern if loaded
        if (this.assets.get('sand_tile')) {
            this.sandTilePattern = this.ctx.createPattern(this.assets.get('sand_tile'), 'repeat');
        }
        
        this.state = 'menu';
        this.setupMenu();
        requestAnimationFrame(t => this.loop(t));
    }
    
    drawLoading() {
        const ctx = this.ctx;
        ctx.fillStyle = '#0a0a0f';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 24px Cairo';
        ctx.textAlign = 'center';
        ctx.fillText('ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÑÿπÿ®ÿ©...', this.canvas.width / 2, this.canvas.height / 2);
        ctx.fillStyle = '#888';
        ctx.font = '16px Cairo';
        ctx.fillText('Loading game assets...', this.canvas.width / 2, this.canvas.height / 2 + 35);
    }
    
    resize() { this.canvas.width = window.innerWidth; this.canvas.height = window.innerHeight; }
    
    setupMenu() {
        document.getElementById('highScore').textContent = this.highScore;
        if (this.baghdadUnlocked) { document.getElementById('cityBaghdad').classList.remove('locked'); document.getElementById('cityBaghdad').querySelector('.city-locked').style.display = 'none'; }
        this.updateCharDisplay();
        document.getElementById('charPrev').onclick = () => { this.charIdx = (this.charIdx - 1 + this.charIds.length) % this.charIds.length; this.updateCharDisplay(); };
        document.getElementById('charNext').onclick = () => { this.charIdx = (this.charIdx + 1) % this.charIds.length; this.updateCharDisplay(); };
        document.querySelectorAll('.city-card').forEach(card => { card.onclick = () => { if (card.classList.contains('locked')) return; document.querySelectorAll('.city-card').forEach(c => c.classList.remove('selected')); card.classList.add('selected'); this.city = card.dataset.city; }; });
        document.getElementById('startBtn').onclick = () => this.start();
        document.getElementById('restartBtn').onclick = () => this.restart();
        document.getElementById('itemContinueBtn').onclick = () => this.continueFromItem();
    }
    
    updateCharDisplay() {
        const id = this.charIds[this.charIdx], c = CHARACTERS[id];
        document.getElementById('charName').textContent = c.name;
        document.getElementById('charTitle').textContent = c.title;
        document.getElementById('charDesc').textContent = c.desc;
        document.getElementById('charWeapon').innerHTML = `üó°Ô∏è ${WEAPONS[c.weapon].name}`;
        let html = '';
        c.passiveText.forEach(p => { const neg = p.includes('ŸÇŸàÿ© ÿßŸÑÿ£ÿπÿØÿßÿ°'); html += `<div class="char-stat"><span class="char-stat-label">‚Ä¢</span><span class="${neg ? 'char-stat-negative' : 'char-stat-value'}">${p}</span></div>`; });
        document.getElementById('charStats').innerHTML = html;
        
        const canvas = document.getElementById('charPreview'), ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, 120, 120);
        
        // Try to draw sprite
        const spriteInfo = CHAR_SPRITES[id];
        const sprite = this.assets && this.assets.get(spriteInfo.idle);
        
        if (sprite) {
            ctx.imageSmoothingEnabled = false;
            const scale = 2;
            const drawW = spriteInfo.frameWidth * scale;
            const drawH = spriteInfo.frameHeight * scale;
            // Draw idle frame (row 0, frame 0)
            ctx.drawImage(
                sprite,
                0, 0, spriteInfo.frameWidth, spriteInfo.frameHeight,
                (120 - drawW) / 2, (120 - drawH) / 2, drawW, drawH
            );
        } else {
            // Fallback to simple drawing
            const col = c.colors;
            ctx.fillStyle = col.body; ctx.fillRect(42, 42, 36, 45);
            ctx.fillStyle = col.head; ctx.fillRect(45, 18, 30, 14);
            ctx.fillStyle = col.skin; ctx.fillRect(48, 32, 24, 16);
            ctx.fillStyle = '#000'; ctx.fillRect(52, 38, 4, 4); ctx.fillRect(64, 38, 4, 4);
            ctx.fillStyle = col.legs; ctx.fillRect(45, 87, 10, 15); ctx.fillRect(65, 87, 10, 15);
        }
    }
    
    setupInput() {
        window.addEventListener('keydown', e => {
            if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') this.input.up = true;
            if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') this.input.down = true;
            if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') this.input.left = true;
            if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') this.input.right = true;
            if ((e.key === 'Escape' || e.key === 'p') && this.state === 'playing') this.pause();
        });
        window.addEventListener('keyup', e => {
            if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') this.input.up = false;
            if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') this.input.down = false;
            if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') this.input.left = false;
            if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') this.input.right = false;
        });
        let touchStart = null;
        this.canvas.addEventListener('touchstart', e => { if (this.state !== 'playing') return; e.preventDefault(); touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY }; this.input.joy = { x: 0, y: 0 }; }, { passive: false });
        this.canvas.addEventListener('touchmove', e => { if (this.state !== 'playing' || !touchStart) return; e.preventDefault(); const dx = e.touches[0].clientX - touchStart.x, dy = e.touches[0].clientY - touchStart.y; const d = Math.min(Math.hypot(dx, dy), 60), a = Math.atan2(dy, dx); this.input.joy = { x: Math.cos(a) * d / 60, y: Math.sin(a) * d / 60 }; }, { passive: false });
        this.canvas.addEventListener('touchend', () => { touchStart = null; this.input.joy = null; });
    }
    
    setupSlots() {
        const ws = document.getElementById('weaponSlots'), bs = document.getElementById('bookSlots');
        ws.innerHTML = ''; bs.innerHTML = '';
        for (let i = 0; i < CONFIG.MAX_WEAPONS; i++) ws.innerHTML += `<div class="equipment-slot" id="ws${i}"></div>`;
        for (let i = 0; i < CONFIG.MAX_BOOKS; i++) bs.innerHTML += `<div class="equipment-slot" id="bs${i}"></div>`;
    }
    
    updateSlots() {
        for (let i = 0; i < CONFIG.MAX_WEAPONS; i++) {
            const slot = document.getElementById(`ws${i}`);
            if (this.player.weapons[i]) { const w = this.player.weapons[i]; slot.innerHTML = `<span style="font-size:1.1rem">${WEAPONS[w.id].icon}</span><span class="slot-level">${w.level}</span>`; slot.style.borderColor = w.upgrades.length > 0 ? w.upgrades[w.upgrades.length - 1].rarity.color : '#444'; }
            else slot.innerHTML = '';
        }
        for (let i = 0; i < CONFIG.MAX_BOOKS; i++) {
            const slot = document.getElementById(`bs${i}`);
            if (this.player.books[i]) { const b = this.player.books[i]; slot.innerHTML = `<span style="font-size:1.1rem">${BOOKS[b.id].icon}</span><span class="slot-level">${b.level}</span>`; slot.style.borderColor = b.upgrades.length > 0 ? b.upgrades[b.upgrades.length - 1].rarity.color : '#444'; }
            else slot.innerHTML = '';
        }
    }
    
    start() {
        this.audio.init();
        this.state = 'playing';
        document.getElementById('mainMenu').style.display = 'none';
        document.getElementById('hud').style.display = 'flex';
        document.getElementById('equipmentSlots').style.display = 'flex';
        
        this.player = new Player(0, 0, this.charIds[this.charIdx]);
        this.enemies = []; this.boss = null; this.proj = []; this.eProj = []; this.pickups = []; this.items = []; this.texts = []; this.fx = []; this.spriteEffects = [];
        this.particles.list = []; this.particles.stains = [];
        this.time = 0; this.spawnT = 0; this.bossSpawned = false; this.bossWarnShown = false;
        this.setupSlots(); this.updateSlots();
    }
    
    restart() {
        document.getElementById('gameOverScreen').style.display = 'none';
        document.getElementById('mainMenu').style.display = 'flex';
        document.getElementById('hud').style.display = 'none';
        document.getElementById('equipmentSlots').style.display = 'none';
        this.state = 'menu';
        if (this.baghdadUnlocked) { document.getElementById('cityBaghdad').classList.remove('locked'); document.getElementById('cityBaghdad').querySelector('.city-locked').style.display = 'none'; }
    }
    
    pause() {
        if (this.state === 'playing') { this.state = 'paused'; document.getElementById('pauseIndicator').style.display = 'block'; }
        else if (this.state === 'paused') { this.state = 'playing'; document.getElementById('pauseIndicator').style.display = 'none'; }
    }
    
    loop(t) {
        const dt = Math.min((t - this.lastTime) / 1000, 0.07);
        this.lastTime = t;
        if (this.state === 'loading') {
            this.drawLoading();
        } else {
            if (this.state === 'playing') this.update(dt);
            this.draw();
        }
        requestAnimationFrame(t => this.loop(t));
    }
    
    update(dt) {
        this.time += dt;
        
        if (this.time >= CONFIG.BOSS_TIME - 30 && !this.bossWarnShown) {
            this.bossWarnShown = true;
            document.getElementById('bossWarning').style.display = 'block';
            this.audio.bossWarn();
            setTimeout(() => document.getElementById('bossWarning').style.display = 'none', 2500);
        }
        
        if (this.time >= CONFIG.BOSS_TIME && !this.bossSpawned) {
            this.bossSpawned = true;
            const a = Math.random() * Math.PI * 2;
            this.boss = new Boss(this.player.x + Math.cos(a) * 320, this.player.y + Math.sin(a) * 320, this.player.enemyBuff);
        }
        
        if (this.globalSlow > 0) this.globalSlow -= dt;
        this.player.update(dt, this.input, this);
        
        this.cam.x = this.player.x - this.canvas.width / 2;
        this.cam.y = this.player.y - this.canvas.height / 2;
        if (this.shake > 0) { this.shake -= dt; this.cam.x += (Math.random() - 0.5) * 6; this.cam.y += (Math.random() - 0.5) * 6; }
        
        // Spawn enemies
        if (!this.bossSpawned) {
            this.spawnT -= dt;
            const spawnMult = 1 + this.player.curse * 0.35 + this.player.extraEnemySpawn;
            const rate = 1.2 / spawnMult;
            const maxE = Math.floor((55 + this.player.curse * 12) * spawnMult);
            if (this.spawnT <= 0 && this.enemies.length < maxE) { this.spawnEnemy(); this.spawnT = rate / (1 + this.time / 100); }
        }
        
        const eDt = this.globalSlow > 0 ? dt * 0.5 : dt;
        for (const e of this.enemies) {
            e.update(eDt, this.player, this.enemies, this);
            if (Math.hypot(e.x - this.player.x, e.y - this.player.y) < (e.width + this.player.width) / 2) this.player.takeDmg(e.atk, this);
            
            // Aura/orbit/melee dmg
            for (const w of this.player.weapons) {
                const data = WEAPONS[w.id], range = this.player.getRange(w);
                if (data.type === 'orbit' || data.type === 'aura') {
                    if (Math.hypot(e.x - this.player.x, e.y - this.player.y) < range + e.width / 2) {
                        const dps = this.player.getDmg(w) * (data.type === 'aura' ? 0.7 : 1.3);
                        if (e.takeDmg(dps * dt, this)) this.killEnemy(e);
                    }
                } else if (data.type === 'melee') {
                    const dist = Math.hypot(e.x - this.player.x, e.y - this.player.y);
                    const ang = Math.atan2(e.y - this.player.y, e.x - this.player.x);
                    const pAng = this.player.facing > 0 ? 0 : Math.PI;
                    if (dist < range + e.width / 2 && Math.abs(ang - pAng) < Math.PI / 2) {
                        const timer = this.player.wTimers[w.id] || 0, cd = this.player.getCD(w);
                        if (timer > cd * 0.82 && timer < cd * 0.95) { if (e.takeDmg(this.player.getDmg(w), this)) this.killEnemy(e); }
                    }
                }
            }
        }
        this.enemies = this.enemies.filter(e => e.hp > 0);
        
        // Boss
        if (this.boss) {
            this.boss.update(dt, this.player, this);
            if (Math.hypot(this.boss.x - this.player.x, this.boss.y - this.player.y) < (this.boss.width + this.player.width) / 2) this.player.takeDmg(this.boss.atk, this);
            for (const w of this.player.weapons) {
                const data = WEAPONS[w.id];
                if (data.type === 'orbit' || data.type === 'aura') {
                    if (Math.hypot(this.boss.x - this.player.x, this.boss.y - this.player.y) < this.player.getRange(w) + this.boss.width / 2)
                        this.boss.takeDmg(this.player.getDmg(w) * dt, this);
                }
            }
            if (this.boss.hp <= 0) this.over(true);
        }
        
        // Projectiles
        for (let i = this.proj.length - 1; i >= 0; i--) {
            const p = this.proj[i];
            p.x += p.vx * dt; p.y += p.vy * dt; p.life -= dt;
            if (p.life <= 0) { this.proj.splice(i, 1); continue; }
            for (const e of this.enemies) {
                if (Math.hypot(p.x - e.x, p.y - e.y) < p.size + e.width / 2) {
                    if (e.takeDmg(p.dmg, this)) this.killEnemy(e);
                    p.pierce = (p.pierce || 1) - 1;
                    if (p.pierce <= 0) this.proj.splice(i, 1);
                    break;
                }
            }
            if (this.boss && Math.hypot(p.x - this.boss.x, p.y - this.boss.y) < p.size + this.boss.width / 2) { this.boss.takeDmg(p.dmg, this); this.proj.splice(i, 1); }
        }
        
        // Enemy projectiles
        for (let i = this.eProj.length - 1; i >= 0; i--) {
            const p = this.eProj[i];
            p.x += p.vx * dt; p.y += p.vy * dt; p.life -= dt;
            if (p.life <= 0) { this.eProj.splice(i, 1); continue; }
            if (Math.hypot(p.x - this.player.x, p.y - this.player.y) < p.size + this.player.width / 2) { this.player.takeDmg(p.dmg, this); this.eProj.splice(i, 1); }
        }
        
        // Effects
        for (let i = this.fx.length - 1; i >= 0; i--) {
            const f = this.fx[i];
            if (f.type === 'lightning') { f.life -= dt; if (f.life <= 0) this.fx.splice(i, 1); }
            else if (f.type === 'meteor') {
                if (f.delay > 0) { f.delay -= dt; continue; }
                f.life -= dt;
                if (f.life <= 0.35 && !f.hit) { f.hit = true; this.particles.emit(f.x, f.y, 10, { color: '#ff4500', minS: 50, maxS: 140 }); for (const e of this.enemies) { if (Math.hypot(f.x - e.x, f.y - e.y) < f.radius) { if (e.takeDmg(f.dmg, this)) this.killEnemy(e); } } }
                if (f.life <= 0) this.fx.splice(i, 1);
            }
            else if (f.type === 'tornado') {
                f.x += f.vx * dt; f.y += f.vy * dt; f.life -= dt;
                for (const e of this.enemies) { if (Math.hypot(f.x - e.x, f.y - e.y) < f.radius + e.width / 2) { e.takeDmg(f.dmg * dt, this); e.slow = f.slow; e.slowT = 0.35; } }
                if (f.life <= 0) this.fx.splice(i, 1);
            }
        }
        
        // Pickups
        for (let i = this.pickups.length - 1; i >= 0; i--) {
            const p = this.pickups[i];
            p.update(dt);
            const d = Math.hypot(p.x - this.player.x, p.y - this.player.y);
            if (d < this.player.pickupRange * 1.8) { const a = Math.atan2(this.player.y - p.y, this.player.x - p.x); const s = 200 * (1 - d / (this.player.pickupRange * 1.8)); p.x += Math.cos(a) * s * dt; p.y += Math.sin(a) * s * dt; }
            if (d < this.player.pickupRange) {
                if (p.type === 'xp') { this.player.xp += p.val * this.player.xpMult * (1 + this.player.curse * 0.4); this.audio.pickup(); this.checkLevelUp(); }
                else { this.player.gold += Math.round(p.val * this.player.goldMult); this.audio.pickup(); }
                this.pickups.splice(i, 1);
            }
        }
        
        // Item drops
        for (let i = this.items.length - 1; i >= 0; i--) {
            const item = this.items[i];
            item.update(dt);
            if (Math.hypot(item.x - this.player.x, item.y - this.player.y) < 22) {
                this.showItemPickup(item);
                this.items.splice(i, 1);
            }
        }
        
        this.texts = this.texts.filter(t => { t.update(dt); return t.life > 0; });
        this.particles.update(dt);
        
        // Update sprite effects
        this.spriteEffects = this.spriteEffects.filter(e => { e.update(dt); return !e.done; });
        
        this.updateHUD();
        this.updateSlots();
    }
    
    spawnEnemy() {
        const a = Math.random() * Math.PI * 2, d = 420 + Math.random() * 70;
        const x = this.player.x + Math.cos(a) * d, y = this.player.y + Math.sin(a) * d;
        const avail = Object.entries(ENEMIES).filter(([, e]) => this.time >= e.time);
        const weights = avail.map((_, i) => Math.pow(1.7, i)), total = weights.reduce((s, w) => s + w, 0);
        let r = Math.random() * total, type = avail[0][0];
        for (let i = 0; i < weights.length; i++) { r -= weights[i]; if (r <= 0) { type = avail[i][0]; break; } }
        this.enemies.push(new Enemy(x, y, type, this.time, this.player.enemyBuff));
        if (ENEMIES[type].pack) for (let i = 0; i < 2; i++) this.enemies.push(new Enemy(x + (Math.random() - 0.5) * 35, y + (Math.random() - 0.5) * 35, type, this.time, this.player.enemyBuff));
    }
    
    killEnemy(enemy) {
        this.player.kills++;
        this.audio.pickup();
        this.particles.blood(enemy.x, enemy.y);
        
        // Add death effect
        this.spriteEffects.push(new SpriteEffect(enemy.x, enemy.y, 'fx_explosion', 32, 32, 7, 0.4, 1.5));
        
        this.pickups.push(new Pickup(enemy.x, enemy.y, 'xp', enemy.xp));
        if (Math.random() < 0.18) this.pickups.push(new Pickup(enemy.x + (Math.random() - 0.5) * 12, enemy.y + (Math.random() - 0.5) * 12, 'gold', 1 + Math.floor(this.time / 55)));
        if (Math.random() < 0.012 * this.player.luck) this.dropItem(enemy.x, enemy.y);
    }
    
    dropItem(x, y) {
        const r = Math.random() * 100 / this.player.luck;
        let rarity = r < 5 ? 'LEGENDARY' : r < 16 ? 'RARE' : 'COMMON';
        const pool = Object.entries(ITEMS).filter(([, i]) => i.rarity === rarity);
        if (pool.length > 0) { const [id] = pool[Math.floor(Math.random() * pool.length)]; this.items.push(new ItemDrop(x, y, id)); }
    }
    
    showItemPickup(drop) {
        this.state = 'itemPickup';
        this.pendingItem = drop;
        const item = ITEMS[drop.id];
        const rar = RARITY[item.rarity];
        
        document.getElementById('itemIcon').textContent = item.icon;
        document.getElementById('itemName').textContent = item.name;
        document.getElementById('itemName').style.color = rar.color;
        document.getElementById('itemRarity').textContent = rar.name;
        document.getElementById('itemRarity').style.background = rar.color + '30';
        document.getElementById('itemRarity').style.color = rar.color;
        document.getElementById('itemDesc').textContent = item.desc;
        
        document.getElementById('itemPickupModal').style.display = 'flex';
        this.audio.itemDrop();
    }
    
    continueFromItem() {
        document.getElementById('itemPickupModal').style.display = 'none';
        if (this.pendingItem) {
            this.collectItem(this.pendingItem);
            this.pendingItem = null;
        }
        this.state = 'playing';
    }
    
    collectItem(drop) {
        const item = ITEMS[drop.id];
        switch (item.effect) {
            case 'heal': 
                this.player.hp = Math.min(this.player.maxHp, this.player.hp + item.val); 
                this.texts.push(new FloatText(this.player.x, this.player.y - 18, `+${item.val} HP`, '#0f0')); 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_heal', 24, 24, 6, 0.5, 2));
                break;
            case 'fullHeal': 
                this.player.maxHp += item.val; 
                this.player.hp = this.player.maxHp; 
                this.texts.push(new FloatText(this.player.x, this.player.y - 18, 'ÿ¥ŸÅÿßÿ° ŸÉÿßŸÖŸÑ!', '#0f0', 16)); 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_heal', 24, 24, 6, 0.6, 2.5));
                break;
            case 'gold': 
                this.player.gold += Math.round(item.val * this.player.goldMult); 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_spark', 24, 24, 5, 0.3, 1.5));
                break;
            case 'tempSpeed': 
                this.player.tempBuffs.push({ type: 'speed', val: item.val, dur: item.dur }); 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_magic', 24, 24, 5, 0.4, 1.8));
                break;
            case 'tempDmg': 
                this.player.tempBuffs.push({ type: 'dmg', val: item.val, dur: item.dur }); 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_fire_small', 24, 24, 6, 0.4, 1.8));
                break;
            case 'tempAtkSpd': 
                this.player.tempBuffs.push({ type: 'atkSpd', val: item.val, dur: item.dur }); 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_spark', 24, 24, 5, 0.4, 1.8));
                break;
            case 'shield': 
                this.player.shield += item.val; 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_circle', 24, 24, 5, 0.5, 2));
                break;
            case 'slow': 
                this.globalSlow = item.dur; 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_ice', 24, 24, 5, 0.5, 2));
                break;
            case 'revive': 
                this.player.hasRevive = true; 
                this.texts.push(new FloatText(this.player.x, this.player.y - 18, 'ÿ•ÿ≠Ÿäÿßÿ° ŸÖÿ≠ŸÅŸàÿ∏!', '#ffd700')); 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_magic', 24, 24, 5, 0.6, 2.5));
                break;
            case 'permGold': 
                this.player.goldMult += item.val; 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_spark', 24, 24, 5, 0.4, 2));
                break;
            case 'randomEquip': 
                this.giveRandomEquip(); 
                this.spriteEffects.push(new SpriteEffect(this.player.x, this.player.y, 'fx_magic', 24, 24, 5, 0.5, 2.5));
                break;
            case 'moreEnemies': 
                this.player.extraEnemySpawn += item.val; 
                this.texts.push(new FloatText(this.player.x, this.player.y - 18, 'ÿ£ÿπÿØÿßÿ° ÿ£ŸÉÿ´ÿ±!', '#f44')); 
                break;
        }
    }
    
    giveRandomEquip() {
        if (Math.random() < 0.5 && this.player.weapons.length < CONFIG.MAX_WEAPONS) {
            const avail = Object.keys(WEAPONS).filter(w => !this.player.weapons.find(pw => pw.id === w));
            if (avail.length > 0) { const id = avail[Math.floor(Math.random() * avail.length)]; this.player.weapons.push({ id, level: 1, upgrades: [] }); this.texts.push(new FloatText(this.player.x, this.player.y - 30, `${WEAPONS[id].name}!`, '#ffd700', 16)); }
        } else if (this.player.books.length < CONFIG.MAX_BOOKS) {
            const avail = Object.keys(BOOKS).filter(b => !this.player.books.find(pb => pb.id === b));
            if (avail.length > 0) { const id = avail[Math.floor(Math.random() * avail.length)]; this.player.books.push({ id, level: 1, upgrades: [] }); this.applyBook(id, 1, RARITY.COMMON); this.texts.push(new FloatText(this.player.x, this.player.y - 30, `${BOOKS[id].name}!`, '#ffd700', 16)); }
        }
    }
    
    checkLevelUp() {
        const req = Math.floor(10 * Math.pow(1.35, this.player.level - 1));
        if (this.player.xp >= req) { this.player.xp -= req; this.player.level++; this.player.hp = Math.min(this.player.maxHp, this.player.hp + this.player.maxHp * 0.12); this.audio.levelUp(); this.showLevelUp(); }
    }
    
    showLevelUp() {
        this.state = 'levelup';
        const modal = document.getElementById('levelUpModal'), opts = document.getElementById('upgradeOptions');
        const choices = [];
        const aw = []; for (const w of this.player.weapons) { if (w.level < CONFIG.MAX_UPGRADE_LEVEL) aw.push({ type: 'weapon', id: w.id, isNew: false }); }
        if (this.player.weapons.length < CONFIG.MAX_WEAPONS) Object.keys(WEAPONS).filter(w => !this.player.weapons.find(pw => pw.id === w)).forEach(w => aw.push({ type: 'weapon', id: w, isNew: true }));
        const ab = []; for (const b of this.player.books) { if (b.level < CONFIG.MAX_UPGRADE_LEVEL) ab.push({ type: 'book', id: b.id, isNew: false }); }
        if (this.player.books.length < CONFIG.MAX_BOOKS) Object.keys(BOOKS).filter(b => !this.player.books.find(pb => pb.id === b)).forEach(b => ab.push({ type: 'book', id: b, isNew: true }));
        const all = [...aw, ...ab];
        while (choices.length < 3 && all.length > 0) choices.push(all.splice(Math.floor(Math.random() * all.length), 1)[0]);
        opts.innerHTML = '';
        choices.forEach(c => {
            const rar = getRandomRarity();
            const card = document.createElement('div');
            card.className = 'upgrade-card';
            card.style.borderColor = rar.color;
            card.style.boxShadow = `0 0 12px ${rar.color}35`;
            const data = c.type === 'weapon' ? WEAPONS[c.id] : BOOKS[c.id];
            const lvl = c.isNew ? 0 : (c.type === 'weapon' ? this.player.weapons : this.player.books).find(x => x.id === c.id).level;
            card.innerHTML = `<div class="upgrade-icon">${data.icon}</div><div class="upgrade-name" style="color:${rar.color}">${data.name}</div><div class="upgrade-type">${c.type === 'weapon' ? 'ÿ≥ŸÑÿßÿ≠' : 'ŸÉÿ™ÿßÿ®'}</div><div class="upgrade-level">${c.isNew ? 'ÿ¨ÿØŸäÿØ!' : `${lvl} ‚Üí ${lvl + 1}`}</div><div class="upgrade-desc">${data.desc}</div><div class="upgrade-rarity" style="background:${rar.color}20;color:${rar.color}">${rar.name} (+${rar.bonus})</div>`;
            card.onclick = () => { this.selectUpgrade(c, rar); modal.style.display = 'none'; this.state = 'playing'; };
            opts.appendChild(card);
        });
        modal.style.display = 'flex';
    }
    
    selectUpgrade(c, rar) {
        if (c.type === 'weapon') {
            if (c.isNew) this.player.weapons.push({ id: c.id, level: 1, upgrades: [{ rarity: rar }] });
            else { const w = this.player.weapons.find(x => x.id === c.id); w.level++; w.upgrades.push({ rarity: rar }); }
        } else {
            if (c.isNew) { this.player.books.push({ id: c.id, level: 1, upgrades: [{ rarity: rar }] }); this.applyBook(c.id, 1, rar); }
            else { const b = this.player.books.find(x => x.id === c.id); b.level++; b.upgrades.push({ rarity: rar }); this.applyBook(c.id, b.level, rar); }
        }
        this.updateSlots();
    }
    
    applyBook(id, level, rar) {
        const book = BOOKS[id], v = book.val * (1 + rar.bonus * 0.12);
        switch (book.stat) {
            case 'damage': this.player.dmgMult += v; break;
            case 'atkSpd': this.player.atkSpd += v; break;
            case 'moveSpd': this.player.speed += this.player.speed * v; break;
            case 'xp': this.player.xpMult += v; break;
            case 'maxHp': const inc = this.player.maxHp * v; this.player.maxHp += inc; this.player.hp += inc; break;
            case 'armor': this.player.armor += v * 6; break;
            case 'pickup': this.player.pickupRange += this.player.pickupRange * v; break;
            case 'luck': this.player.luck += v; break;
            case 'curse': this.player.curse += v; break;
            case 'regen': this.player.regen += v; break;
        }
    }
    
    over(victory) {
        this.state = 'gameover';
        document.getElementById('hud').style.display = 'none';
        document.getElementById('equipmentSlots').style.display = 'none';
        const title = document.getElementById('gameOverTitle'), unlock = document.getElementById('unlockMessage');
        if (victory) { this.audio.victory(); title.textContent = 'üéâ ÿßŸÜÿ™ÿµÿßÿ±! üéâ'; title.className = 'game-over-title victory-title'; if (!this.baghdadUnlocked) { this.baghdadUnlocked = true; localStorage.setItem('baghdadUnlocked', 'true'); unlock.textContent = 'üîì ÿ™ŸÖ ŸÅÿ™ÿ≠ ÿÆÿ±Ÿäÿ∑ÿ© ÿ®ÿ∫ÿØÿßÿØ!'; unlock.style.display = 'block'; } else unlock.style.display = 'none'; }
        else { this.audio.death(); title.textContent = 'ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑŸÑÿπÿ®ÿ©'; title.className = 'game-over-title'; unlock.style.display = 'none'; }
        if (this.player.kills > this.highScore) { this.highScore = this.player.kills; localStorage.setItem('goldBloodHighScore', this.highScore.toString()); document.getElementById('highScore').textContent = this.highScore; }
        const m = Math.floor(this.time / 60), s = Math.floor(this.time % 60);
        document.getElementById('finalStats').innerHTML = `<p>‚è±Ô∏è ${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}</p><p>‚≠ê ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ: ${this.player.level}</p><p>üíÄ ÿßŸÑŸÇÿ™ŸÑŸâ: ${this.player.kills}</p><p>üí∞ ÿßŸÑÿ∞Ÿáÿ®: ${this.player.gold}</p>`;
        document.getElementById('gameOverScreen').style.display = 'flex';
    }
    
    updateHUD() {
        document.getElementById('healthBar').style.width = `${(this.player.hp / this.player.maxHp) * 100}%`;
        document.getElementById('healthText').textContent = `${Math.ceil(this.player.hp)}/${Math.ceil(this.player.maxHp)}`;
        const req = Math.floor(10 * Math.pow(1.35, this.player.level - 1));
        document.getElementById('xpBar').style.width = `${(this.player.xp / req) * 100}%`;
        document.getElementById('xpText').textContent = `${Math.floor(this.player.xp)}/${req}`;
        document.getElementById('levelText').textContent = `ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ: ${this.player.level}`;
        document.getElementById('goldText').textContent = this.player.gold;
        document.getElementById('killText').textContent = this.player.kills;
        const m = Math.floor(this.time / 60), s = Math.floor(this.time % 60);
        document.getElementById('timerText').textContent = `‚è±Ô∏è ${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    }
    
    draw() {
        const ctx = this.ctx;
        ctx.fillStyle = this.city === 'baghdad' ? '#7a9a7a' : '#d4b896';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        if (this.state === 'menu') { this.drawMenuBg(); return; }
        if (['playing', 'paused', 'levelup', 'itemPickup', 'gameover'].includes(this.state)) this.drawGame();
    }
    
    drawMenuBg() {
        const ctx = this.ctx, t = Date.now() / 1000;
        for (let i = 0; i < 4; i++) { const y = this.canvas.height * 0.45 + i * 60; ctx.fillStyle = `rgba(${45 + i * 7}, ${35 + i * 4}, ${22 + i * 3}, 0.35)`; ctx.beginPath(); ctx.moveTo(0, y); for (let x = 0; x <= this.canvas.width; x += 35) ctx.lineTo(x, y + Math.sin(x * 0.007 + t + i) * 12); ctx.lineTo(this.canvas.width, this.canvas.height); ctx.lineTo(0, this.canvas.height); ctx.fill(); }
    }
    
    drawGame() {
        const ctx = this.ctx;
        this.drawBg();
        this.particles.draw(ctx, this.cam);
        for (const p of this.pickups) p.draw(ctx, this.cam, this.assets);
        for (const i of this.items) i.draw(ctx, this.cam);
        
        // Draw effects
        for (const f of this.fx) {
            const sx = f.x - this.cam.x, sy = f.y - this.cam.y;
            if (f.type === 'lightning') { 
                ctx.strokeStyle = `rgba(255, 255, 100, ${f.life / 0.2})`; 
                ctx.lineWidth = 3; 
                ctx.beginPath(); 
                ctx.moveTo(sx, sy - 350); 
                // Zigzag lightning
                for (let i = 0; i < 10; i++) {
                    ctx.lineTo(sx + (Math.random() - 0.5) * 30, sy - 350 + i * 35);
                }
                ctx.lineTo(sx, sy); 
                ctx.stroke(); 
                ctx.fillStyle = `rgba(255, 255, 160, ${f.life / 0.2 * 0.4})`; 
                ctx.beginPath(); 
                ctx.arc(sx, sy, 25, 0, Math.PI * 2); 
                ctx.fill(); 
            }
            else if (f.type === 'meteor' && f.delay <= 0) { 
                if (f.life > 0.35) { 
                    ctx.strokeStyle = 'rgba(255, 70, 0, 0.4)'; 
                    ctx.lineWidth = 2; 
                    ctx.beginPath(); 
                    ctx.arc(sx, sy, f.radius, 0, Math.PI * 2); 
                    ctx.stroke(); 
                    // Incoming meteor visual
                    ctx.fillStyle = 'rgba(255, 100, 0, 0.6)';
                    ctx.beginPath();
                    ctx.arc(sx, sy - (f.life - 0.35) * 200, 12, 0, Math.PI * 2);
                    ctx.fill();
                } else { 
                    ctx.fillStyle = 'rgba(255, 70, 0, 0.3)'; 
                    ctx.beginPath(); 
                    ctx.arc(sx, sy, f.radius * (1 - f.life / 0.35), 0, Math.PI * 2); 
                    ctx.fill(); 
                } 
            }
            else if (f.type === 'tornado') { 
                ctx.strokeStyle = 'rgba(160, 140, 110, 0.5)'; 
                ctx.lineWidth = 2; 
                for (let i = 0; i < 3; i++) { 
                    ctx.beginPath(); 
                    ctx.arc(sx, sy, f.radius - i * 8, 0, Math.PI * 2); 
                    ctx.stroke(); 
                } 
            }
        }
        
        // Draw enemies with sprites
        for (const e of this.enemies) e.draw(ctx, this.cam, this.assets);
        if (this.boss) this.boss.draw(ctx, this.cam, this.assets);
        
        // Draw player with sprite
        this.player.draw(ctx, this.cam, this.assets);
        
        // Draw projectiles with better visuals
        for (const p of this.proj) { 
            const px = p.x - this.cam.x, py = p.y - this.cam.y;
            
            if (p.type === 'fire') {
                // Fire projectile with glow (no shadow for performance)
                ctx.fillStyle = '#ff4500';
                ctx.beginPath();
                ctx.arc(px, py, p.size + 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ff6600';
                ctx.beginPath();
                ctx.arc(px, py, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ffcc00';
                ctx.beginPath();
                ctx.arc(px, py, p.size * 0.5, 0, Math.PI * 2);
                ctx.fill();
            } else {
                ctx.fillStyle = p.color; 
                ctx.beginPath(); 
                ctx.arc(px, py, p.size, 0, Math.PI * 2); 
                ctx.fill();
            }
            
            // Trail effect
            ctx.globalAlpha = 0.35;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(px - p.vx * 0.015, py - p.vy * 0.015, p.size * 0.65, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 0.2;
            ctx.beginPath();
            ctx.arc(px - p.vx * 0.03, py - p.vy * 0.03, p.size * 0.4, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
        for (const p of this.eProj) { 
            ctx.fillStyle = p.color; 
            ctx.beginPath(); 
            ctx.arc(p.x - this.cam.x, p.y - this.cam.y, p.size, 0, Math.PI * 2); 
            ctx.fill(); 
        }
        for (const t of this.texts) t.draw(ctx, this.cam);
        
        // Draw sprite effects
        for (const e of this.spriteEffects) e.draw(ctx, this.cam, this.assets);
        
        this.drawLighting();
        
        // Virtual joystick for mobile
        if (this.input.joy) { 
            ctx.fillStyle = 'rgba(255, 255, 255, 0.12)'; 
            ctx.beginPath(); 
            ctx.arc(80, this.canvas.height - 80, 55, 0, Math.PI * 2); 
            ctx.fill(); 
            ctx.fillStyle = 'rgba(255, 215, 0, 0.35)'; 
            ctx.beginPath(); 
            ctx.arc(80 + this.input.joy.x * 35, this.canvas.height - 80 + this.input.joy.y * 35, 20, 0, Math.PI * 2); 
            ctx.fill(); 
        }
        
        // Boss health bar
        if (this.boss) {
            const bw = Math.min(350, this.canvas.width * 0.8), bx = (this.canvas.width - bw) / 2;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; 
            ctx.fillRect(bx - 3, 44, bw + 6, 26);
            ctx.fillStyle = '#222'; 
            ctx.fillRect(bx, 47, bw, 20);
            const hpColor = this.boss.phase === 3 ? '#ff0000' : this.boss.phase === 2 ? '#ff6600' : '#ffcc00';
            ctx.fillStyle = hpColor;
            ctx.fillRect(bx, 47, bw * (this.boss.hp / this.boss.maxHp), 20);
            ctx.fillStyle = '#fff'; 
            ctx.font = 'bold 12px Cairo'; 
            ctx.textAlign = 'center';
            ctx.fillText(`üëπ ${BOSS.name} - ÿßŸÑŸÖÿ±ÿ≠ŸÑÿ© ${this.boss.phase}`, this.canvas.width / 2, 42);
        }
    }
    
    drawBg() {
        const ctx = this.ctx, ts = CONFIG.TILE_SIZE;
        const sandTile = this.assets.get('sand_tile');
        
        // If we have the sand tile, use it as a repeating pattern
        if (sandTile && this.city === 'badaya') {
            ctx.save();
            ctx.translate(-this.cam.x % ts, -this.cam.y % ts);
            
            if (!this.sandTilePattern) {
                this.sandTilePattern = ctx.createPattern(sandTile, 'repeat');
            }
            
            if (this.sandTilePattern) {
                ctx.fillStyle = this.sandTilePattern;
                ctx.fillRect(0, 0, this.canvas.width + ts * 2, this.canvas.height + ts * 2);
            }
            ctx.restore();
            
            // Add some decorations on top
            const sx = Math.floor(this.cam.x / ts) - 1, sy = Math.floor(this.cam.y / ts) - 1;
            const ex = Math.ceil((this.cam.x + this.canvas.width) / ts) + 1, ey = Math.ceil((this.cam.y + this.canvas.height) / ts) + 1;
            
            for (let y = sy; y <= ey; y++) {
                for (let x = sx; x <= ex; x++) {
                    const px = x * ts - this.cam.x, py = y * ts - this.cam.y;
                    const seed = Math.abs(Math.sin(x * 12.9898 + y * 78.233) * 43758.5453) % 1;
                    
                    // Rocks
                    if (seed < 0.008) { 
                        ctx.fillStyle = '#6a6050'; 
                        ctx.beginPath(); 
                        ctx.arc(px + ts / 2, py + ts / 2, 5 + seed * 8, 0, Math.PI * 2); 
                        ctx.fill(); 
                    }
                    // Palm trees
                    else if (seed < 0.018) { 
                        // Trunk
                        ctx.fillStyle = '#5a3520'; 
                        ctx.fillRect(px + ts / 2 - 3, py + ts / 2 - 16, 6, 20); 
                        // Leaves
                        ctx.fillStyle = '#3a6a28'; 
                        for (let i = 0; i < 5; i++) { 
                            ctx.beginPath(); 
                            ctx.ellipse(px + ts / 2 + Math.cos(i * 1.3) * 12, py + ts / 2 - 18 + Math.sin(i * 1.3) * 6, 10, 4, i * 0.8, 0, Math.PI * 2); 
                            ctx.fill(); 
                        } 
                    }
                    // Small bushes
                    else if (seed < 0.028) {
                        ctx.fillStyle = '#5a7a48';
                        ctx.beginPath();
                        ctx.arc(px + ts / 2, py + ts / 2, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        } else {
            // Fallback for no tile or Baghdad
            const sx = Math.floor(this.cam.x / ts) - 1, sy = Math.floor(this.cam.y / ts) - 1;
            const ex = Math.ceil((this.cam.x + this.canvas.width) / ts) + 1, ey = Math.ceil((this.cam.y + this.canvas.height) / ts) + 1;
            
            for (let y = sy; y <= ey; y++) {
                for (let x = sx; x <= ex; x++) {
                    const px = x * ts - this.cam.x, py = y * ts - this.cam.y;
                    const n = Math.sin(x * 0.35) * Math.cos(y * 0.35) * 0.07;
                    let r = 210, g = 180, b = 140;
                    if (this.city === 'baghdad') { r = 130; g = 170; b = 130; }
                    ctx.fillStyle = `rgb(${Math.floor(r + n * 22)}, ${Math.floor(g + n * 18)}, ${Math.floor(b + n * 12)})`;
                    ctx.fillRect(px, py, ts + 1, ts + 1);
                    
                    const seed = Math.abs(Math.sin(x * 12.9898 + y * 78.233) * 43758.5453) % 1;
                    if (seed < 0.012) { 
                        ctx.fillStyle = '#555'; 
                        ctx.beginPath(); 
                        ctx.arc(px + ts / 2, py + ts / 2, 4 + seed * 5, 0, Math.PI * 2); 
                        ctx.fill(); 
                    }
                    else if (this.city === 'badaya' && seed < 0.022) { 
                        ctx.fillStyle = '#3a2518'; 
                        ctx.fillRect(px + ts / 2 - 2, py + ts / 2 - 12, 4, 16); 
                        ctx.fillStyle = '#2a4a18'; 
                        for (let i = 0; i < 4; i++) { 
                            ctx.beginPath(); 
                            ctx.ellipse(px + ts / 2 + Math.cos(i * 1.4) * 9, py + ts / 2 - 14 + Math.sin(i * 1.4) * 4, 7, 3, i * 0.7, 0, Math.PI * 2); 
                            ctx.fill(); 
                        } 
                    }
                    else if (this.city === 'baghdad' && seed < 0.035) { 
                        ctx.fillStyle = '#3a5a30'; 
                        for (let i = 0; i < 3; i++) ctx.fillRect(px + ts / 3 + i * 7, py + ts / 2, 1.5, 6); 
                    }
                }
            }
        }
    }
    
    drawLighting() {
        // Subtle vignette effect only - no heavy darkness
        const ctx = this.ctx;
        const cx = this.canvas.width / 2, cy = this.canvas.height / 2;
        const maxDist = Math.max(this.canvas.width, this.canvas.height) * 0.7;
        
        // Very subtle edge darkening (vignette)
        const vignette = ctx.createRadialGradient(cx, cy, maxDist * 0.5, cx, cy, maxDist);
        vignette.addColorStop(0, 'rgba(0, 0, 0, 0)');
        vignette.addColorStop(1, 'rgba(0, 0, 0, 0.15)');
        ctx.fillStyle = vignette;
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Warm tint overlay
        ctx.fillStyle = 'rgba(255, 200, 100, 0.02)';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }
}

window.addEventListener('load', () => new Game());
    </script>
</body>
</html>
