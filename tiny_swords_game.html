<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>‚öîÔ∏è Tiny Swords ‚öîÔ∏è</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }
        html, body { width: 100%; height: 100%; overflow: hidden; background: #000; }
        #gameCanvas { 
            display: block; 
            width: 100%; 
            height: 100%;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        #loadingScreen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(180deg, #2a4a2a 0%, #1a3a1a 100%);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 1000; color: #fff; font-family: sans-serif;
        }
        .loading-text { font-size: 24px; margin-bottom: 20px; }
        .loading-bar-bg { width: 300px; height: 40px; background: #1a2a1a; border: 4px solid #4a6a4a; }
        .loading-bar-fill { height: 100%; background: linear-gradient(90deg, #6a9a6a, #8aba8a); width: 0%; transition: width 0.2s; }
        .loading-pct { margin-top: 10px; font-size: 18px; }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <div class="loading-text">‚öîÔ∏è Tiny Swords ‚öîÔ∏è</div>
        <div class="loading-bar-bg"><div class="loading-bar-fill" id="loadFill"></div></div>
        <div class="loading-pct" id="loadPct">0%</div>
    </div>
    <canvas id="gameCanvas"></canvas>

<script>
// ===================== TINY SWORDS - COMPLETE REWRITE =====================
const BASE = 'assets/Tiny Swords Free Pack/Tiny Swords (Free Pack)/';
const ENEMY_BASE = 'assets/New enemy/Tiny Swords Enemy Pack/Tiny Swords (Enemy Pack)/Enemy Pack/';

// ===================== ASSET LOADER =====================
class Assets {
    constructor() {
        this.images = {};
        this.loaded = 0;
        this.total = 0;
    }
    
    load(key, path) {
        this.total++;
        return new Promise(resolve => {
            const img = new Image();
            img.onload = () => { this.images[key] = img; this.loaded++; this.updateUI(); resolve(img); };
            img.onerror = () => { console.warn('Failed:', path); this.loaded++; this.updateUI(); resolve(null); };
            img.src = path;
        });
    }
    
    updateUI() {
        const pct = Math.floor((this.loaded / this.total) * 100);
        document.getElementById('loadFill').style.width = pct + '%';
        document.getElementById('loadPct').textContent = pct + '%';
    }
    
    get(key) { return this.images[key]; }
    
    async loadAll() {
        const P = [];
        
        // Terrain
        P.push(this.load('tilemap1', BASE + 'Terrain/Tileset/Tilemap_color1.png'));
        P.push(this.load('tilemap2', BASE + 'Terrain/Tileset/Tilemap_color2.png'));
        P.push(this.load('water', BASE + 'Terrain/Tileset/Water Foam.png'));
        P.push(this.load('shadow', BASE + 'Terrain/Tileset/Shadow.png'));
        
        // Trees, Bushes, Rocks
        for (let i = 1; i <= 4; i++) {
            P.push(this.load('tree' + i, BASE + 'Terrain/Resources/Wood/Trees/Tree' + i + '.png'));
            P.push(this.load('bush' + i, BASE + 'Terrain/Decorations/Bushes/Bushe' + i + '.png'));
            P.push(this.load('rock' + i, BASE + 'Terrain/Decorations/Rocks/Rock' + i + '.png'));
        }
        
        // Buildings
        P.push(this.load('castle', BASE + 'Buildings/Blue Buildings/Castle.png'));
        P.push(this.load('tower', BASE + 'Buildings/Blue Buildings/Tower.png'));
        P.push(this.load('house1', BASE + 'Buildings/Blue Buildings/House1.png'));
        P.push(this.load('house2', BASE + 'Buildings/Blue Buildings/House2.png'));
        
        // Gold & Resources
        P.push(this.load('gold_res', BASE + 'Terrain/Resources/Gold/Gold Resource/Gold_Resource.png'));
        P.push(this.load('meat', BASE + 'Terrain/Resources/Meat/Meat Resource/Meat Resource.png'));
        
        // UI Elements
        P.push(this.load('bar_base', BASE + 'UI Elements/UI Elements/Bars/BigBar_Base.png'));
        P.push(this.load('bar_fill', BASE + 'UI Elements/UI Elements/Bars/BigBar_Fill.png'));
        P.push(this.load('banner', BASE + 'UI Elements/UI Elements/Banners/Banner.png'));
        P.push(this.load('btn_blue', BASE + 'UI Elements/UI Elements/Buttons/BigBlueButton_Regular.png'));
        P.push(this.load('btn_blue_p', BASE + 'UI Elements/UI Elements/Buttons/BigBlueButton_Pressed.png'));
        P.push(this.load('btn_red', BASE + 'UI Elements/UI Elements/Buttons/BigRedButton_Regular.png'));
        P.push(this.load('wood_table', BASE + 'UI Elements/UI Elements/Wood Table/WoodTable.png'));
        P.push(this.load('ribbons', BASE + 'UI Elements/UI Elements/Ribbons/BigRibbons.png'));
        P.push(this.load('swords', BASE + 'UI Elements/UI Elements/Swords/Swords.png'));
        
        // Icons & Avatars
        for (let i = 1; i <= 12; i++) {
            P.push(this.load('icon' + i, BASE + 'UI Elements/UI Elements/Icons/Icon_' + String(i).padStart(2, '0') + '.png'));
        }
        for (let i = 1; i <= 10; i++) {
            P.push(this.load('avatar' + i, BASE + 'UI Elements/UI Elements/Human Avatars/Avatars_' + String(i).padStart(2, '0') + '.png'));
        }
        
        // Particle FX
        P.push(this.load('explosion', BASE + 'Particle FX/Explosion_01.png'));
        P.push(this.load('dust', BASE + 'Particle FX/Dust_01.png'));
        
        // Characters - Warrior
        P.push(this.load('warrior_idle', BASE + 'Units/Blue Units/Warrior/Warrior_Idle.png'));
        P.push(this.load('warrior_run', BASE + 'Units/Blue Units/Warrior/Warrior_Run.png'));
        P.push(this.load('warrior_atk', BASE + 'Units/Blue Units/Warrior/Warrior_Attack1.png'));
        
        // Characters - Archer
        P.push(this.load('archer_idle', BASE + 'Units/Blue Units/Archer/Archer_Idle.png'));
        P.push(this.load('archer_run', BASE + 'Units/Blue Units/Archer/Archer_Run.png'));
        P.push(this.load('archer_atk', BASE + 'Units/Blue Units/Archer/Archer_Shoot.png'));
        P.push(this.load('arrow', BASE + 'Units/Blue Units/Archer/Arrow.png'));
        
        // Characters - Lancer
        P.push(this.load('lancer_idle', BASE + 'Units/Yellow Units/Lancer/Lancer_Idle.png'));
        P.push(this.load('lancer_run', BASE + 'Units/Yellow Units/Lancer/Lancer_Run.png'));
        
        // Characters - Pawn  
        P.push(this.load('pawn_idle', BASE + 'Units/Yellow Units/Pawn/Pawn_Idle.png'));
        P.push(this.load('pawn_run', BASE + 'Units/Yellow Units/Pawn/Pawn_Run.png'));
        
        // Enemies
        const enemies = ['Skull', 'Spider', 'Snake', 'Gnome', 'Lizard', 'Thief', 'Gnoll', 'Bear', 'Panda', 'Troll', 'Minotaur', 'Turtle'];
        for (const e of enemies) {
            const k = e.toLowerCase();
            P.push(this.load(k + '_idle', ENEMY_BASE + e + '/' + e + '_Idle.png'));
            P.push(this.load(k + '_run', ENEMY_BASE + e + '/' + e + '_Run.png'));
            P.push(this.load(k + '_walk', ENEMY_BASE + e + '/' + e + '_Walk.png'));
            P.push(this.load(k + '_atk', ENEMY_BASE + e + '/' + e + '_Attack.png'));
        }
        
        await Promise.all(P);
    }
}

// ===================== 9-SLICE RENDERER =====================
function draw9Slice(ctx, img, x, y, w, h, sliceW, sliceH) {
    if (!img) return;
    const sw = sliceW || img.width / 3;
    const sh = sliceH || img.height / 3;
    const mw = w - sw * 2;
    const mh = h - sh * 2;
    
    // Corners
    ctx.drawImage(img, 0, 0, sw, sh, x, y, sw, sh); // TL
    ctx.drawImage(img, sw * 2, 0, sw, sh, x + w - sw, y, sw, sh); // TR
    ctx.drawImage(img, 0, sh * 2, sw, sh, x, y + h - sh, sw, sh); // BL
    ctx.drawImage(img, sw * 2, sh * 2, sw, sh, x + w - sw, y + h - sh, sw, sh); // BR
    
    // Edges
    ctx.drawImage(img, sw, 0, sw, sh, x + sw, y, mw, sh); // Top
    ctx.drawImage(img, sw, sh * 2, sw, sh, x + sw, y + h - sh, mw, sh); // Bottom
    ctx.drawImage(img, 0, sh, sw, sh, x, y + sh, sw, mh); // Left
    ctx.drawImage(img, sw * 2, sh, sw, sh, x + w - sw, y + sh, sw, mh); // Right
    
    // Center
    ctx.drawImage(img, sw, sh, sw, sh, x + sw, y + sh, mw, mh);
}

// ===================== GAME CLASS =====================
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.assets = new Assets();
        
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        this.state = 'loading';
        this.charIndex = 0;
        this.chars = [
            { key: 'warrior', name: 'ÿßŸÑŸÖÿ≠ÿßÿ±ÿ®', title: 'Warrior', hp: 120, dmg: 12, spd: 200, range: 70, atkSpd: 1.0, avatar: 1, type: 'melee', idleF: 8, runF: 6, atkF: 4 },
            { key: 'archer', name: 'ÿßŸÑÿ±ÿßŸÖŸä', title: 'Archer', hp: 85, dmg: 18, spd: 210, range: 350, atkSpd: 0.7, avatar: 3, type: 'ranged', idleF: 6, runF: 6, atkF: 8 },
            { key: 'lancer', name: 'ÿßŸÑÿ±ŸÖŸëÿßÿ≠', title: 'Lancer', hp: 100, dmg: 14, spd: 220, range: 90, atkSpd: 0.9, avatar: 5, type: 'melee', idleF: 6, runF: 6, atkF: 6 },
            { key: 'pawn', name: 'ÿßŸÑÿπÿßŸÖŸÑ', title: 'Pawn', hp: 90, dmg: 8, spd: 250, range: 50, atkSpd: 1.3, avatar: 7, type: 'melee', idleF: 6, runF: 6, atkF: 4, goldBonus: 0.5 }
        ];
        
        this.player = null;
        this.enemies = [];
        this.projectiles = [];
        this.pickups = [];
        this.effects = [];
        this.dmgNums = [];
        this.decorations = [];
        
        this.camera = { x: 0, y: 0 };
        this.worldSize = 3000;
        
        this.kills = 0;
        this.gold = 0;
        this.gameTime = 0;
        this.level = 1;
        this.xp = 0;
        this.xpNext = 15;
        
        this.spawnTimer = 0;
        this.bossSpawned = false;
        this.boss = null;
        
        this.keys = {};
        this.touch = { active: false, sx: 0, sy: 0, x: 0, y: 0 };
        this.joy = { x: 0, y: 0 };
        this.clickAreas = [];
        
        this.setupInput();
    }
    
    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.ctx.imageSmoothingEnabled = false;
    }
    
    setupInput() {
        window.addEventListener('keydown', e => this.keys[e.code] = true);
        window.addEventListener('keyup', e => this.keys[e.code] = false);
        
        const handleStart = (x, y) => {
            this.touch.active = true;
            this.touch.sx = x;
            this.touch.sy = y;
            
            // Check click areas
            for (const area of this.clickAreas) {
                if (x >= area.x && x <= area.x + area.w && y >= area.y && y <= area.y + area.h) {
                    if (area.onClick) area.onClick();
                    return;
                }
            }
        };
        
        const handleMove = (x, y) => {
            if (this.touch.active && this.state === 'playing') {
                const dx = x - this.touch.sx;
                const dy = y - this.touch.sy;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 20) {
                    this.joy.x = Math.max(-1, Math.min(1, dx / 80));
                    this.joy.y = Math.max(-1, Math.min(1, dy / 80));
                }
            }
        };
        
        const handleEnd = () => {
            this.touch.active = false;
            this.joy.x = 0;
            this.joy.y = 0;
        };
        
        this.canvas.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY));
        this.canvas.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
        this.canvas.addEventListener('mouseup', handleEnd);
        
        this.canvas.addEventListener('touchstart', e => { e.preventDefault(); handleStart(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
        this.canvas.addEventListener('touchmove', e => { e.preventDefault(); handleMove(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
        this.canvas.addEventListener('touchend', e => { e.preventDefault(); handleEnd(); }, { passive: false });
    }
    
    async init() {
        await this.assets.loadAll();
        document.getElementById('loadingScreen').style.display = 'none';
        this.generateWorld();
        this.state = 'menu';
        this.lastTime = performance.now();
        requestAnimationFrame(t => this.loop(t));
    }
    
    generateWorld() {
        this.decorations = [];
        const size = this.worldSize;
        
        // Trees
        for (let i = 0; i < 40; i++) {
            this.decorations.push({
                type: 'tree',
                variant: 1 + (i % 4),
                x: (Math.random() - 0.5) * size * 1.6,
                y: (Math.random() - 0.5) * size * 1.6,
                frame: Math.floor(Math.random() * 6)
            });
        }
        
        // Bushes
        for (let i = 0; i < 60; i++) {
            this.decorations.push({
                type: 'bush',
                variant: 1 + (i % 4),
                x: (Math.random() - 0.5) * size * 1.6,
                y: (Math.random() - 0.5) * size * 1.6,
                frame: Math.floor(Math.random() * 8)
            });
        }
        
        // Rocks
        for (let i = 0; i < 30; i++) {
            this.decorations.push({
                type: 'rock',
                variant: 1 + (i % 4),
                x: (Math.random() - 0.5) * size * 1.6,
                y: (Math.random() - 0.5) * size * 1.6
            });
        }
        
        // Sort by Y
        this.decorations.sort((a, b) => a.y - b.y);
    }
    
    startGame() {
        const c = this.chars[this.charIndex];
        this.player = {
            x: 0, y: 0,
            hp: c.hp, maxHp: c.hp,
            damage: c.dmg,
            speed: c.spd,
            range: c.range,
            attackSpeed: c.atkSpd,
            attackCD: 0,
            char: c,
            frame: 0, frameTime: 0,
            facingRight: true,
            moving: false,
            attacking: false,
            regen: 0, regenTimer: 0,
            crit: 0,
            goldBonus: c.goldBonus || 0
        };
        
        this.enemies = [];
        this.projectiles = [];
        this.pickups = [];
        this.effects = [];
        this.dmgNums = [];
        this.kills = 0;
        this.gold = 0;
        this.gameTime = 0;
        this.level = 1;
        this.xp = 0;
        this.xpNext = 15;
        this.spawnTimer = 0;
        this.bossSpawned = false;
        this.boss = null;
        
        this.state = 'playing';
    }
    
    loop(time) {
        const dt = Math.min((time - this.lastTime) / 1000, 0.1);
        this.lastTime = time;
        
        this.update(dt);
        this.render();
        
        requestAnimationFrame(t => this.loop(t));
    }
    
    update(dt) {
        if (this.state !== 'playing') return;
        
        this.gameTime += dt;
        
        // Player
        this.updatePlayer(dt);
        
        // Enemies
        this.updateEnemies(dt);
        
        // Spawning
        this.spawnTimer += dt;
        const rate = Math.max(0.4, 1.8 - this.gameTime / 200);
        if (this.spawnTimer >= rate && this.enemies.length < 60) {
            this.spawnEnemy();
            this.spawnTimer = 0;
        }
        
        // Projectiles
        this.updateProjectiles(dt);
        
        // Pickups
        this.updatePickups(dt);
        
        // Effects
        this.effects = this.effects.filter(e => {
            e.life -= dt;
            e.frameTime += dt;
            if (e.frameTime >= 0.06) { e.frame++; e.frameTime = 0; }
            return e.life > 0;
        });
        
        // Damage numbers
        this.dmgNums = this.dmgNums.filter(d => {
            d.life -= dt;
            d.y -= 50 * dt;
            return d.life > 0;
        });
        
        // Camera
        this.camera.x = this.player.x - this.canvas.width / 2;
        this.camera.y = this.player.y - this.canvas.height / 2;
        
        // Regen
        if (this.player.regen > 0) {
            this.player.regenTimer += dt;
            if (this.player.regenTimer >= 1) {
                this.player.hp = Math.min(this.player.maxHp, this.player.hp + this.player.regen);
                this.player.regenTimer = 0;
            }
        }
        
        // Boss spawn
        if (this.gameTime >= 540 && !this.bossSpawned) {
            this.spawnBoss();
        }
        
        // Death check
        if (this.player.hp <= 0) {
            this.state = 'gameover';
            this.victory = false;
        }
    }
    
    updatePlayer(dt) {
        let dx = 0, dy = 0;
        
        if (this.keys['KeyW'] || this.keys['ArrowUp']) dy -= 1;
        if (this.keys['KeyS'] || this.keys['ArrowDown']) dy += 1;
        if (this.keys['KeyA'] || this.keys['ArrowLeft']) dx -= 1;
        if (this.keys['KeyD'] || this.keys['ArrowRight']) dx += 1;
        
        if (Math.abs(this.joy.x) > 0.1 || Math.abs(this.joy.y) > 0.1) {
            dx = this.joy.x;
            dy = this.joy.y;
        }
        
        const mag = Math.sqrt(dx * dx + dy * dy);
        if (mag > 0) {
            dx /= mag;
            dy /= mag;
            this.player.moving = true;
            if (dx !== 0) this.player.facingRight = dx > 0;
        } else {
            this.player.moving = false;
        }
        
        this.player.x += dx * this.player.speed * dt;
        this.player.y += dy * this.player.speed * dt;
        
        // Clamp
        const half = this.worldSize / 2;
        this.player.x = Math.max(-half, Math.min(half, this.player.x));
        this.player.y = Math.max(-half, Math.min(half, this.player.y));
        
        // Animation
        this.player.frameTime += dt;
        if (this.player.frameTime >= 0.1) {
            this.player.frame++;
            this.player.frameTime = 0;
        }
        
        // Attack
        this.player.attackCD -= dt;
        if (this.player.attackCD <= 0) {
            const target = this.findNearest();
            if (target) {
                const d = this.dist(this.player, target);
                if (d <= this.player.range) {
                    this.attack(target);
                    this.player.attackCD = 1 / this.player.attackSpeed;
                    this.player.attacking = true;
                    setTimeout(() => this.player.attacking = false, 250);
                }
            }
        }
    }
    
    findNearest() {
        let best = null, bestD = Infinity;
        const all = this.boss ? [...this.enemies, this.boss] : this.enemies;
        for (const e of all) {
            const d = this.dist(this.player, e);
            if (d < bestD) { bestD = d; best = e; }
        }
        return best;
    }
    
    dist(a, b) {
        return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
    }
    
    attack(target) {
        if (this.player.char.type === 'ranged') {
            // Shoot arrow
            const angle = Math.atan2(target.y - this.player.y, target.x - this.player.x);
            this.projectiles.push({
                x: this.player.x,
                y: this.player.y,
                vx: Math.cos(angle) * 500,
                vy: Math.sin(angle) * 500,
                damage: this.player.damage,
                life: 2,
                angle: angle
            });
        } else {
            // Melee
            this.dealDamage(target, this.player.damage);
        }
    }
    
    dealDamage(target, baseDmg) {
        let dmg = baseDmg;
        const crit = Math.random() < this.player.crit;
        if (crit) dmg *= 2;
        
        target.hp -= dmg;
        this.dmgNums.push({
            x: target.x,
            y: target.y - 30,
            text: Math.floor(dmg),
            color: crit ? '#ffff00' : '#ffffff',
            life: 0.8
        });
        
        this.effects.push({
            type: 'hit',
            x: target.x,
            y: target.y,
            frame: 0,
            frameTime: 0,
            life: 0.4
        });
        
        if (target.hp <= 0) {
            this.killEnemy(target);
        }
    }
    
    killEnemy(enemy) {
        if (enemy === this.boss) {
            this.state = 'gameover';
            this.victory = true;
            return;
        }
        
        const idx = this.enemies.indexOf(enemy);
        if (idx !== -1) this.enemies.splice(idx, 1);
        
        this.kills++;
        
        // Gold
        const goldAmt = Math.floor(enemy.type.gold * (1 + this.player.goldBonus));
        this.gold += goldAmt;
        
        // Drop
        if (Math.random() < 0.35) {
            this.pickups.push({
                x: enemy.x + (Math.random() - 0.5) * 20,
                y: enemy.y + (Math.random() - 0.5) * 20,
                type: Math.random() < 0.7 ? 'gold' : 'meat',
                value: Math.random() < 0.5 ? goldAmt : 20
            });
        }
        
        // Explosion
        this.effects.push({
            type: 'explosion',
            x: enemy.x,
            y: enemy.y,
            frame: 0,
            frameTime: 0,
            life: 0.6
        });
        
        // XP
        this.xp += enemy.type.xp;
        if (this.xp >= this.xpNext) {
            this.levelUp();
        }
    }
    
    levelUp() {
        this.xp -= this.xpNext;
        this.level++;
        this.xpNext = Math.floor(15 * Math.pow(1.25, this.level - 1));
        this.state = 'levelup';
        
        this.upgrades = [
            { name: 'ŸÇŸàÿ© ÿßŸÑŸáÿ¨ŸàŸÖ', desc: '+25% ÿ∂ÿ±ÿ±', icon: 1, apply: () => this.player.damage *= 1.25 },
            { name: 'ÿßŸÑÿ≥ÿ±ÿπÿ©', desc: '+15% ÿ≥ÿ±ÿπÿ© ÿ≠ÿ±ŸÉÿ©', icon: 2, apply: () => this.player.speed *= 1.15 },
            { name: 'ÿ≥ÿ±ÿπÿ© ÿßŸÑŸáÿ¨ŸàŸÖ', desc: '+20% ÿ≥ÿ±ÿπÿ© Ÿáÿ¨ŸàŸÖ', icon: 3, apply: () => this.player.attackSpeed *= 1.20 },
            { name: 'ÿßŸÑÿµÿ≠ÿ©', desc: '+30 ÿµÿ≠ÿ© ŸÇÿµŸàŸâ', icon: 4, apply: () => { this.player.maxHp += 30; this.player.hp += 30; } },
            { name: 'ÿßŸÑŸÖÿØŸâ', desc: '+25% ŸÖÿØŸâ', icon: 5, apply: () => this.player.range *= 1.25 },
            { name: 'ÿßŸÑÿ™ÿ¨ÿØŸäÿØ', desc: '+3 ÿ¥ŸÅÿßÿ°/ÿ´', icon: 6, apply: () => this.player.regen += 3 },
            { name: 'ÿßŸÑÿ∂ÿ±ÿ®ÿ© ÿßŸÑÿ≠ÿ±ÿ¨ÿ©', desc: '+10% ŸÉÿ±Ÿäÿ™ŸäŸÉÿßŸÑ', icon: 7, apply: () => this.player.crit += 0.10 },
            { name: 'ÿßŸÑÿ∞Ÿáÿ®', desc: '+30% ÿ∞Ÿáÿ®', icon: 8, apply: () => this.player.goldBonus += 0.30 }
        ].sort(() => Math.random() - 0.5).slice(0, 3);
    }
    
    selectUpgrade(upgrade) {
        upgrade.apply();
        this.state = 'playing';
    }
    
    spawnEnemy() {
        const types = [
            { key: 'skull', hp: 25, dmg: 5, spd: 85, xp: 2, gold: 1, after: 0, size: 48 },
            { key: 'spider', hp: 20, dmg: 4, spd: 100, xp: 2, gold: 1, after: 0, size: 48 },
            { key: 'snake', hp: 30, dmg: 6, spd: 80, xp: 3, gold: 2, after: 60, size: 48 },
            { key: 'gnome', hp: 35, dmg: 7, spd: 75, xp: 3, gold: 2, after: 60, size: 48 },
            { key: 'lizard', hp: 45, dmg: 9, spd: 70, xp: 4, gold: 3, after: 120, size: 52 },
            { key: 'thief', hp: 30, dmg: 12, spd: 110, xp: 5, gold: 5, after: 180, size: 48 },
            { key: 'gnoll', hp: 60, dmg: 10, spd: 65, xp: 6, gold: 4, after: 240, size: 56 },
            { key: 'bear', hp: 100, dmg: 14, spd: 55, xp: 10, gold: 7, after: 300, size: 72 },
            { key: 'panda', hp: 85, dmg: 12, spd: 60, xp: 8, gold: 6, after: 360, size: 64 },
            { key: 'troll', hp: 130, dmg: 16, spd: 50, xp: 12, gold: 9, after: 420, size: 70 },
            { key: 'minotaur', hp: 160, dmg: 18, spd: 55, xp: 18, gold: 14, after: 480, size: 76 }
        ];
        
        const available = types.filter(t => this.gameTime >= t.after);
        const type = available[Math.floor(Math.random() * available.length)];
        
        const angle = Math.random() * Math.PI * 2;
        const dist = 450 + Math.random() * 200;
        const scale = 1 + this.gameTime / 350;
        
        this.enemies.push({
            x: this.player.x + Math.cos(angle) * dist,
            y: this.player.y + Math.sin(angle) * dist,
            hp: type.hp * scale,
            maxHp: type.hp * scale,
            damage: type.dmg * scale,
            speed: type.spd,
            type: type,
            frame: 0,
            frameTime: 0,
            facingRight: true,
            atkCD: 1,
            size: type.size
        });
    }
    
    spawnBoss() {
        this.bossSpawned = true;
        this.enemies = this.enemies.slice(0, 5);
        
        const angle = Math.random() * Math.PI * 2;
        this.boss = {
            x: this.player.x + Math.cos(angle) * 550,
            y: this.player.y + Math.sin(angle) * 550,
            hp: 4000,
            maxHp: 4000,
            damage: 30,
            speed: 65,
            frame: 0,
            frameTime: 0,
            facingRight: true,
            atkCD: 1.5,
            size: 140
        };
    }
    
    updateEnemies(dt) {
        for (const e of this.enemies) {
            const dx = this.player.x - e.x;
            const dy = this.player.y - e.y;
            const d = Math.sqrt(dx * dx + dy * dy);
            
            if (d > 40) {
                e.x += (dx / d) * e.speed * dt;
                e.y += (dy / d) * e.speed * dt;
                e.facingRight = dx > 0;
            }
            
            if (d < 50) {
                e.atkCD -= dt;
                if (e.atkCD <= 0) {
                    this.player.hp -= e.damage;
                    e.atkCD = 1;
                    this.dmgNums.push({
                        x: this.player.x,
                        y: this.player.y - 30,
                        text: Math.floor(e.damage),
                        color: '#ff4444',
                        life: 0.8
                    });
                }
            }
            
            e.frameTime += dt;
            if (e.frameTime >= 0.12) {
                e.frame++;
                e.frameTime = 0;
            }
        }
        
        // Boss
        if (this.boss) {
            const b = this.boss;
            const dx = this.player.x - b.x;
            const dy = this.player.y - b.y;
            const d = Math.sqrt(dx * dx + dy * dy);
            
            if (d > 60) {
                b.x += (dx / d) * b.speed * dt;
                b.y += (dy / d) * b.speed * dt;
                b.facingRight = dx > 0;
            }
            
            if (d < 80) {
                b.atkCD -= dt;
                if (b.atkCD <= 0) {
                    this.player.hp -= b.damage;
                    b.atkCD = 1.5;
                    this.dmgNums.push({
                        x: this.player.x,
                        y: this.player.y - 30,
                        text: Math.floor(b.damage),
                        color: '#ff0000',
                        life: 0.8
                    });
                }
            }
            
            b.frameTime += dt;
            if (b.frameTime >= 0.15) {
                b.frame++;
                b.frameTime = 0;
            }
        }
    }
    
    updateProjectiles(dt) {
        for (let i = this.projectiles.length - 1; i >= 0; i--) {
            const p = this.projectiles[i];
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.life -= dt;
            
            if (p.life <= 0) {
                this.projectiles.splice(i, 1);
                continue;
            }
            
            const all = this.boss ? [...this.enemies, this.boss] : this.enemies;
            for (const e of all) {
                if (this.dist(p, e) < 40) {
                    this.dealDamage(e, p.damage);
                    this.projectiles.splice(i, 1);
                    break;
                }
            }
        }
    }
    
    updatePickups(dt) {
        for (let i = this.pickups.length - 1; i >= 0; i--) {
            const p = this.pickups[i];
            if (this.dist(this.player, p) < 60) {
                if (p.type === 'gold') {
                    this.gold += p.value;
                } else {
                    this.player.hp = Math.min(this.player.maxHp, this.player.hp + p.value);
                }
                this.pickups.splice(i, 1);
            }
        }
    }
    
    // ===================== RENDERING =====================
    render() {
        const ctx = this.ctx;
        ctx.fillStyle = '#3a6a3a';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.clickAreas = [];
        
        if (this.state === 'menu') {
            this.renderMenu();
        } else if (this.state === 'playing' || this.state === 'levelup') {
            this.renderWorld();
            this.renderHUD();
            if (this.state === 'levelup') this.renderLevelUp();
        } else if (this.state === 'gameover') {
            this.renderWorld();
            this.renderGameOver();
        }
    }
    
    renderMenu() {
        const ctx = this.ctx;
        const cx = this.canvas.width / 2;
        const cy = this.canvas.height / 2;
        
        // Background terrain
        this.renderTerrain();
        
        // Darken
        ctx.fillStyle = 'rgba(0,0,0,0.75)';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Main panel (9-slice banner)
        const panelW = Math.min(420, this.canvas.width - 40);
        const panelH = Math.min(520, this.canvas.height - 80);
        const panelX = cx - panelW / 2;
        const panelY = cy - panelH / 2;
        
        draw9Slice(ctx, this.assets.get('banner'), panelX, panelY, panelW, panelH, 149, 149);
        
        // Title ribbon with swords
        const swords = this.assets.get('swords');
        if (swords) {
            // Blue row (row 0)
            const sw = 64, sh = 64;
            const titleW = 280;
            const titleX = cx - titleW / 2;
            const titleY = panelY + 25;
            
            // Left sword
            ctx.drawImage(swords, 0, 0, sw, sh, titleX, titleY, 50, 50);
            // Middle banner
            ctx.drawImage(swords, sw, 0, sw, sh, titleX + 50, titleY, titleW - 100, 50);
            // Right sword
            ctx.drawImage(swords, sw * 2, 0, sw, sh, titleX + titleW - 50, titleY, 50, 50);
        }
        
        // Title text
        ctx.fillStyle = '#4a3020';
        ctx.font = 'bold 28px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Tiny Swords', cx, panelY + 60);
        
        ctx.fillStyle = '#6a5040';
        ctx.font = '16px sans-serif';
        ctx.fillText('ÿßŸÇÿ™ŸÑ ÿßŸÑÿ®Ÿàÿ≥ ŸÅŸä 10 ÿØŸÇÿßÿ¶ŸÇ!', cx, panelY + 90);
        
        // Character card (wood table)
        const cardW = 260;
        const cardH = 280;
        const cardX = cx - cardW / 2;
        const cardY = panelY + 110;
        
        draw9Slice(ctx, this.assets.get('wood_table'), cardX, cardY, cardW, cardH, 149, 149);
        
        // Avatar
        const char = this.chars[this.charIndex];
        const avatar = this.assets.get('avatar' + char.avatar);
        if (avatar) {
            ctx.drawImage(avatar, cx - 45, cardY + 20, 90, 90);
        }
        
        // Character name
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 22px sans-serif';
        ctx.fillText(char.name, cx, cardY + 130);
        
        ctx.fillStyle = '#ccc';
        ctx.font = '14px sans-serif';
        ctx.fillText(char.title, cx, cardY + 150);
        
        // Stats
        ctx.textAlign = 'right';
        ctx.fillStyle = '#fff';
        const statsX = cx + 80;
        let statsY = cardY + 180;
        
        ctx.fillText(`‚ù§Ô∏è ÿßŸÑÿµÿ≠ÿ©: ${char.hp}`, statsX, statsY);
        ctx.fillText(`‚öîÔ∏è ÿßŸÑÿ∂ÿ±ÿ±: ${char.dmg}`, statsX, statsY + 25);
        ctx.fillText(`üèÉ ÿßŸÑÿ≥ÿ±ÿπÿ©: ${char.spd}`, statsX, statsY + 50);
        
        // Navigation arrows (9-slice buttons)
        const arrowSize = 50;
        const arrowY = cardY + cardH / 2 - arrowSize / 2;
        
        // Left arrow
        draw9Slice(ctx, this.assets.get('btn_blue'), cardX - arrowSize - 15, arrowY, arrowSize, arrowSize, 106, 106);
        ctx.fillStyle = '#fff';
        ctx.font = '24px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('‚óÄ', cardX - arrowSize / 2 - 15, arrowY + 33);
        this.clickAreas.push({
            x: cardX - arrowSize - 15, y: arrowY, w: arrowSize, h: arrowSize,
            onClick: () => { this.charIndex = (this.charIndex - 1 + this.chars.length) % this.chars.length; }
        });
        
        // Right arrow
        draw9Slice(ctx, this.assets.get('btn_blue'), cardX + cardW + 15, arrowY, arrowSize, arrowSize, 106, 106);
        ctx.fillText('‚ñ∂', cardX + cardW + 15 + arrowSize / 2, arrowY + 33);
        this.clickAreas.push({
            x: cardX + cardW + 15, y: arrowY, w: arrowSize, h: arrowSize,
            onClick: () => { this.charIndex = (this.charIndex + 1) % this.chars.length; }
        });
        
        // Start button
        const btnW = 200;
        const btnH = 55;
        const btnX = cx - btnW / 2;
        const btnY = panelY + panelH - 80;
        
        draw9Slice(ctx, this.assets.get('btn_blue'), btnX, btnY, btnW, btnH, 106, 106);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 18px sans-serif';
        ctx.fillText('‚öîÔ∏è ÿßÿ®ÿØÿ£ ÿßŸÑŸÖÿπÿ±ŸÉÿ© ‚öîÔ∏è', cx, btnY + 36);
        
        this.clickAreas.push({
            x: btnX, y: btnY, w: btnW, h: btnH,
            onClick: () => this.startGame()
        });
    }
    
    renderWorld() {
        const ctx = this.ctx;
        ctx.save();
        ctx.translate(-this.camera.x, -this.camera.y);
        
        // Terrain tiles
        this.renderTerrain();
        
        // Decorations behind player
        for (const d of this.decorations) {
            if (d.y < this.player.y) this.renderDecor(d);
        }
        
        // Pickups
        for (const p of this.pickups) {
            this.renderPickup(p);
        }
        
        // Enemies
        for (const e of this.enemies) {
            this.renderEnemy(e);
        }
        
        // Boss
        if (this.boss) this.renderBoss();
        
        // Player
        this.renderPlayer();
        
        // Decorations in front
        for (const d of this.decorations) {
            if (d.y >= this.player.y) this.renderDecor(d);
        }
        
        // Projectiles
        for (const p of this.projectiles) {
            this.renderProjectile(p);
        }
        
        // Effects
        for (const e of this.effects) {
            this.renderEffect(e);
        }
        
        // Damage numbers
        for (const d of this.dmgNums) {
            ctx.globalAlpha = Math.min(1, d.life * 2);
            ctx.fillStyle = d.color;
            ctx.font = 'bold 20px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(d.text, d.x, d.y);
        }
        ctx.globalAlpha = 1;
        
        ctx.restore();
    }
    
    renderTerrain() {
        const ctx = this.ctx;
        const tile = this.assets.get('tilemap1');
        if (!tile) return;
        
        const tileSize = 64;
        const camX = this.state === 'menu' ? 0 : this.camera.x;
        const camY = this.state === 'menu' ? 0 : this.camera.y;
        
        const startX = Math.floor(camX / tileSize) * tileSize - tileSize;
        const startY = Math.floor(camY / tileSize) * tileSize - tileSize;
        const endX = camX + this.canvas.width + tileSize;
        const endY = camY + this.canvas.height + tileSize;
        
        for (let x = startX; x < endX; x += tileSize) {
            for (let y = startY; y < endY; y += tileSize) {
                // Use center grass tile (column 1, row 0)
                ctx.drawImage(tile, tileSize, 0, tileSize, tileSize, x, y, tileSize, tileSize);
            }
        }
    }
    
    renderDecor(d) {
        const ctx = this.ctx;
        
        if (d.type === 'tree') {
            const img = this.assets.get('tree' + d.variant);
            if (img) {
                const fw = 256, fh = 256;
                const frame = d.frame % 6;
                ctx.drawImage(img, frame * fw, 0, fw, fh, d.x - 70, d.y - 120, 140, 140);
            }
        } else if (d.type === 'bush') {
            const img = this.assets.get('bush' + d.variant);
            if (img) {
                const fw = 128, fh = 128;
                const frame = d.frame % 8;
                ctx.drawImage(img, frame * fw, 0, fw, fh, d.x - 30, d.y - 30, 60, 60);
            }
        } else if (d.type === 'rock') {
            const img = this.assets.get('rock' + d.variant);
            if (img) {
                ctx.drawImage(img, d.x - 20, d.y - 20, 40, 40);
            }
        }
    }
    
    renderPickup(p) {
        const ctx = this.ctx;
        const img = p.type === 'gold' ? this.assets.get('gold_res') : this.assets.get('meat');
        if (img) {
            ctx.drawImage(img, p.x - 16, p.y - 16, 32, 32);
        }
    }
    
    renderPlayer() {
        const ctx = this.ctx;
        const p = this.player;
        const c = p.char;
        
        let state = 'idle';
        let frames = c.idleF;
        if (p.attacking) { state = 'atk'; frames = c.atkF; }
        else if (p.moving) { state = 'run'; frames = c.runF; }
        
        const img = this.assets.get(c.key + '_' + state);
        if (!img) return;
        
        const fw = 192;
        const frame = p.frame % frames;
        const size = 80;
        
        ctx.save();
        ctx.translate(p.x, p.y);
        if (!p.facingRight) ctx.scale(-1, 1);
        ctx.drawImage(img, frame * fw, 0, fw, fw, -size / 2, -size / 2, size, size);
        ctx.restore();
    }
    
    renderEnemy(e) {
        const ctx = this.ctx;
        const key = e.type.key;
        
        let img = this.assets.get(key + '_run') || this.assets.get(key + '_walk') || this.assets.get(key + '_idle');
        if (!img) return;
        
        const fw = key === 'bear' ? 256 : 192;
        const frames = 6;
        const frame = e.frame % frames;
        const size = e.size;
        
        ctx.save();
        ctx.translate(e.x, e.y);
        if (!e.facingRight) ctx.scale(-1, 1);
        ctx.drawImage(img, frame * fw, 0, fw, fw, -size / 2, -size / 2, size, size);
        ctx.restore();
        
        // Health bar
        const barW = size * 0.8;
        const hpPct = e.hp / e.maxHp;
        ctx.fillStyle = '#000';
        ctx.fillRect(e.x - barW / 2 - 1, e.y - size / 2 - 12, barW + 2, 8);
        ctx.fillStyle = '#c33';
        ctx.fillRect(e.x - barW / 2, e.y - size / 2 - 11, barW * hpPct, 6);
    }
    
    renderBoss() {
        const ctx = this.ctx;
        const b = this.boss;
        
        const img = this.assets.get('minotaur_idle') || this.assets.get('minotaur_walk');
        if (!img) return;
        
        const fw = 192;
        const frame = b.frame % 6;
        const size = b.size;
        
        ctx.save();
        ctx.translate(b.x, b.y);
        if (!b.facingRight) ctx.scale(-1, 1);
        ctx.drawImage(img, frame * fw, 0, fw, fw, -size / 2, -size / 2, size, size);
        ctx.restore();
    }
    
    renderProjectile(p) {
        const ctx = this.ctx;
        const arrow = this.assets.get('arrow');
        if (arrow) {
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(p.angle);
            ctx.drawImage(arrow, -25, -8, 50, 16);
            ctx.restore();
        }
    }
    
    renderEffect(e) {
        const ctx = this.ctx;
        if (e.type === 'explosion') {
            const img = this.assets.get('explosion');
            if (img) {
                const frame = Math.min(e.frame, 7);
                ctx.drawImage(img, frame * 192, 0, 192, 192, e.x - 50, e.y - 50, 100, 100);
            }
        }
    }
    
    renderHUD() {
        const ctx = this.ctx;
        
        // Left panel
        const panelX = 10;
        const panelY = 10;
        
        // HP Bar using actual bar assets
        const barBase = this.assets.get('bar_base');
        const barFill = this.assets.get('bar_fill');
        
        if (barBase && barFill) {
            const barW = 180;
            const barH = 32;
            
            // HP Bar
            // Draw 3-slice bar base (left, middle, right)
            const sliceW = barBase.width / 5; // Left cap, middle (3x), right cap
            ctx.drawImage(barBase, 0, 0, sliceW, barBase.height, panelX, panelY, sliceW * 0.5, barH);
            ctx.drawImage(barBase, sliceW, 0, sliceW * 3, barBase.height, panelX + sliceW * 0.5, panelY, barW - sliceW, barH);
            ctx.drawImage(barBase, sliceW * 4, 0, sliceW, barBase.height, panelX + barW - sliceW * 0.5, panelY, sliceW * 0.5, barH);
            
            // Fill (red tinted)
            const hpPct = this.player.hp / this.player.maxHp;
            ctx.save();
            ctx.beginPath();
            ctx.rect(panelX + 12, panelY + 6, (barW - 24) * hpPct, barH - 12);
            ctx.clip();
            ctx.drawImage(barFill, panelX + 12, panelY + 6, barW - 24, barH - 12);
            ctx.restore();
            
            // HP Text
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`${Math.floor(this.player.hp)}/${this.player.maxHp}`, panelX + barW / 2, panelY + 22);
            
            // XP Bar
            const xpY = panelY + 38;
            ctx.drawImage(barBase, 0, 0, sliceW, barBase.height, panelX, xpY, sliceW * 0.5, barH);
            ctx.drawImage(barBase, sliceW, 0, sliceW * 3, barBase.height, panelX + sliceW * 0.5, xpY, barW - sliceW, barH);
            ctx.drawImage(barBase, sliceW * 4, 0, sliceW, barBase.height, panelX + barW - sliceW * 0.5, xpY, sliceW * 0.5, barH);
            
            // Fill (green tinted)
            const xpPct = this.xp / this.xpNext;
            ctx.save();
            ctx.beginPath();
            ctx.rect(panelX + 12, xpY + 6, (barW - 24) * xpPct, barH - 12);
            ctx.clip();
            ctx.fillStyle = '#4a4';
            ctx.fillRect(panelX + 12, xpY + 6, (barW - 24) * xpPct, barH - 12);
            ctx.restore();
            
            // XP Text
            ctx.fillStyle = '#fff';
            ctx.fillText(`${this.xp}/${this.xpNext}`, panelX + barW / 2, xpY + 22);
        }
        
        // Gold with icon
        const goldIcon = this.assets.get('icon3');
        if (goldIcon) {
            ctx.drawImage(goldIcon, panelX, panelY + 78, 28, 28);
        }
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 18px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText(this.gold, panelX + 32, panelY + 100);
        
        // Right stats
        const rightX = this.canvas.width - 15;
        ctx.textAlign = 'right';
        
        ctx.fillStyle = '#8f8';
        ctx.font = 'bold 16px sans-serif';
        ctx.fillText(`Lv.${this.level}`, rightX, 30);
        
        ctx.fillStyle = '#f88';
        ctx.fillText(`üíÄ ${this.kills}`, rightX, 55);
        
        const remaining = Math.max(0, 600 - this.gameTime);
        const mins = Math.floor(remaining / 60);
        const secs = Math.floor(remaining % 60);
        ctx.fillStyle = '#8cf';
        ctx.fillText(`${mins}:${secs.toString().padStart(2, '0')}`, rightX, 80);
        
        // Boss health bar
        if (this.boss) {
            const bossW = Math.min(400, this.canvas.width - 100);
            const bossX = (this.canvas.width - bossW) / 2;
            
            ctx.fillStyle = '#000';
            ctx.fillRect(bossX - 2, 8, bossW + 4, 28);
            ctx.fillStyle = '#800';
            ctx.fillRect(bossX, 10, bossW * (this.boss.hp / this.boss.maxHp), 24);
            
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.font = 'bold 14px sans-serif';
            ctx.fillText(`ÿßŸÑŸÖŸäŸÜŸàÿ™Ÿàÿ± - ${Math.floor(this.boss.hp)}/${this.boss.maxHp}`, this.canvas.width / 2, 28);
        }
        
        // Joystick
        if (this.touch.active) {
            ctx.strokeStyle = 'rgba(255,255,255,0.4)';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(this.touch.sx, this.touch.sy, 70, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            ctx.beginPath();
            ctx.arc(this.touch.sx + this.joy.x * 50, this.touch.sy + this.joy.y * 50, 30, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    renderLevelUp() {
        const ctx = this.ctx;
        
        ctx.fillStyle = 'rgba(0,0,0,0.8)';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        const cx = this.canvas.width / 2;
        const cy = this.canvas.height / 2;
        
        // Panel
        const panelW = Math.min(500, this.canvas.width - 30);
        const panelH = 320;
        draw9Slice(ctx, this.assets.get('banner'), cx - panelW / 2, cy - panelH / 2, panelW, panelH, 149, 149);
        
        // Title
        ctx.fillStyle = '#4a3020';
        ctx.font = 'bold 28px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(`üéâ ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ ${this.level}! üéâ`, cx, cy - panelH / 2 + 55);
        
        // Upgrade cards
        const cardW = 130;
        const cardH = 170;
        const gap = 15;
        const startX = cx - (cardW * 1.5 + gap);
        
        for (let i = 0; i < 3; i++) {
            const upgrade = this.upgrades[i];
            const x = startX + i * (cardW + gap);
            const y = cy - 50;
            
            draw9Slice(ctx, this.assets.get('wood_table'), x, y, cardW, cardH, 149, 149);
            
            // Icon
            const icon = this.assets.get('icon' + upgrade.icon);
            if (icon) {
                ctx.drawImage(icon, x + cardW / 2 - 24, y + 20, 48, 48);
            }
            
            // Text
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 14px sans-serif';
            ctx.fillText(upgrade.name, x + cardW / 2, y + 90);
            
            ctx.fillStyle = '#fff';
            ctx.font = '12px sans-serif';
            ctx.fillText(upgrade.desc, x + cardW / 2, y + 115);
            
            this.clickAreas.push({
                x, y, w: cardW, h: cardH,
                onClick: () => this.selectUpgrade(upgrade)
            });
        }
    }
    
    renderGameOver() {
        const ctx = this.ctx;
        
        ctx.fillStyle = 'rgba(0,0,0,0.85)';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        const cx = this.canvas.width / 2;
        const cy = this.canvas.height / 2;
        
        // Panel
        const panelW = 350;
        const panelH = 320;
        draw9Slice(ctx, this.assets.get('banner'), cx - panelW / 2, cy - panelH / 2, panelW, panelH, 149, 149);
        
        // Title
        ctx.font = 'bold 32px sans-serif';
        ctx.textAlign = 'center';
        if (this.victory) {
            ctx.fillStyle = '#ffd700';
            ctx.fillText('üéâ ÿßŸÜÿ™ÿµÿßÿ±! üéâ', cx, cy - 90);
        } else {
            ctx.fillStyle = '#c33';
            ctx.fillText('üíÄ Ÿáÿ≤ŸäŸÖÿ© üíÄ', cx, cy - 90);
        }
        
        // Stats
        ctx.fillStyle = '#4a3020';
        ctx.font = '18px sans-serif';
        const mins = Math.floor(this.gameTime / 60);
        const secs = Math.floor(this.gameTime % 60);
        ctx.fillText(`‚è±Ô∏è ÿßŸÑŸàŸÇÿ™: ${mins}:${secs.toString().padStart(2, '0')}`, cx, cy - 40);
        ctx.fillText(`üíÄ ÿßŸÑŸÇÿ™ŸÑŸâ: ${this.kills}`, cx, cy - 10);
        ctx.fillText(`ü™ô ÿßŸÑÿ∞Ÿáÿ®: ${this.gold}`, cx, cy + 20);
        ctx.fillText(`üìä ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ: ${this.level}`, cx, cy + 50);
        
        // Button
        const btnW = 180;
        const btnH = 50;
        const btnX = cx - btnW / 2;
        const btnY = cy + 80;
        
        draw9Slice(ctx, this.assets.get('btn_blue'), btnX, btnY, btnW, btnH, 106, 106);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 16px sans-serif';
        ctx.fillText('üîÑ ÿßŸÑÿπÿ® ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ', cx, btnY + 32);
        
        this.clickAreas.push({
            x: btnX, y: btnY, w: btnW, h: btnH,
            onClick: () => { this.state = 'menu'; }
        });
    }
}

// ===================== START =====================
const game = new Game();
game.init();
</script>
</body>
</html>
