<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Tiny Swords - ŸÖÿπÿ±ŸÉÿ© ÿßŸÑÿ≥ŸäŸàŸÅ ÿßŸÑÿµÿ∫Ÿäÿ±ÿ©</title>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
        body { 
            background: #1a1a2e; 
            font-family: 'Cairo', sans-serif; 
            overflow: hidden; 
            min-height: 100vh; 
            color: #fff; 
        }
        #gameCanvas { 
            display: block; 
            position: absolute; 
            top: 0; 
            left: 0; 
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        #mainMenu {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            background: linear-gradient(180deg, rgba(26,26,46,0.98) 0%, rgba(10,10,15,0.98) 100%);
            gap: 15px;
        }
        
        .menu-title {
            font-size: 2.5rem;
            font-weight: 900;
            background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: none;
        }
        
        .menu-subtitle {
            font-size: 1rem;
            color: #888;
        }
        
        .character-select {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .char-arrow {
            width: 50px; height: 50px;
            background: rgba(255,215,0,0.1);
            border: 2px solid rgba(255,215,0,0.3);
            border-radius: 50%;
            color: #ffd700;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s;
        }
        .char-arrow:hover {
            background: rgba(255,215,0,0.2);
            transform: scale(1.1);
        }
        
        .character-display {
            width: 280px;
            padding: 20px;
            background: rgba(30,30,40,0.9);
            border: 3px solid rgba(255,215,0,0.3);
            border-radius: 15px;
            text-align: center;
        }
        
        .char-preview {
            width: 128px; height: 128px;
            margin: 0 auto 15px;
            image-rendering: pixelated;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
        }
        
        .char-name {
            font-size: 1.5rem;
            font-weight: 900;
            color: #ffd700;
        }
        
        .char-title {
            font-size: 0.9rem;
            color: #888;
            margin-bottom: 10px;
        }
        
        .char-stats {
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
        }
        
        .char-stat {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            margin: 5px 0;
        }
        
        .stat-label { color: #888; }
        .stat-value { color: #4f4; font-weight: bold; }
        
        .btn {
            padding: 15px 50px;
            font-size: 1.2rem;
            font-weight: 700;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%);
            color: #000;
            box-shadow: 0 6px 20px rgba(255,215,0,0.4);
        }
        .btn-primary:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 25px rgba(255,215,0,0.5);
        }
        
        #hud {
            position: fixed;
            top: 10px; left: 10px;
            display: none;
            z-index: 50;
        }
        
        .hud-panel {
            background: rgba(42,37,48,0.95);
            border: 3px solid #1a1518;
            padding: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 5px;
        }
        
        .hud-avatar {
            width: 48px; height: 48px;
            background: #1a1518;
            border: 2px solid #3a3540;
            overflow: hidden;
        }
        .hud-avatar canvas {
            image-rendering: pixelated;
        }
        
        .hud-bars {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .hud-bar {
            width: 150px;
            height: 16px;
            background: #0a0808;
            border: 2px solid #3a3540;
            position: relative;
        }
        
        .hud-bar-fill {
            height: 100%;
            transition: width 0.2s;
        }
        
        .health-fill { background: linear-gradient(180deg, #ff4444, #cc2222); }
        .xp-fill { background: linear-gradient(180deg, #44ff44, #22cc22); }
        
        .hud-bar-text {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
        }
        
        .hud-stats {
            position: fixed;
            top: 10px; right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: flex-end;
        }
        
        .hud-stat {
            background: rgba(42,37,48,0.95);
            border: 2px solid #1a1518;
            padding: 5px 12px;
            font-size: 14px;
            font-weight: bold;
        }
        
        .gold-text { color: #ffd700; }
        .kill-text { color: #ff6666; }
        .timer-text { color: #88ccff; }
        .level-text { color: #88ff88; }
        
        #levelUpModal {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        
        .level-up-content {
            text-align: center;
            padding: 30px;
            background: rgba(20,20,30,0.95);
            border: 3px solid #ffd700;
            border-radius: 20px;
        }
        
        .level-up-title {
            font-size: 2rem;
            color: #ffd700;
            margin-bottom: 20px;
        }
        
        .upgrade-options {
            display: flex;
            gap: 15px;
            justify-content: center;
        }
        
        .upgrade-card {
            width: 140px;
            padding: 15px;
            background: #3d3846;
            border: 3px solid #5a5060;
            cursor: pointer;
            transition: all 0.2s;
        }
        .upgrade-card:hover {
            transform: scale(1.05);
            border-color: #ffd700;
        }
        
        .upgrade-icon { font-size: 2rem; margin-bottom: 10px; }
        .upgrade-name { font-size: 1rem; font-weight: bold; margin-bottom: 5px; }
        .upgrade-desc { font-size: 0.8rem; color: #aaa; }
        
        #gameOverScreen {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
        }
        
        .game-over-title {
            font-size: 3rem;
            color: #ff0000;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(255,0,0,0.8);
        }
        .victory-title {
            color: #ffd700 !important;
            text-shadow: 0 0 20px rgba(255,215,0,0.8) !important;
        }
        
        .final-stats {
            font-size: 1.2rem;
            margin-bottom: 30px;
            line-height: 2;
        }
        
        #bossWarning {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5rem;
            color: #ff0000;
            text-shadow: 0 0 30px rgba(255,0,0,0.8);
            display: none;
            z-index: 150;
            animation: bossWarn 0.5s ease-in-out infinite alternate;
        }
        @keyframes bossWarn {
            from { transform: translate(-50%, -50%) scale(1); }
            to { transform: translate(-50%, -50%) scale(1.1); }
        }
        
        #pauseBtn {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 50px; height: 50px;
            background: rgba(0,0,0,0.6);
            border: 2px solid rgba(255,215,0,0.5);
            border-radius: 50%;
            color: #ffd700;
            font-size: 1.5rem;
            cursor: pointer;
            z-index: 60;
            display: none;
        }
        
        @media (max-width: 768px) {
            .menu-title { font-size: 1.8rem; }
            .character-display { width: 220px; padding: 15px; }
            .char-preview { width: 96px; height: 96px; }
            .btn { padding: 12px 35px; font-size: 1rem; }
            .upgrade-card { width: 100px; padding: 10px; }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="mainMenu">
        <h1 class="menu-title">‚öîÔ∏è Tiny Swords ‚öîÔ∏è</h1>
        <p class="menu-subtitle">ÿßŸáÿ≤ŸÖ ÿßŸÑÿ£ÿπÿØÿßÿ° ŸàÿßŸÇÿ™ŸÑ ÿßŸÑÿ®Ÿàÿ≥ ŸÅŸä 10 ÿØŸÇÿßÿ¶ŸÇ!</p>
        
        <div class="character-select">
            <button class="char-arrow" id="charPrev">‚Üí</button>
            <div class="character-display">
                <canvas class="char-preview" id="charPreview" width="128" height="128"></canvas>
                <div class="char-name" id="charName">ÿßŸÑŸÖÿ≠ÿßÿ±ÿ®</div>
                <div class="char-title" id="charTitle">Warrior</div>
                <div class="char-stats" id="charStats">
                    <div class="char-stat"><span class="stat-label">‚ù§Ô∏è ÿßŸÑÿµÿ≠ÿ©:</span><span class="stat-value" id="statHp">100</span></div>
                    <div class="char-stat"><span class="stat-label">‚öîÔ∏è ÿßŸÑÿ∂ÿ±ÿ±:</span><span class="stat-value" id="statDmg">10</span></div>
                    <div class="char-stat"><span class="stat-label">üèÉ ÿßŸÑÿ≥ÿ±ÿπÿ©:</span><span class="stat-value" id="statSpd">ŸÖÿ™Ÿàÿ≥ÿ∑ÿ©</span></div>
                </div>
            </div>
            <button class="char-arrow" id="charNext">‚Üê</button>
        </div>
        
        <button class="btn btn-primary" id="startBtn">‚öîÔ∏è ÿßÿ®ÿØÿ£ ÿßŸÑŸÖÿπÿ±ŸÉÿ© ‚öîÔ∏è</button>
    </div>
    
    <div id="hud">
        <div class="hud-panel">
            <div class="hud-avatar"><canvas id="hudAvatarCanvas" width="48" height="48"></canvas></div>
            <div class="hud-bars">
                <div class="hud-bar">
                    <div class="hud-bar-fill health-fill" id="healthBar" style="width:100%"></div>
                    <span class="hud-bar-text" id="healthText">100/100</span>
                </div>
                <div class="hud-bar">
                    <div class="hud-bar-fill xp-fill" id="xpBar" style="width:0%"></div>
                    <span class="hud-bar-text" id="xpText">0/10</span>
                </div>
            </div>
        </div>
        <div class="hud-panel" style="padding:5px 12px">
            <span style="font-size:1.2rem">ü™ô</span>
            <span class="gold-text" id="goldText">0</span>
        </div>
    </div>
    
    <div class="hud-stats" id="hudStats" style="display:none">
        <div class="hud-stat level-text">üìä <span id="levelText">Lv.1</span></div>
        <div class="hud-stat kill-text">üíÄ <span id="killText">0</span></div>
        <div class="hud-stat timer-text">‚è±Ô∏è <span id="timerText">10:00</span></div>
    </div>
    
    <button id="pauseBtn">‚è∏Ô∏è</button>
    
    <div id="levelUpModal">
        <div class="level-up-content">
            <h2 class="level-up-title">üéâ ŸÖÿ≥ÿ™ŸàŸâ ÿ¨ÿØŸäÿØ! üéâ</h2>
            <div class="upgrade-options" id="upgradeOptions"></div>
        </div>
    </div>
    
    <div id="gameOverScreen">
        <h1 class="game-over-title" id="gameOverTitle">ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑŸÑÿπÿ®ÿ©!</h1>
        <div class="final-stats" id="finalStats"></div>
        <button class="btn btn-primary" id="restartBtn">üîÑ ÿßŸÑÿπÿ® ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ</button>
    </div>
    
    <div id="bossWarning">‚ö†Ô∏è ÿßŸÑÿ®Ÿàÿ≥ ŸÇÿßÿØŸÖ! ‚ö†Ô∏è</div>
    
    <script>
    // ==================== GAME CONFIGURATION ====================
    const CONFIG = {
        // Paths
        ASSETS_PATH: 'assets/',
        CHARACTERS_PATH: 'assets/Tiny Swords Free Pack/Tiny Swords (Free Pack)/Units/',
        ENEMIES_PATH: 'assets/New enemy/Tiny Swords Enemy Pack/Tiny Swords (Enemy Pack)/Enemy Pack/',
        TERRAIN_PATH: 'assets/Tiny Swords Free Pack/Tiny Swords (Free Pack)/Terrain/',
        UI_PATH: 'assets/Tiny Swords Free Pack/Tiny Swords (Free Pack)/UI Elements/',
        
        // Game settings
        GAME_DURATION: 600, // 10 minutes in seconds
        BOSS_TIME: 540, // Boss appears at 9 minutes
        
        // Player defaults
        PLAYER_SIZE: 48,
        PLAYER_SPEED: 200,
        
        // Enemy settings
        ENEMY_BASE_HP: 20,
        ENEMY_BASE_DMG: 5,
        ENEMY_BASE_SPEED: 80,
        SPAWN_RATE: 1.5, // seconds between spawns
        MAX_ENEMIES: 100,
        
        // XP settings
        XP_PER_LEVEL: [10, 15, 20, 30, 40, 50, 65, 80, 100, 120],
    };
    
    // ==================== CHARACTER DEFINITIONS ====================
    const CHARACTERS = {
        warrior: {
            name: 'ÿßŸÑŸÖÿ≠ÿßÿ±ÿ®',
            title: 'Warrior',
            color: 'Blue',
            hp: 120,
            damage: 12,
            speed: 200,
            attackSpeed: 1.0,
            attackRange: 60,
            idleSprite: 'Warrior_Idle',
            runSprite: 'Warrior_Run',
            attackSprite: 'Warrior_Attack1',
            frameSize: 192,
            idleFrames: 8,
            runFrames: 6,
            attackFrames: 6,
            passive: '+20% ÿµÿ≠ÿ©ÿå Ÿáÿ¨ŸàŸÖ ŸÇŸàŸä'
        },
        archer: {
            name: 'ÿßŸÑÿ±ÿßŸÖŸä',
            title: 'Archer',
            color: 'Blue',
            hp: 80,
            damage: 15,
            speed: 220,
            attackSpeed: 0.8,
            attackRange: 300,
            idleSprite: 'Archer_Idle',
            runSprite: 'Archer_Run',
            attackSprite: 'Archer_Shoot',
            frameSize: 192,
            idleFrames: 6,
            runFrames: 6,
            attackFrames: 8,
            passive: 'Ÿáÿ¨ŸàŸÖ ÿ®ÿπŸäÿØ ÿßŸÑŸÖÿØŸâ'
        },
        lancer: {
            name: 'ÿßŸÑÿ±ŸÖŸëÿßÿ≠',
            title: 'Lancer',
            color: 'Yellow',
            hp: 100,
            damage: 14,
            speed: 210,
            attackSpeed: 0.9,
            attackRange: 80,
            idleSprite: 'Lancer_Idle',
            runSprite: 'Lancer_Run',
            attackSprite: 'Lancer_Right_Attack',
            frameSize: 192,
            idleFrames: 6,
            runFrames: 6,
            attackFrames: 6,
            passive: 'ŸÖÿØŸâ Ÿáÿ¨ŸàŸÖ ÿ£ÿ∑ŸàŸÑ'
        },
        pawn: {
            name: 'ÿßŸÑÿπÿßŸÖŸÑ',
            title: 'Pawn',
            color: 'Yellow',
            hp: 90,
            damage: 8,
            speed: 240,
            attackSpeed: 1.2,
            attackRange: 50,
            idleSprite: 'Pawn_Idle',
            runSprite: 'Pawn_Run',
            attackSprite: 'Pawn_Idle',
            frameSize: 192,
            idleFrames: 6,
            runFrames: 6,
            attackFrames: 6,
            passive: 'ÿ≥ÿ±ÿπÿ© ÿπÿßŸÑŸäÿ©ÿå +50% ÿ∞Ÿáÿ®'
        },
        monk: {
            name: 'ÿßŸÑÿ±ÿßŸáÿ®',
            title: 'Monk',
            color: 'Purple',
            hp: 100,
            damage: 10,
            speed: 190,
            attackSpeed: 1.0,
            attackRange: 70,
            idleSprite: 'Idle',
            runSprite: 'Run',
            attackSprite: 'Heal',
            frameSize: 192,
            idleFrames: 6,
            runFrames: 6,
            attackFrames: 6,
            passive: 'ÿ¥ŸÅÿßÿ° ÿ∞ÿßÿ™Ÿä ŸÉŸÑ 5 ÿ´ŸàÿßŸÜŸä',
            monkPath: true
        }
    };
    
    // ==================== ENEMY DEFINITIONS ====================
    const ENEMIES = {
        skull: {
            name: 'ÿßŸÑÿ¨ŸÖÿ¨ŸÖÿ©',
            folder: 'Skull',
            hp: 1,
            damage: 0.8,
            speed: 1.2,
            xp: 2,
            gold: 1,
            frameSize: 192,
            idleFrames: 8,
            runFrames: 4,
            appearsAfter: 0
        },
        spider: {
            name: 'ÿßŸÑÿπŸÜŸÉÿ®Ÿàÿ™',
            folder: 'Spider',
            hp: 0.8,
            damage: 0.7,
            speed: 1.4,
            xp: 2,
            gold: 1,
            frameSize: 192,
            idleFrames: 8,
            runFrames: 6,
            appearsAfter: 0
        },
        snake: {
            name: 'ÿßŸÑÿ£ŸÅÿπŸâ',
            folder: 'Snake',
            hp: 1,
            damage: 1,
            speed: 1.1,
            xp: 3,
            gold: 2,
            frameSize: 192,
            idleFrames: 6,
            runFrames: 6,
            appearsAfter: 60
        },
        gnome: {
            name: 'ÿßŸÑŸÇÿ≤ŸÖ',
            folder: 'Gnome',
            hp: 1.2,
            damage: 1,
            speed: 1.0,
            xp: 3,
            gold: 2,
            frameSize: 192,
            idleFrames: 6,
            runFrames: 6,
            appearsAfter: 60
        },
        lizard: {
            name: 'ÿßŸÑÿ≥ÿ≠ŸÑŸäÿ©',
            folder: 'Lizard',
            hp: 1.5,
            damage: 1.2,
            speed: 1.0,
            xp: 4,
            gold: 3,
            frameSize: 192,
            idleFrames: 6,
            runFrames: 6,
            appearsAfter: 120
        },
        thief: {
            name: 'ÿßŸÑŸÑÿµ',
            folder: 'Thief',
            hp: 1,
            damage: 1.5,
            speed: 1.5,
            xp: 4,
            gold: 5,
            frameSize: 192,
            idleFrames: 6,
            runFrames: 6,
            appearsAfter: 180
        },
        gnoll: {
            name: 'ÿßŸÑÿ¨ŸÜŸàŸÑ',
            folder: 'Gnoll',
            hp: 2,
            damage: 1.3,
            speed: 0.9,
            xp: 5,
            gold: 4,
            frameSize: 192,
            idleFrames: 6,
            walkFrames: 6,
            appearsAfter: 240
        },
        bear: {
            name: 'ÿßŸÑÿØÿ®',
            folder: 'Bear',
            hp: 3,
            damage: 2,
            speed: 0.7,
            xp: 8,
            gold: 6,
            frameSize: 256,
            idleFrames: 8,
            runFrames: 6,
            appearsAfter: 300
        },
        panda: {
            name: 'ÿßŸÑÿ®ÿßŸÜÿØÿß',
            folder: 'Panda',
            hp: 2.5,
            damage: 1.8,
            speed: 0.8,
            xp: 7,
            gold: 5,
            frameSize: 192,
            idleFrames: 6,
            runFrames: 6,
            appearsAfter: 360
        },
        troll: {
            name: 'ÿßŸÑÿ™ÿ±ŸàŸÑ',
            folder: 'Troll',
            hp: 4,
            damage: 2.5,
            speed: 0.6,
            xp: 10,
            gold: 8,
            frameSize: 192,
            idleFrames: 6,
            walkFrames: 6,
            appearsAfter: 420
        },
        minotaur: {
            name: 'ÿßŸÑŸÖŸäŸÜŸàÿ™Ÿàÿ±',
            folder: 'Minotaur',
            hp: 5,
            damage: 3,
            speed: 0.5,
            xp: 15,
            gold: 12,
            frameSize: 192,
            idleFrames: 6,
            walkFrames: 6,
            appearsAfter: 480
        }
    };
    
    // Boss definition
    const BOSS = {
        name: 'ÿßŸÑÿ™ŸÜŸäŸÜ ÿßŸÑÿ£ÿπÿ∏ŸÖ',
        folder: 'Minotaur', // Using Minotaur as boss sprite
        hp: 5000,
        damage: 25,
        speed: 60,
        frameSize: 192,
        scale: 2.5
    };
    
    // ==================== UPGRADES ====================
    const UPGRADES = {
        damage: { name: '‚öîÔ∏è ŸÇŸàÿ© ÿßŸÑŸáÿ¨ŸàŸÖ', desc: '+15% ÿ∂ÿ±ÿ±', stat: 'damage', value: 0.15 },
        speed: { name: 'üèÉ ÿßŸÑÿ≥ÿ±ÿπÿ©', desc: '+10% ÿ≥ÿ±ÿπÿ©', stat: 'speed', value: 0.10 },
        attackSpeed: { name: '‚ö° ÿ≥ÿ±ÿπÿ© ÿßŸÑŸáÿ¨ŸàŸÖ', desc: '+12% ÿ≥ÿ±ÿπÿ© Ÿáÿ¨ŸàŸÖ', stat: 'attackSpeed', value: 0.12 },
        maxHp: { name: '‚ù§Ô∏è ÿßŸÑÿµÿ≠ÿ©', desc: '+20 ÿµÿ≠ÿ© ŸÇÿµŸàŸâ', stat: 'maxHp', value: 20 },
        range: { name: 'üéØ ÿßŸÑŸÖÿØŸâ', desc: '+15% ŸÖÿØŸâ ÿßŸÑŸáÿ¨ŸàŸÖ', stat: 'range', value: 0.15 },
        regen: { name: 'üíö ÿßŸÑÿ™ÿ¨ÿØŸäÿØ', desc: '+1 ÿ¥ŸÅÿßÿ°/ÿ´ÿßŸÜŸäÿ©', stat: 'regen', value: 1 },
        crit: { name: 'üí• ÿßŸÑÿ∂ÿ±ÿ®ÿ© ÿßŸÑÿ≠ÿ±ÿ¨ÿ©', desc: '+5% ÿßÿ≠ÿ™ŸÖÿßŸÑ ÿ∂ÿ±ÿ®ÿ© ÿ≠ÿ±ÿ¨ÿ©', stat: 'crit', value: 0.05 },
        goldBonus: { name: 'ü™ô ÿßŸÑÿ∞Ÿáÿ®', desc: '+20% ÿ∞Ÿáÿ®', stat: 'goldBonus', value: 0.20 }
    };
    
    // ==================== ASSET LOADER ====================
    class AssetLoader {
        constructor() {
            this.images = {};
            this.loadedCount = 0;
            this.totalCount = 0;
        }
        
        async loadImage(name, path) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    this.images[name] = img;
                    this.loadedCount++;
                    resolve(img);
                };
                img.onerror = () => {
                    console.warn(`Failed to load: ${path}`);
                    resolve(null);
                };
                img.src = path;
            });
        }
        
        async loadAllAssets() {
            const promises = [];
            
            // Load character sprites
            for (const [key, char] of Object.entries(CHARACTERS)) {
                const basePath = char.monkPath 
                    ? `${CONFIG.CHARACTERS_PATH}${char.color} Units/Monk/`
                    : `${CONFIG.CHARACTERS_PATH}${char.color} Units/${char.title}/`;
                
                promises.push(this.loadImage(`${key}_idle`, `${basePath}${char.idleSprite}.png`));
                promises.push(this.loadImage(`${key}_run`, `${basePath}${char.runSprite}.png`));
                if (char.attackSprite) {
                    promises.push(this.loadImage(`${key}_attack`, `${basePath}${char.attackSprite}.png`));
                }
            }
            
            // Load enemy sprites
            for (const [key, enemy] of Object.entries(ENEMIES)) {
                const basePath = `${CONFIG.ENEMIES_PATH}${enemy.folder}/`;
                const prefix = enemy.folder.replace(' ', '');
                
                promises.push(this.loadImage(`${key}_idle`, `${basePath}${prefix}_Idle.png`));
                if (enemy.runFrames) {
                    promises.push(this.loadImage(`${key}_run`, `${basePath}${prefix}_Run.png`));
                }
                if (enemy.walkFrames) {
                    promises.push(this.loadImage(`${key}_walk`, `${basePath}${prefix}_Walk.png`));
                }
            }
            
            // Load terrain
            promises.push(this.loadImage('tilemap', `${CONFIG.TERRAIN_PATH}Tileset/Tilemap_color1.png`));
            promises.push(this.loadImage('shadow', `${CONFIG.TERRAIN_PATH}Tileset/Shadow.png`));
            
            await Promise.all(promises);
            console.log(`Loaded ${this.loadedCount} assets`);
        }
        
        get(name) {
            return this.images[name];
        }
    }
    
    // ==================== GAME CLASS ====================
    class Game {
        constructor() {
            this.canvas = document.getElementById('gameCanvas');
            this.ctx = this.canvas.getContext('2d');
            this.assets = new AssetLoader();
            
            this.resize();
            window.addEventListener('resize', () => this.resize());
            
            // Game state
            this.state = 'menu'; // menu, playing, paused, gameover
            this.selectedCharIndex = 0;
            this.characterKeys = Object.keys(CHARACTERS);
            
            // Player
            this.player = null;
            
            // Entities
            this.enemies = [];
            this.projectiles = [];
            this.pickups = [];
            this.damageNumbers = [];
            
            // Camera
            this.camera = { x: 0, y: 0 };
            
            // Stats
            this.kills = 0;
            this.gold = 0;
            this.gameTime = 0;
            this.level = 1;
            this.xp = 0;
            this.xpToNext = CONFIG.XP_PER_LEVEL[0];
            
            // Timing
            this.lastTime = 0;
            this.spawnTimer = 0;
            this.bossSpawned = false;
            this.boss = null;
            
            // Input
            this.keys = {};
            this.touch = { active: false, x: 0, y: 0 };
            this.joystick = { x: 0, y: 0 };
            
            this.setupInput();
            this.setupUI();
        }
        
        resize() {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            this.ctx.imageSmoothingEnabled = false;
        }
        
        setupInput() {
            // Keyboard
            window.addEventListener('keydown', e => {
                this.keys[e.code] = true;
                if (e.code === 'Escape' && this.state === 'playing') {
                    this.togglePause();
                }
            });
            window.addEventListener('keyup', e => this.keys[e.code] = false);
            
            // Touch / Mouse for movement
            this.canvas.addEventListener('touchstart', e => {
                e.preventDefault();
                const touch = e.touches[0];
                this.touch.active = true;
                this.touch.startX = touch.clientX;
                this.touch.startY = touch.clientY;
            });
            
            this.canvas.addEventListener('touchmove', e => {
                e.preventDefault();
                if (this.touch.active) {
                    const touch = e.touches[0];
                    const dx = touch.clientX - this.touch.startX;
                    const dy = touch.clientY - this.touch.startY;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist > 10) {
                        this.joystick.x = dx / Math.max(dist, 50);
                        this.joystick.y = dy / Math.max(dist, 50);
                    }
                }
            });
            
            this.canvas.addEventListener('touchend', e => {
                e.preventDefault();
                this.touch.active = false;
                this.joystick.x = 0;
                this.joystick.y = 0;
            });
        }
        
        setupUI() {
            // Character selection
            document.getElementById('charPrev').onclick = () => this.changeCharacter(-1);
            document.getElementById('charNext').onclick = () => this.changeCharacter(1);
            
            // Start button
            document.getElementById('startBtn').onclick = () => this.startGame();
            
            // Restart button
            document.getElementById('restartBtn').onclick = () => {
                document.getElementById('gameOverScreen').style.display = 'none';
                document.getElementById('mainMenu').style.display = 'flex';
                this.state = 'menu';
            };
            
            // Pause button
            document.getElementById('pauseBtn').onclick = () => this.togglePause();
        }
        
        changeCharacter(dir) {
            this.selectedCharIndex = (this.selectedCharIndex + dir + this.characterKeys.length) % this.characterKeys.length;
            this.updateCharacterDisplay();
        }
        
        updateCharacterDisplay() {
            const key = this.characterKeys[this.selectedCharIndex];
            const char = CHARACTERS[key];
            
            document.getElementById('charName').textContent = char.name;
            document.getElementById('charTitle').textContent = char.title;
            document.getElementById('statHp').textContent = char.hp;
            document.getElementById('statDmg').textContent = char.damage;
            document.getElementById('statSpd').textContent = char.speed >= 220 ? 'ÿπÿßŸÑŸäÿ©' : (char.speed >= 200 ? 'ŸÖÿ™Ÿàÿ≥ÿ∑ÿ©' : 'ŸÖŸÜÿÆŸÅÿ∂ÿ©');
            
            // Draw character preview
            const previewCanvas = document.getElementById('charPreview');
            const ctx = previewCanvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;
            ctx.clearRect(0, 0, 128, 128);
            
            const sprite = this.assets.get(`${key}_idle`);
            if (sprite) {
                const frameSize = char.frameSize;
                ctx.drawImage(sprite, 0, 0, frameSize, frameSize, 0, 0, 128, 128);
            }
        }
        
        async init() {
            await this.assets.loadAllAssets();
            this.updateCharacterDisplay();
            this.gameLoop(0);
        }
        
        startGame() {
            const key = this.characterKeys[this.selectedCharIndex];
            const charDef = CHARACTERS[key];
            
            // Initialize player
            this.player = {
                x: 0,
                y: 0,
                hp: charDef.hp,
                maxHp: charDef.hp,
                damage: charDef.damage,
                speed: charDef.speed,
                attackSpeed: charDef.attackSpeed,
                attackRange: charDef.attackRange,
                attackCooldown: 0,
                charKey: key,
                charDef: charDef,
                frame: 0,
                frameTime: 0,
                facingRight: true,
                isMoving: false,
                isAttacking: false,
                regen: 0,
                regenTimer: 0,
                crit: 0,
                goldBonus: charDef.title === 'Pawn' ? 0.5 : 0
            };
            
            // Reset game state
            this.enemies = [];
            this.projectiles = [];
            this.pickups = [];
            this.damageNumbers = [];
            this.kills = 0;
            this.gold = 0;
            this.gameTime = 0;
            this.level = 1;
            this.xp = 0;
            this.xpToNext = CONFIG.XP_PER_LEVEL[0];
            this.spawnTimer = 0;
            this.bossSpawned = false;
            this.boss = null;
            
            // Hide menu, show HUD
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            document.getElementById('hudStats').style.display = 'flex';
            document.getElementById('pauseBtn').style.display = 'block';
            
            // Draw HUD avatar
            this.drawHUDAvatar();
            
            this.state = 'playing';
        }
        
        drawHUDAvatar() {
            const canvas = document.getElementById('hudAvatarCanvas');
            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;
            ctx.clearRect(0, 0, 48, 48);
            
            const sprite = this.assets.get(`${this.player.charKey}_idle`);
            if (sprite) {
                const frameSize = this.player.charDef.frameSize;
                ctx.drawImage(sprite, 0, 0, frameSize, frameSize, 0, 0, 48, 48);
            }
        }
        
        togglePause() {
            if (this.state === 'playing') {
                this.state = 'paused';
            } else if (this.state === 'paused') {
                this.state = 'playing';
            }
        }
        
        gameLoop(timestamp) {
            const dt = Math.min((timestamp - this.lastTime) / 1000, 0.1);
            this.lastTime = timestamp;
            
            if (this.state === 'playing') {
                this.update(dt);
            }
            
            this.render();
            requestAnimationFrame(t => this.gameLoop(t));
        }
        
        update(dt) {
            this.gameTime += dt;
            
            // Update timer display
            const remaining = Math.max(0, CONFIG.GAME_DURATION - this.gameTime);
            const mins = Math.floor(remaining / 60);
            const secs = Math.floor(remaining % 60);
            document.getElementById('timerText').textContent = 
                `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            
            // Check win/lose
            if (this.gameTime >= CONFIG.GAME_DURATION && !this.bossSpawned) {
                this.spawnBoss();
            }
            
            if (this.player.hp <= 0) {
                this.gameOver(false);
                return;
            }
            
            // Update player
            this.updatePlayer(dt);
            
            // Update enemies
            this.updateEnemies(dt);
            
            // Spawn enemies
            this.spawnTimer += dt;
            if (this.spawnTimer >= CONFIG.SPAWN_RATE && this.enemies.length < CONFIG.MAX_ENEMIES) {
                this.spawnEnemy();
                this.spawnTimer = 0;
            }
            
            // Update projectiles
            this.updateProjectiles(dt);
            
            // Update pickups
            this.updatePickups(dt);
            
            // Update damage numbers
            this.damageNumbers = this.damageNumbers.filter(d => {
                d.life -= dt;
                d.y -= 30 * dt;
                return d.life > 0;
            });
            
            // Update camera
            this.camera.x = this.player.x - this.canvas.width / 2;
            this.camera.y = this.player.y - this.canvas.height / 2;
            
            // Regen
            if (this.player.regen > 0) {
                this.player.regenTimer += dt;
                if (this.player.regenTimer >= 1) {
                    this.player.hp = Math.min(this.player.maxHp, this.player.hp + this.player.regen);
                    this.player.regenTimer = 0;
                }
            }
            
            // Monk passive heal
            if (this.player.charDef.title === 'Monk') {
                this.player.regenTimer += dt;
                if (this.player.regenTimer >= 5) {
                    this.player.hp = Math.min(this.player.maxHp, this.player.hp + 10);
                    this.player.regenTimer = 0;
                }
            }
            
            // Update HUD
            this.updateHUD();
        }
        
        updatePlayer(dt) {
            // Movement
            let dx = 0, dy = 0;
            
            if (this.keys['KeyW'] || this.keys['ArrowUp']) dy -= 1;
            if (this.keys['KeyS'] || this.keys['ArrowDown']) dy += 1;
            if (this.keys['KeyA'] || this.keys['ArrowLeft']) dx -= 1;
            if (this.keys['KeyD'] || this.keys['ArrowRight']) dx += 1;
            
            // Joystick input
            if (Math.abs(this.joystick.x) > 0.1 || Math.abs(this.joystick.y) > 0.1) {
                dx = this.joystick.x;
                dy = this.joystick.y;
            }
            
            // Normalize
            const mag = Math.sqrt(dx*dx + dy*dy);
            if (mag > 0) {
                dx /= mag;
                dy /= mag;
                this.player.isMoving = true;
                if (dx !== 0) this.player.facingRight = dx > 0;
            } else {
                this.player.isMoving = false;
            }
            
            this.player.x += dx * this.player.speed * dt;
            this.player.y += dy * this.player.speed * dt;
            
            // Animation
            this.player.frameTime += dt;
            if (this.player.frameTime >= 0.1) {
                this.player.frame++;
                this.player.frameTime = 0;
            }
            
            // Auto attack nearest enemy
            this.player.attackCooldown -= dt;
            if (this.player.attackCooldown <= 0) {
                const target = this.findNearestEnemy();
                if (target) {
                    const dist = this.distance(this.player, target);
                    if (dist <= this.player.attackRange) {
                        this.attackEnemy(target);
                        this.player.attackCooldown = 1 / this.player.attackSpeed;
                        this.player.isAttacking = true;
                        setTimeout(() => this.player.isAttacking = false, 200);
                    } else if (this.player.charDef.title === 'Archer' && dist <= 300) {
                        // Archer shoots projectile
                        this.shootProjectile(target);
                        this.player.attackCooldown = 1 / this.player.attackSpeed;
                    }
                }
            }
        }
        
        findNearestEnemy() {
            let nearest = null;
            let minDist = Infinity;
            
            const allEnemies = this.boss ? [...this.enemies, this.boss] : this.enemies;
            
            for (const enemy of allEnemies) {
                const dist = this.distance(this.player, enemy);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = enemy;
                }
            }
            return nearest;
        }
        
        distance(a, b) {
            const dx = a.x - b.x;
            const dy = a.y - b.y;
            return Math.sqrt(dx*dx + dy*dy);
        }
        
        attackEnemy(enemy) {
            let damage = this.player.damage;
            let isCrit = false;
            
            if (Math.random() < this.player.crit) {
                damage *= 2;
                isCrit = true;
            }
            
            enemy.hp -= damage;
            this.damageNumbers.push({
                x: enemy.x,
                y: enemy.y - 30,
                text: Math.floor(damage),
                color: isCrit ? '#ffff00' : '#ffffff',
                life: 0.8
            });
            
            if (enemy.hp <= 0) {
                this.killEnemy(enemy);
            }
        }
        
        shootProjectile(target) {
            const angle = Math.atan2(target.y - this.player.y, target.x - this.player.x);
            this.projectiles.push({
                x: this.player.x,
                y: this.player.y,
                vx: Math.cos(angle) * 400,
                vy: Math.sin(angle) * 400,
                damage: this.player.damage,
                life: 2
            });
        }
        
        updateProjectiles(dt) {
            for (let i = this.projectiles.length - 1; i >= 0; i--) {
                const p = this.projectiles[i];
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.life -= dt;
                
                if (p.life <= 0) {
                    this.projectiles.splice(i, 1);
                    continue;
                }
                
                // Check collision with enemies
                const allEnemies = this.boss ? [...this.enemies, this.boss] : this.enemies;
                for (const enemy of allEnemies) {
                    if (this.distance(p, enemy) < 30) {
                        enemy.hp -= p.damage;
                        this.damageNumbers.push({
                            x: enemy.x,
                            y: enemy.y - 30,
                            text: Math.floor(p.damage),
                            color: '#ffffff',
                            life: 0.8
                        });
                        if (enemy.hp <= 0) {
                            this.killEnemy(enemy);
                        }
                        this.projectiles.splice(i, 1);
                        break;
                    }
                }
            }
        }
        
        killEnemy(enemy) {
            if (enemy === this.boss) {
                this.gameOver(true);
                return;
            }
            
            const idx = this.enemies.indexOf(enemy);
            if (idx !== -1) {
                this.enemies.splice(idx, 1);
            }
            
            this.kills++;
            document.getElementById('killText').textContent = this.kills;
            
            // Drop gold
            const goldAmount = Math.floor(enemy.def.gold * (1 + this.player.goldBonus));
            this.gold += goldAmount;
            document.getElementById('goldText').textContent = this.gold;
            
            // Give XP
            this.xp += enemy.def.xp;
            if (this.xp >= this.xpToNext) {
                this.levelUp();
            }
        }
        
        levelUp() {
            this.xp -= this.xpToNext;
            this.level++;
            this.xpToNext = CONFIG.XP_PER_LEVEL[Math.min(this.level - 1, CONFIG.XP_PER_LEVEL.length - 1)];
            document.getElementById('levelText').textContent = `Lv.${this.level}`;
            
            // Show upgrade modal
            this.showUpgradeModal();
        }
        
        showUpgradeModal() {
            this.state = 'paused';
            const modal = document.getElementById('levelUpModal');
            const options = document.getElementById('upgradeOptions');
            options.innerHTML = '';
            
            // Pick 3 random upgrades
            const upgradeKeys = Object.keys(UPGRADES);
            const chosen = [];
            while (chosen.length < 3) {
                const key = upgradeKeys[Math.floor(Math.random() * upgradeKeys.length)];
                if (!chosen.includes(key)) chosen.push(key);
            }
            
            for (const key of chosen) {
                const upgrade = UPGRADES[key];
                const card = document.createElement('div');
                card.className = 'upgrade-card';
                card.innerHTML = `
                    <div class="upgrade-icon">${upgrade.name.split(' ')[0]}</div>
                    <div class="upgrade-name">${upgrade.name.split(' ').slice(1).join(' ')}</div>
                    <div class="upgrade-desc">${upgrade.desc}</div>
                `;
                card.onclick = () => this.selectUpgrade(key);
                options.appendChild(card);
            }
            
            modal.style.display = 'flex';
        }
        
        selectUpgrade(key) {
            const upgrade = UPGRADES[key];
            
            switch (upgrade.stat) {
                case 'damage':
                    this.player.damage *= (1 + upgrade.value);
                    break;
                case 'speed':
                    this.player.speed *= (1 + upgrade.value);
                    break;
                case 'attackSpeed':
                    this.player.attackSpeed *= (1 + upgrade.value);
                    break;
                case 'maxHp':
                    this.player.maxHp += upgrade.value;
                    this.player.hp += upgrade.value;
                    break;
                case 'range':
                    this.player.attackRange *= (1 + upgrade.value);
                    break;
                case 'regen':
                    this.player.regen += upgrade.value;
                    break;
                case 'crit':
                    this.player.crit += upgrade.value;
                    break;
                case 'goldBonus':
                    this.player.goldBonus += upgrade.value;
                    break;
            }
            
            document.getElementById('levelUpModal').style.display = 'none';
            this.state = 'playing';
        }
        
        updateEnemies(dt) {
            for (const enemy of this.enemies) {
                // Move towards player
                const dx = this.player.x - enemy.x;
                const dy = this.player.y - enemy.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist > 30) {
                    enemy.x += (dx / dist) * enemy.speed * dt;
                    enemy.y += (dy / dist) * enemy.speed * dt;
                    enemy.facingRight = dx > 0;
                }
                
                // Attack player
                if (dist < 40) {
                    enemy.attackTimer -= dt;
                    if (enemy.attackTimer <= 0) {
                        this.player.hp -= enemy.damage;
                        enemy.attackTimer = 1;
                        this.damageNumbers.push({
                            x: this.player.x,
                            y: this.player.y - 30,
                            text: Math.floor(enemy.damage),
                            color: '#ff4444',
                            life: 0.8
                        });
                    }
                }
                
                // Animation
                enemy.frameTime += dt;
                if (enemy.frameTime >= 0.12) {
                    enemy.frame++;
                    enemy.frameTime = 0;
                }
            }
            
            // Update boss
            if (this.boss) {
                const dx = this.player.x - this.boss.x;
                const dy = this.player.y - this.boss.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist > 50) {
                    this.boss.x += (dx / dist) * this.boss.speed * dt;
                    this.boss.y += (dy / dist) * this.boss.speed * dt;
                    this.boss.facingRight = dx > 0;
                }
                
                if (dist < 60) {
                    this.boss.attackTimer -= dt;
                    if (this.boss.attackTimer <= 0) {
                        this.player.hp -= this.boss.damage;
                        this.boss.attackTimer = 1.5;
                        this.damageNumbers.push({
                            x: this.player.x,
                            y: this.player.y - 30,
                            text: Math.floor(this.boss.damage),
                            color: '#ff0000',
                            life: 0.8
                        });
                    }
                }
                
                this.boss.frameTime += dt;
                if (this.boss.frameTime >= 0.15) {
                    this.boss.frame++;
                    this.boss.frameTime = 0;
                }
            }
        }
        
        spawnEnemy() {
            // Determine which enemies can spawn based on time
            const available = Object.entries(ENEMIES).filter(([k, e]) => this.gameTime >= e.appearsAfter);
            if (available.length === 0) return;
            
            // Pick random enemy type (weighted towards newer ones)
            const [key, def] = available[Math.floor(Math.random() * available.length)];
            
            // Spawn at edge of screen
            const angle = Math.random() * Math.PI * 2;
            const dist = 500 + Math.random() * 200;
            
            const enemy = {
                x: this.player.x + Math.cos(angle) * dist,
                y: this.player.y + Math.sin(angle) * dist,
                hp: CONFIG.ENEMY_BASE_HP * def.hp * (1 + this.gameTime / 300),
                maxHp: CONFIG.ENEMY_BASE_HP * def.hp * (1 + this.gameTime / 300),
                damage: CONFIG.ENEMY_BASE_DMG * def.damage * (1 + this.gameTime / 400),
                speed: CONFIG.ENEMY_BASE_SPEED * def.speed,
                def: def,
                key: key,
                frame: 0,
                frameTime: 0,
                facingRight: true,
                attackTimer: 1
            };
            
            this.enemies.push(enemy);
        }
        
        spawnBoss() {
            this.bossSpawned = true;
            
            // Show warning
            const warning = document.getElementById('bossWarning');
            warning.style.display = 'block';
            setTimeout(() => warning.style.display = 'none', 3000);
            
            // Clear most enemies
            this.enemies = this.enemies.slice(0, 10);
            
            // Spawn boss
            const angle = Math.random() * Math.PI * 2;
            this.boss = {
                x: this.player.x + Math.cos(angle) * 600,
                y: this.player.y + Math.sin(angle) * 600,
                hp: BOSS.hp,
                maxHp: BOSS.hp,
                damage: BOSS.damage,
                speed: BOSS.speed,
                frame: 0,
                frameTime: 0,
                facingRight: true,
                attackTimer: 1.5
            };
        }
        
        updatePickups(dt) {
            // Pickups are automatically collected
            for (let i = this.pickups.length - 1; i >= 0; i--) {
                const pickup = this.pickups[i];
                const dist = this.distance(this.player, pickup);
                if (dist < 50) {
                    // Collect
                    if (pickup.type === 'gold') {
                        this.gold += pickup.value;
                        document.getElementById('goldText').textContent = this.gold;
                    } else if (pickup.type === 'hp') {
                        this.player.hp = Math.min(this.player.maxHp, this.player.hp + pickup.value);
                    }
                    this.pickups.splice(i, 1);
                }
            }
        }
        
        updateHUD() {
            const hpPercent = (this.player.hp / this.player.maxHp) * 100;
            document.getElementById('healthBar').style.width = `${hpPercent}%`;
            document.getElementById('healthText').textContent = `${Math.floor(this.player.hp)}/${this.player.maxHp}`;
            
            const xpPercent = (this.xp / this.xpToNext) * 100;
            document.getElementById('xpBar').style.width = `${xpPercent}%`;
            document.getElementById('xpText').textContent = `${this.xp}/${this.xpToNext}`;
        }
        
        gameOver(victory) {
            this.state = 'gameover';
            
            const screen = document.getElementById('gameOverScreen');
            const title = document.getElementById('gameOverTitle');
            const stats = document.getElementById('finalStats');
            
            if (victory) {
                title.textContent = 'üéâ ÿßŸÜÿ™ÿµÿßÿ±! üéâ';
                title.classList.add('victory-title');
            } else {
                title.textContent = 'üíÄ ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑŸÑÿπÿ®ÿ© üíÄ';
                title.classList.remove('victory-title');
            }
            
            const mins = Math.floor(this.gameTime / 60);
            const secs = Math.floor(this.gameTime % 60);
            
            stats.innerHTML = `
                <div>‚è±Ô∏è ÿßŸÑŸàŸÇÿ™: ${mins}:${secs.toString().padStart(2, '0')}</div>
                <div>üíÄ ÿßŸÑŸÇÿ™ŸÑŸâ: ${this.kills}</div>
                <div>ü™ô ÿßŸÑÿ∞Ÿáÿ®: ${this.gold}</div>
                <div>üìä ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ: ${this.level}</div>
            `;
            
            screen.style.display = 'flex';
            document.getElementById('hud').style.display = 'none';
            document.getElementById('hudStats').style.display = 'none';
            document.getElementById('pauseBtn').style.display = 'none';
        }
        
        render() {
            this.ctx.fillStyle = '#2d5a27';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            
            if (this.state === 'menu') return;
            
            this.ctx.save();
            this.ctx.translate(-this.camera.x, -this.camera.y);
            
            // Draw ground pattern
            this.drawGround();
            
            // Draw pickups
            for (const pickup of this.pickups) {
                this.ctx.fillStyle = pickup.type === 'gold' ? '#ffd700' : '#ff4444';
                this.ctx.beginPath();
                this.ctx.arc(pickup.x, pickup.y, 8, 0, Math.PI * 2);
                this.ctx.fill();
            }
            
            // Draw enemies
            for (const enemy of this.enemies) {
                this.drawEnemy(enemy);
            }
            
            // Draw boss
            if (this.boss) {
                this.drawBoss();
            }
            
            // Draw projectiles
            this.ctx.fillStyle = '#ffff00';
            for (const p of this.projectiles) {
                this.ctx.beginPath();
                this.ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                this.ctx.fill();
            }
            
            // Draw player
            this.drawPlayer();
            
            // Draw damage numbers
            for (const d of this.damageNumbers) {
                this.ctx.fillStyle = d.color;
                this.ctx.font = 'bold 16px Cairo';
                this.ctx.textAlign = 'center';
                this.ctx.globalAlpha = d.life;
                this.ctx.fillText(d.text, d.x, d.y);
                this.ctx.globalAlpha = 1;
            }
            
            this.ctx.restore();
            
            // Draw boss health bar
            if (this.boss) {
                this.drawBossHealthBar();
            }
            
            // Draw pause overlay
            if (this.state === 'paused' && document.getElementById('levelUpModal').style.display !== 'flex') {
                this.ctx.fillStyle = 'rgba(0,0,0,0.7)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = '#ffd700';
                this.ctx.font = 'bold 48px Cairo';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('‚è∏Ô∏è ÿ•ŸäŸÇÿßŸÅ ŸÖÿ§ŸÇÿ™', this.canvas.width / 2, this.canvas.height / 2);
            }
        }
        
        drawGround() {
            // Simple grid pattern
            const gridSize = 64;
            const startX = Math.floor(this.camera.x / gridSize) * gridSize;
            const startY = Math.floor(this.camera.y / gridSize) * gridSize;
            
            for (let x = startX; x < this.camera.x + this.canvas.width + gridSize; x += gridSize) {
                for (let y = startY; y < this.camera.y + this.canvas.height + gridSize; y += gridSize) {
                    const isEven = ((x / gridSize) + (y / gridSize)) % 2 === 0;
                    this.ctx.fillStyle = isEven ? '#3d7a3d' : '#2d5a27';
                    this.ctx.fillRect(x, y, gridSize, gridSize);
                }
            }
        }
        
        drawPlayer() {
            const p = this.player;
            const char = p.charDef;
            
            let spriteKey = p.isMoving ? `${p.charKey}_run` : `${p.charKey}_idle`;
            const sprite = this.assets.get(spriteKey);
            
            if (!sprite) {
                // Fallback circle
                this.ctx.fillStyle = '#4488ff';
                this.ctx.beginPath();
                this.ctx.arc(p.x, p.y, 24, 0, Math.PI * 2);
                this.ctx.fill();
                return;
            }
            
            const frameCount = p.isMoving ? char.runFrames : char.idleFrames;
            const frameIdx = p.frame % frameCount;
            const frameSize = char.frameSize;
            
            this.ctx.save();
            this.ctx.translate(p.x, p.y);
            if (!p.facingRight) {
                this.ctx.scale(-1, 1);
            }
            
            const drawSize = 64;
            this.ctx.drawImage(
                sprite,
                frameIdx * frameSize, 0, frameSize, frameSize,
                -drawSize/2, -drawSize/2, drawSize, drawSize
            );
            
            this.ctx.restore();
        }
        
        drawEnemy(enemy) {
            const def = enemy.def;
            
            let spriteKey = `${enemy.key}_run`;
            let sprite = this.assets.get(spriteKey);
            if (!sprite) {
                spriteKey = `${enemy.key}_walk`;
                sprite = this.assets.get(spriteKey);
            }
            if (!sprite) {
                spriteKey = `${enemy.key}_idle`;
                sprite = this.assets.get(spriteKey);
            }
            
            if (!sprite) {
                // Fallback circle
                this.ctx.fillStyle = '#ff4444';
                this.ctx.beginPath();
                this.ctx.arc(enemy.x, enemy.y, 20, 0, Math.PI * 2);
                this.ctx.fill();
                return;
            }
            
            const frameCount = def.runFrames || def.walkFrames || def.idleFrames || 6;
            const frameIdx = enemy.frame % frameCount;
            const frameSize = def.frameSize;
            
            this.ctx.save();
            this.ctx.translate(enemy.x, enemy.y);
            if (!enemy.facingRight) {
                this.ctx.scale(-1, 1);
            }
            
            const drawSize = 48;
            this.ctx.drawImage(
                sprite,
                frameIdx * frameSize, 0, frameSize, frameSize,
                -drawSize/2, -drawSize/2, drawSize, drawSize
            );
            
            this.ctx.restore();
            
            // Health bar
            const hpPercent = enemy.hp / enemy.maxHp;
            this.ctx.fillStyle = '#000';
            this.ctx.fillRect(enemy.x - 20, enemy.y - 35, 40, 6);
            this.ctx.fillStyle = '#ff4444';
            this.ctx.fillRect(enemy.x - 19, enemy.y - 34, 38 * hpPercent, 4);
        }
        
        drawBoss() {
            const b = this.boss;
            const sprite = this.assets.get('minotaur_idle') || this.assets.get('minotaur_walk');
            
            if (!sprite) {
                this.ctx.fillStyle = '#8b0000';
                this.ctx.beginPath();
                this.ctx.arc(b.x, b.y, 50, 0, Math.PI * 2);
                this.ctx.fill();
                return;
            }
            
            const frameCount = 6;
            const frameIdx = b.frame % frameCount;
            const frameSize = 192;
            
            this.ctx.save();
            this.ctx.translate(b.x, b.y);
            if (!b.facingRight) {
                this.ctx.scale(-1, 1);
            }
            
            const drawSize = 128;
            this.ctx.drawImage(
                sprite,
                frameIdx * frameSize, 0, frameSize, frameSize,
                -drawSize/2, -drawSize/2, drawSize, drawSize
            );
            
            this.ctx.restore();
        }
        
        drawBossHealthBar() {
            const b = this.boss;
            const hpPercent = b.hp / b.maxHp;
            
            const barWidth = 400;
            const barHeight = 20;
            const x = (this.canvas.width - barWidth) / 2;
            const y = 60;
            
            // Background
            this.ctx.fillStyle = '#000';
            this.ctx.fillRect(x - 2, y - 2, barWidth + 4, barHeight + 4);
            
            // Health
            this.ctx.fillStyle = '#8b0000';
            this.ctx.fillRect(x, y, barWidth * hpPercent, barHeight);
            
            // Text
            this.ctx.fillStyle = '#fff';
            this.ctx.font = 'bold 14px Cairo';
            this.ctx.textAlign = 'center';
            this.ctx.fillText(`${BOSS.name} - ${Math.floor(b.hp)}/${b.maxHp}`, this.canvas.width / 2, y + 15);
        }
    }
    
    // ==================== START GAME ====================
    const game = new Game();
    game.init();
    </script>
</body>
</html>
