<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>‚öîÔ∏è Tiny Swords - ŸÖÿπÿ±ŸÉÿ© ÿßŸÑÿ≥ŸäŸàŸÅ ‚öîÔ∏è</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
        body { 
            background: #1a3d1a; 
            overflow: hidden; 
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, sans-serif;
        }
        #gameCanvas { 
            display: block; 
            position: absolute; 
            top: 0; left: 0;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        /* Loading Screen */
        #loadingScreen {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: #1a3d1a;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: #fff;
            font-size: 1.5rem;
        }
        .loading-bar {
            width: 300px;
            height: 30px;
            background: #0a1a0a;
            border: 3px solid #3d6d3d;
            margin-top: 20px;
            overflow: hidden;
        }
        .loading-fill {
            height: 100%;
            background: linear-gradient(90deg, #4a8a4a, #6aba6a);
            width: 0%;
            transition: width 0.3s;
        }
        
        /* All UI is rendered on canvas */
        #mainMenu, #hud, #levelUpModal, #gameOverScreen {
            display: none;
        }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <div>‚öîÔ∏è ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ... ‚öîÔ∏è</div>
        <div class="loading-bar">
            <div class="loading-fill" id="loadingFill"></div>
        </div>
        <div id="loadingText" style="margin-top:10px;font-size:1rem">0%</div>
    </div>
    <canvas id="gameCanvas"></canvas>

<script>
// ==================== TINY SWORDS GAME ====================
// Complete rewrite using all Tiny Swords assets properly

const PATHS = {
    base: 'assets/Tiny Swords Free Pack/Tiny Swords (Free Pack)/',
    enemies: 'assets/New enemy/Tiny Swords Enemy Pack/Tiny Swords (Enemy Pack)/Enemy Pack/',
    update: 'assets/Tiny Swords/Tiny Swords (Update 010)/'
};

// ==================== ASSET MANAGER ====================
class AssetManager {
    constructor() {
        this.images = {};
        this.loaded = 0;
        this.total = 0;
    }
    
    async load(name, path) {
        this.total++;
        return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => {
                this.images[name] = img;
                this.loaded++;
                this.updateProgress();
                resolve(img);
            };
            img.onerror = () => {
                console.warn('Failed:', path);
                this.loaded++;
                this.updateProgress();
                resolve(null);
            };
            img.src = path;
        });
    }
    
    updateProgress() {
        const pct = Math.floor((this.loaded / this.total) * 100);
        document.getElementById('loadingFill').style.width = pct + '%';
        document.getElementById('loadingText').textContent = pct + '%';
    }
    
    get(name) {
        return this.images[name];
    }
    
    async loadAll() {
        const p = [];
        
        // Terrain
        p.push(this.load('tilemap', PATHS.base + 'Terrain/Tileset/Tilemap_color1.png'));
        p.push(this.load('tilemap2', PATHS.base + 'Terrain/Tileset/Tilemap_color2.png'));
        p.push(this.load('shadow', PATHS.base + 'Terrain/Tileset/Shadow.png'));
        p.push(this.load('water', PATHS.base + 'Terrain/Tileset/Water Foam.png'));
        
        // Decorations
        for (let i = 1; i <= 4; i++) {
            p.push(this.load('tree' + i, PATHS.base + 'Terrain/Resources/Wood/Trees/Tree' + i + '.png'));
            p.push(this.load('bush' + i, PATHS.base + 'Terrain/Decorations/Bushes/Bushe' + i + '.png'));
            p.push(this.load('rock' + i, PATHS.base + 'Terrain/Decorations/Rocks/Rock' + i + '.png'));
        }
        
        // Resources
        p.push(this.load('gold', PATHS.base + 'Terrain/Resources/Gold/Gold Resource/Gold_Resource.png'));
        p.push(this.load('meat', PATHS.base + 'Terrain/Resources/Meat/Meat Resource/Meat Resource.png'));
        
        // Buildings
        p.push(this.load('castle', PATHS.base + 'Buildings/Blue Buildings/Castle.png'));
        p.push(this.load('tower', PATHS.base + 'Buildings/Blue Buildings/Tower.png'));
        p.push(this.load('house1', PATHS.base + 'Buildings/Blue Buildings/House1.png'));
        p.push(this.load('house2', PATHS.base + 'Buildings/Blue Buildings/House2.png'));
        
        // UI Elements
        p.push(this.load('ui_bar_base', PATHS.base + 'UI Elements/UI Elements/Bars/BigBar_Base.png'));
        p.push(this.load('ui_bar_fill', PATHS.base + 'UI Elements/UI Elements/Bars/BigBar_Fill.png'));
        p.push(this.load('ui_bar_small_base', PATHS.base + 'UI Elements/UI Elements/Bars/SmallBar_Base.png'));
        p.push(this.load('ui_bar_small_fill', PATHS.base + 'UI Elements/UI Elements/Bars/SmallBar_Fill.png'));
        p.push(this.load('ui_banner', PATHS.base + 'UI Elements/UI Elements/Banners/Banner.png'));
        p.push(this.load('ui_btn_blue', PATHS.base + 'UI Elements/UI Elements/Buttons/BigBlueButton_Regular.png'));
        p.push(this.load('ui_btn_blue_pressed', PATHS.base + 'UI Elements/UI Elements/Buttons/BigBlueButton_Pressed.png'));
        p.push(this.load('ui_btn_red', PATHS.base + 'UI Elements/UI Elements/Buttons/BigRedButton_Regular.png'));
        p.push(this.load('ui_wood_table', PATHS.base + 'UI Elements/UI Elements/Wood Table/WoodTable.png'));
        p.push(this.load('ui_ribbon', PATHS.base + 'UI Elements/UI Elements/Ribbons/BigRibbons.png'));
        p.push(this.load('ui_swords', PATHS.base + 'UI Elements/UI Elements/Swords/Swords.png'));
        
        // Icons
        for (let i = 1; i <= 12; i++) {
            const num = i.toString().padStart(2, '0');
            p.push(this.load('icon_' + i, PATHS.base + 'UI Elements/UI Elements/Icons/Icon_' + num + '.png'));
        }
        
        // Avatars
        for (let i = 1; i <= 10; i++) {
            const num = i.toString().padStart(2, '0');
            p.push(this.load('avatar_' + i, PATHS.base + 'UI Elements/UI Elements/Human Avatars/Avatars_' + num + '.png'));
        }
        
        // Particle FX
        p.push(this.load('fx_explosion1', PATHS.base + 'Particle FX/Explosion_01.png'));
        p.push(this.load('fx_explosion2', PATHS.base + 'Particle FX/Explosion_02.png'));
        p.push(this.load('fx_fire1', PATHS.base + 'Particle FX/Fire_01.png'));
        p.push(this.load('fx_dust1', PATHS.base + 'Particle FX/Dust_01.png'));
        
        // Characters - Blue
        p.push(this.load('warrior_idle', PATHS.base + 'Units/Blue Units/Warrior/Warrior_Idle.png'));
        p.push(this.load('warrior_run', PATHS.base + 'Units/Blue Units/Warrior/Warrior_Run.png'));
        p.push(this.load('warrior_attack', PATHS.base + 'Units/Blue Units/Warrior/Warrior_Attack1.png'));
        p.push(this.load('archer_idle', PATHS.base + 'Units/Blue Units/Archer/Archer_Idle.png'));
        p.push(this.load('archer_run', PATHS.base + 'Units/Blue Units/Archer/Archer_Run.png'));
        p.push(this.load('archer_attack', PATHS.base + 'Units/Blue Units/Archer/Archer_Shoot.png'));
        p.push(this.load('arrow', PATHS.base + 'Units/Blue Units/Archer/Arrow.png'));
        
        // Characters - Yellow
        p.push(this.load('lancer_idle', PATHS.base + 'Units/Yellow Units/Lancer/Lancer_Idle.png'));
        p.push(this.load('lancer_run', PATHS.base + 'Units/Yellow Units/Lancer/Lancer_Run.png'));
        p.push(this.load('pawn_idle', PATHS.base + 'Units/Yellow Units/Pawn/Pawn_Idle.png'));
        p.push(this.load('pawn_run', PATHS.base + 'Units/Yellow Units/Pawn/Pawn_Run.png'));
        
        // Enemies
        const enemies = ['Skull', 'Spider', 'Snake', 'Gnome', 'Lizard', 'Thief', 'Gnoll', 'Bear', 'Panda', 'Troll', 'Minotaur', 'Turtle'];
        for (const e of enemies) {
            const key = e.toLowerCase();
            p.push(this.load(key + '_idle', PATHS.enemies + e + '/' + e + '_Idle.png'));
            p.push(this.load(key + '_run', PATHS.enemies + e + '/' + e + '_Run.png'));
            p.push(this.load(key + '_walk', PATHS.enemies + e + '/' + e + '_Walk.png'));
            p.push(this.load(key + '_attack', PATHS.enemies + e + '/' + e + '_Attack.png'));
        }
        
        await Promise.all(p);
        console.log(`Loaded ${this.loaded}/${this.total} assets`);
    }
}

// ==================== GAME ====================
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.assets = new AssetManager();
        
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        // Game state
        this.state = 'loading'; // loading, menu, playing, levelup, gameover
        this.selectedChar = 0;
        
        // World
        this.worldSize = 3000;
        this.camera = { x: 0, y: 0 };
        this.decorations = [];
        
        // Player
        this.player = null;
        
        // Entities
        this.enemies = [];
        this.projectiles = [];
        this.pickups = [];
        this.effects = [];
        this.damageNumbers = [];
        
        // Stats
        this.kills = 0;
        this.gold = 0;
        this.gameTime = 0;
        this.level = 1;
        this.xp = 0;
        this.xpToNext = 15;
        
        // Timers
        this.spawnTimer = 0;
        this.bossSpawned = false;
        this.boss = null;
        
        // Input
        this.keys = {};
        this.mouse = { x: 0, y: 0, down: false };
        this.touch = { active: false, startX: 0, startY: 0, x: 0, y: 0 };
        this.joystick = { x: 0, y: 0 };
        
        // Menu state
        this.menuButtons = [];
        this.hoveredButton = null;
        
        this.setupInput();
    }
    
    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.ctx.imageSmoothingEnabled = false;
    }
    
    setupInput() {
        window.addEventListener('keydown', e => this.keys[e.code] = true);
        window.addEventListener('keyup', e => this.keys[e.code] = false);
        
        this.canvas.addEventListener('mousemove', e => {
            this.mouse.x = e.clientX;
            this.mouse.y = e.clientY;
        });
        
        this.canvas.addEventListener('mousedown', e => {
            this.mouse.down = true;
            this.handleClick(e.clientX, e.clientY);
        });
        
        this.canvas.addEventListener('mouseup', () => this.mouse.down = false);
        
        this.canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            const t = e.touches[0];
            this.touch.active = true;
            this.touch.startX = t.clientX;
            this.touch.startY = t.clientY;
            this.handleClick(t.clientX, t.clientY);
        });
        
        this.canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if (this.touch.active && this.state === 'playing') {
                const t = e.touches[0];
                const dx = t.clientX - this.touch.startX;
                const dy = t.clientY - this.touch.startY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist > 15) {
                    this.joystick.x = Math.max(-1, Math.min(1, dx / 60));
                    this.joystick.y = Math.max(-1, Math.min(1, dy / 60));
                }
            }
        });
        
        this.canvas.addEventListener('touchend', e => {
            e.preventDefault();
            this.touch.active = false;
            this.joystick.x = 0;
            this.joystick.y = 0;
        });
    }
    
    handleClick(x, y) {
        if (this.state === 'menu') {
            // Check buttons
            for (const btn of this.menuButtons) {
                if (x >= btn.x && x <= btn.x + btn.w && y >= btn.y && y <= btn.y + btn.h) {
                    if (btn.action) btn.action();
                    return;
                }
            }
        } else if (this.state === 'levelup') {
            // Check upgrade cards
            for (const card of this.upgradeCards || []) {
                if (x >= card.x && x <= card.x + card.w && y >= card.y && y <= card.y + card.h) {
                    this.selectUpgrade(card.upgrade);
                    return;
                }
            }
        } else if (this.state === 'gameover') {
            // Check restart button
            const btn = this.restartButton;
            if (btn && x >= btn.x && x <= btn.x + btn.w && y >= btn.y && y <= btn.y + btn.h) {
                this.state = 'menu';
            }
        }
    }
    
    async init() {
        await this.assets.loadAll();
        document.getElementById('loadingScreen').style.display = 'none';
        this.generateDecorations();
        this.state = 'menu';
        this.lastTime = performance.now();
        this.gameLoop();
    }
    
    generateDecorations() {
        this.decorations = [];
        const area = this.worldSize;
        
        // Trees
        for (let i = 0; i < 50; i++) {
            this.decorations.push({
                type: 'tree',
                variant: Math.floor(Math.random() * 4) + 1,
                x: (Math.random() - 0.5) * area * 1.8,
                y: (Math.random() - 0.5) * area * 1.8,
                frame: Math.floor(Math.random() * 4)
            });
        }
        
        // Bushes
        for (let i = 0; i < 80; i++) {
            this.decorations.push({
                type: 'bush',
                variant: Math.floor(Math.random() * 4) + 1,
                x: (Math.random() - 0.5) * area * 1.8,
                y: (Math.random() - 0.5) * area * 1.8,
                frame: Math.floor(Math.random() * 8)
            });
        }
        
        // Rocks
        for (let i = 0; i < 40; i++) {
            this.decorations.push({
                type: 'rock',
                variant: Math.floor(Math.random() * 4) + 1,
                x: (Math.random() - 0.5) * area * 1.8,
                y: (Math.random() - 0.5) * area * 1.8
            });
        }
        
        // Sort by Y for depth
        this.decorations.sort((a, b) => a.y - b.y);
    }
    
    gameLoop() {
        const now = performance.now();
        const dt = Math.min((now - this.lastTime) / 1000, 0.1);
        this.lastTime = now;
        
        this.update(dt);
        this.render();
        
        requestAnimationFrame(() => this.gameLoop());
    }
    
    update(dt) {
        if (this.state === 'playing') {
            this.gameTime += dt;
            this.updatePlayer(dt);
            this.updateEnemies(dt);
            this.updateProjectiles(dt);
            this.updatePickups(dt);
            this.updateEffects(dt);
            this.spawnEnemies(dt);
            
            // Update camera
            this.camera.x = this.player.x - this.canvas.width / 2;
            this.camera.y = this.player.y - this.canvas.height / 2;
            
            // Update damage numbers
            this.damageNumbers = this.damageNumbers.filter(d => {
                d.life -= dt;
                d.y -= 40 * dt;
                return d.life > 0;
            });
            
            // Check boss spawn
            if (this.gameTime >= 540 && !this.bossSpawned) {
                this.spawnBoss();
            }
            
            // Check death
            if (this.player.hp <= 0) {
                this.gameOver(false);
            }
        }
    }
    
    // ==================== PLAYER ====================
    startGame() {
        const chars = [
            { key: 'warrior', name: 'ÿßŸÑŸÖÿ≠ÿßÿ±ÿ®', hp: 120, dmg: 12, spd: 200, range: 60, atkSpd: 1.0, avatar: 1, type: 'melee' },
            { key: 'archer', name: 'ÿßŸÑÿ±ÿßŸÖŸä', hp: 80, dmg: 15, spd: 220, range: 300, atkSpd: 0.8, avatar: 3, type: 'ranged' },
            { key: 'lancer', name: 'ÿßŸÑÿ±ŸÖŸëÿßÿ≠', hp: 100, dmg: 14, spd: 210, range: 80, atkSpd: 0.9, avatar: 5, type: 'melee' },
            { key: 'pawn', name: 'ÿßŸÑÿπÿßŸÖŸÑ', hp: 90, dmg: 8, spd: 250, range: 50, atkSpd: 1.2, avatar: 7, type: 'melee', goldBonus: 0.5 }
        ];
        
        const c = chars[this.selectedChar];
        this.player = {
            x: 0, y: 0,
            hp: c.hp, maxHp: c.hp,
            damage: c.dmg,
            speed: c.spd,
            range: c.range,
            attackSpeed: c.atkSpd,
            attackCooldown: 0,
            key: c.key,
            name: c.name,
            avatar: c.avatar,
            type: c.type,
            goldBonus: c.goldBonus || 0,
            crit: 0,
            regen: 0,
            regenTimer: 0,
            frame: 0,
            frameTime: 0,
            facingRight: true,
            isMoving: false,
            isAttacking: false
        };
        
        this.enemies = [];
        this.projectiles = [];
        this.pickups = [];
        this.effects = [];
        this.damageNumbers = [];
        this.kills = 0;
        this.gold = 0;
        this.gameTime = 0;
        this.level = 1;
        this.xp = 0;
        this.xpToNext = 15;
        this.bossSpawned = false;
        this.boss = null;
        this.spawnTimer = 0;
        
        this.state = 'playing';
    }
    
    updatePlayer(dt) {
        // Movement
        let dx = 0, dy = 0;
        if (this.keys['KeyW'] || this.keys['ArrowUp']) dy -= 1;
        if (this.keys['KeyS'] || this.keys['ArrowDown']) dy += 1;
        if (this.keys['KeyA'] || this.keys['ArrowLeft']) dx -= 1;
        if (this.keys['KeyD'] || this.keys['ArrowRight']) dx += 1;
        
        if (Math.abs(this.joystick.x) > 0.1 || Math.abs(this.joystick.y) > 0.1) {
            dx = this.joystick.x;
            dy = this.joystick.y;
        }
        
        const mag = Math.sqrt(dx*dx + dy*dy);
        if (mag > 0) {
            dx /= mag; dy /= mag;
            this.player.isMoving = true;
            if (dx !== 0) this.player.facingRight = dx > 0;
        } else {
            this.player.isMoving = false;
        }
        
        this.player.x += dx * this.player.speed * dt;
        this.player.y += dy * this.player.speed * dt;
        
        // Clamp to world
        const half = this.worldSize / 2;
        this.player.x = Math.max(-half, Math.min(half, this.player.x));
        this.player.y = Math.max(-half, Math.min(half, this.player.y));
        
        // Animation
        this.player.frameTime += dt;
        if (this.player.frameTime >= 0.1) {
            this.player.frame++;
            this.player.frameTime = 0;
        }
        
        // Auto attack
        this.player.attackCooldown -= dt;
        if (this.player.attackCooldown <= 0) {
            const target = this.findNearestEnemy();
            if (target) {
                const dist = this.dist(this.player, target);
                if (this.player.type === 'ranged') {
                    if (dist <= this.player.range) {
                        this.shootArrow(target);
                        this.player.attackCooldown = 1 / this.player.attackSpeed;
                    }
                } else {
                    if (dist <= this.player.range) {
                        this.meleeAttack(target);
                        this.player.attackCooldown = 1 / this.player.attackSpeed;
                    }
                }
            }
        }
        
        // Regen
        if (this.player.regen > 0) {
            this.player.regenTimer += dt;
            if (this.player.regenTimer >= 1) {
                this.player.hp = Math.min(this.player.maxHp, this.player.hp + this.player.regen);
                this.player.regenTimer = 0;
            }
        }
    }
    
    findNearestEnemy() {
        let nearest = null;
        let minDist = Infinity;
        const all = this.boss ? [...this.enemies, this.boss] : this.enemies;
        for (const e of all) {
            const d = this.dist(this.player, e);
            if (d < minDist) { minDist = d; nearest = e; }
        }
        return nearest;
    }
    
    dist(a, b) {
        return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
    }
    
    shootArrow(target) {
        const angle = Math.atan2(target.y - this.player.y, target.x - this.player.x);
        this.projectiles.push({
            x: this.player.x,
            y: this.player.y,
            vx: Math.cos(angle) * 450,
            vy: Math.sin(angle) * 450,
            damage: this.player.damage,
            life: 2,
            isArrow: true,
            angle: angle
        });
        this.player.isAttacking = true;
        setTimeout(() => this.player.isAttacking = false, 200);
    }
    
    meleeAttack(target) {
        let dmg = this.player.damage;
        let crit = Math.random() < this.player.crit;
        if (crit) dmg *= 2;
        
        target.hp -= dmg;
        this.damageNumbers.push({
            x: target.x, y: target.y - 40,
            text: Math.floor(dmg),
            color: crit ? '#ffff00' : '#ffffff',
            life: 0.8
        });
        
        // Effect
        this.effects.push({
            type: 'hit',
            x: target.x, y: target.y,
            frame: 0, frameTime: 0, life: 0.3
        });
        
        if (target.hp <= 0) this.killEnemy(target);
        
        this.player.isAttacking = true;
        setTimeout(() => this.player.isAttacking = false, 200);
    }
    
    // ==================== ENEMIES ====================
    spawnEnemies(dt) {
        this.spawnTimer += dt;
        const rate = Math.max(0.5, 2 - this.gameTime / 300);
        
        if (this.spawnTimer >= rate && this.enemies.length < 80) {
            this.spawnTimer = 0;
            
            const types = [
                { key: 'skull', hp: 20, dmg: 5, spd: 90, xp: 2, gold: 1, after: 0, size: 40 },
                { key: 'spider', hp: 15, dmg: 4, spd: 110, xp: 2, gold: 1, after: 0, size: 40 },
                { key: 'snake', hp: 25, dmg: 6, spd: 85, xp: 3, gold: 2, after: 60, size: 40 },
                { key: 'gnome', hp: 30, dmg: 7, spd: 80, xp: 3, gold: 2, after: 60, size: 40 },
                { key: 'lizard', hp: 40, dmg: 8, spd: 75, xp: 4, gold: 3, after: 120, size: 45 },
                { key: 'thief', hp: 25, dmg: 10, spd: 120, xp: 4, gold: 5, after: 180, size: 40 },
                { key: 'gnoll', hp: 50, dmg: 9, spd: 70, xp: 5, gold: 4, after: 240, size: 48 },
                { key: 'bear', hp: 80, dmg: 12, spd: 60, xp: 8, gold: 6, after: 300, size: 64 },
                { key: 'panda', hp: 70, dmg: 11, spd: 65, xp: 7, gold: 5, after: 360, size: 56 },
                { key: 'troll', hp: 100, dmg: 14, spd: 50, xp: 10, gold: 8, after: 420, size: 60 },
                { key: 'minotaur', hp: 120, dmg: 16, spd: 55, xp: 15, gold: 12, after: 480, size: 64 }
            ];
            
            const available = types.filter(t => this.gameTime >= t.after);
            const type = available[Math.floor(Math.random() * available.length)];
            
            const angle = Math.random() * Math.PI * 2;
            const dist = 500 + Math.random() * 200;
            
            const scale = 1 + this.gameTime / 400;
            
            this.enemies.push({
                x: this.player.x + Math.cos(angle) * dist,
                y: this.player.y + Math.sin(angle) * dist,
                hp: type.hp * scale,
                maxHp: type.hp * scale,
                damage: type.dmg * scale,
                speed: type.spd,
                type: type,
                frame: 0,
                frameTime: 0,
                facingRight: true,
                attackTimer: 1,
                size: type.size
            });
        }
    }
    
    updateEnemies(dt) {
        for (const e of this.enemies) {
            const dx = this.player.x - e.x;
            const dy = this.player.y - e.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if (dist > 35) {
                e.x += (dx / dist) * e.speed * dt;
                e.y += (dy / dist) * e.speed * dt;
                e.facingRight = dx > 0;
            }
            
            if (dist < 45) {
                e.attackTimer -= dt;
                if (e.attackTimer <= 0) {
                    this.player.hp -= e.damage;
                    e.attackTimer = 1;
                    this.damageNumbers.push({
                        x: this.player.x, y: this.player.y - 40,
                        text: Math.floor(e.damage),
                        color: '#ff4444',
                        life: 0.8
                    });
                }
            }
            
            e.frameTime += dt;
            if (e.frameTime >= 0.12) {
                e.frame++;
                e.frameTime = 0;
            }
        }
        
        // Boss
        if (this.boss) {
            const dx = this.player.x - this.boss.x;
            const dy = this.player.y - this.boss.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if (dist > 60) {
                this.boss.x += (dx / dist) * this.boss.speed * dt;
                this.boss.y += (dy / dist) * this.boss.speed * dt;
                this.boss.facingRight = dx > 0;
            }
            
            if (dist < 70) {
                this.boss.attackTimer -= dt;
                if (this.boss.attackTimer <= 0) {
                    this.player.hp -= this.boss.damage;
                    this.boss.attackTimer = 1.5;
                    this.damageNumbers.push({
                        x: this.player.x, y: this.player.y - 40,
                        text: Math.floor(this.boss.damage),
                        color: '#ff0000',
                        life: 0.8
                    });
                }
            }
            
            this.boss.frameTime += dt;
            if (this.boss.frameTime >= 0.15) {
                this.boss.frame++;
                this.boss.frameTime = 0;
            }
        }
    }
    
    killEnemy(enemy) {
        if (enemy === this.boss) {
            this.gameOver(true);
            return;
        }
        
        const idx = this.enemies.indexOf(enemy);
        if (idx !== -1) this.enemies.splice(idx, 1);
        
        this.kills++;
        
        // Drop gold
        const goldAmt = Math.floor(enemy.type.gold * (1 + this.player.goldBonus));
        this.gold += goldAmt;
        
        // Drop pickup
        if (Math.random() < 0.3) {
            this.pickups.push({
                x: enemy.x, y: enemy.y,
                type: Math.random() < 0.7 ? 'gold' : 'meat',
                value: Math.random() < 0.5 ? goldAmt : 15,
                frame: 0, frameTime: 0
            });
        }
        
        // Explosion effect
        this.effects.push({
            type: 'explosion',
            x: enemy.x, y: enemy.y,
            frame: 0, frameTime: 0, life: 0.5
        });
        
        // XP
        this.xp += enemy.type.xp;
        if (this.xp >= this.xpToNext) {
            this.levelUp();
        }
    }
    
    spawnBoss() {
        this.bossSpawned = true;
        this.enemies = this.enemies.slice(0, 5);
        
        const angle = Math.random() * Math.PI * 2;
        this.boss = {
            x: this.player.x + Math.cos(angle) * 600,
            y: this.player.y + Math.sin(angle) * 600,
            hp: 3000,
            maxHp: 3000,
            damage: 25,
            speed: 70,
            frame: 0,
            frameTime: 0,
            facingRight: true,
            attackTimer: 1.5,
            size: 120
        };
    }
    
    // ==================== PROJECTILES & PICKUPS ====================
    updateProjectiles(dt) {
        for (let i = this.projectiles.length - 1; i >= 0; i--) {
            const p = this.projectiles[i];
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.life -= dt;
            
            if (p.life <= 0) {
                this.projectiles.splice(i, 1);
                continue;
            }
            
            const all = this.boss ? [...this.enemies, this.boss] : this.enemies;
            for (const e of all) {
                if (this.dist(p, e) < 35) {
                    let dmg = p.damage;
                    let crit = Math.random() < this.player.crit;
                    if (crit) dmg *= 2;
                    
                    e.hp -= dmg;
                    this.damageNumbers.push({
                        x: e.x, y: e.y - 40,
                        text: Math.floor(dmg),
                        color: crit ? '#ffff00' : '#ffffff',
                        life: 0.8
                    });
                    
                    if (e.hp <= 0) this.killEnemy(e);
                    this.projectiles.splice(i, 1);
                    break;
                }
            }
        }
    }
    
    updatePickups(dt) {
        for (let i = this.pickups.length - 1; i >= 0; i--) {
            const p = this.pickups[i];
            p.frameTime += dt;
            if (p.frameTime >= 0.15) {
                p.frame++;
                p.frameTime = 0;
            }
            
            if (this.dist(this.player, p) < 60) {
                if (p.type === 'gold') {
                    this.gold += p.value;
                } else {
                    this.player.hp = Math.min(this.player.maxHp, this.player.hp + p.value);
                }
                this.pickups.splice(i, 1);
            }
        }
    }
    
    updateEffects(dt) {
        for (let i = this.effects.length - 1; i >= 0; i--) {
            const e = this.effects[i];
            e.life -= dt;
            e.frameTime += dt;
            if (e.frameTime >= 0.05) {
                e.frame++;
                e.frameTime = 0;
            }
            if (e.life <= 0) this.effects.splice(i, 1);
        }
    }
    
    // ==================== LEVEL UP ====================
    levelUp() {
        this.xp -= this.xpToNext;
        this.level++;
        this.xpToNext = Math.floor(15 * Math.pow(1.2, this.level - 1));
        this.state = 'levelup';
        
        const upgrades = [
            { name: 'ŸÇŸàÿ© ÿßŸÑŸáÿ¨ŸàŸÖ', desc: '+20% ÿ∂ÿ±ÿ±', icon: 1, apply: () => this.player.damage *= 1.2 },
            { name: 'ÿßŸÑÿ≥ÿ±ÿπÿ©', desc: '+15% ÿ≥ÿ±ÿπÿ©', icon: 2, apply: () => this.player.speed *= 1.15 },
            { name: 'ÿ≥ÿ±ÿπÿ© ÿßŸÑŸáÿ¨ŸàŸÖ', desc: '+15% ÿ≥ÿ±ÿπÿ© Ÿáÿ¨ŸàŸÖ', icon: 3, apply: () => this.player.attackSpeed *= 1.15 },
            { name: 'ÿßŸÑÿµÿ≠ÿ©', desc: '+25 ÿµÿ≠ÿ©', icon: 4, apply: () => { this.player.maxHp += 25; this.player.hp += 25; } },
            { name: 'ÿßŸÑŸÖÿØŸâ', desc: '+20% ŸÖÿØŸâ', icon: 5, apply: () => this.player.range *= 1.2 },
            { name: 'ÿßŸÑÿ™ÿ¨ÿØŸäÿØ', desc: '+2 ÿ¥ŸÅÿßÿ°/ÿ´', icon: 6, apply: () => this.player.regen += 2 },
            { name: 'ÿßŸÑÿ∂ÿ±ÿ®ÿ© ÿßŸÑÿ≠ÿ±ÿ¨ÿ©', desc: '+8% ŸÉÿ±Ÿäÿ™ŸäŸÉÿßŸÑ', icon: 7, apply: () => this.player.crit += 0.08 },
            { name: 'ÿßŸÑÿ∞Ÿáÿ®', desc: '+25% ÿ∞Ÿáÿ®', icon: 8, apply: () => this.player.goldBonus += 0.25 }
        ];
        
        // Pick 3 random
        const shuffled = upgrades.sort(() => Math.random() - 0.5);
        this.currentUpgrades = shuffled.slice(0, 3);
    }
    
    selectUpgrade(upgrade) {
        upgrade.apply();
        this.state = 'playing';
    }
    
    gameOver(victory) {
        this.state = 'gameover';
        this.victory = victory;
    }
    
    // ==================== RENDERING ====================
    render() {
        this.ctx.fillStyle = '#3d6d3d';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        if (this.state === 'menu') {
            this.renderMenu();
        } else if (this.state === 'playing' || this.state === 'levelup') {
            this.renderGame();
            this.renderHUD();
            if (this.state === 'levelup') this.renderLevelUp();
        } else if (this.state === 'gameover') {
            this.renderGame();
            this.renderGameOver();
        }
    }
    
    renderMenu() {
        const cx = this.canvas.width / 2;
        const cy = this.canvas.height / 2;
        this.menuButtons = [];
        
        // Background
        this.renderTerrain(0, 0);
        
        // Darken
        this.ctx.fillStyle = 'rgba(0,0,0,0.7)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Banner background
        const banner = this.assets.get('ui_banner');
        if (banner) {
            this.ctx.drawImage(banner, cx - 200, cy - 280, 400, 400);
        }
        
        // Title with swords
        const swords = this.assets.get('ui_swords');
        if (swords) {
            this.ctx.drawImage(swords, cx - 100, cy - 260, 200, 80);
        }
        
        this.ctx.fillStyle = '#ffd700';
        this.ctx.font = 'bold 36px sans-serif';
        this.ctx.textAlign = 'center';
        this.ctx.fillText('Tiny Swords', cx, cy - 180);
        
        this.ctx.fillStyle = '#fff';
        this.ctx.font = '18px sans-serif';
        this.ctx.fillText('ÿßŸÇÿ™ŸÑ ÿßŸÑÿ®Ÿàÿ≥ ŸÅŸä 10 ÿØŸÇÿßÿ¶ŸÇ!', cx, cy - 150);
        
        // Character selection
        const chars = ['ÿßŸÑŸÖÿ≠ÿßÿ±ÿ®', 'ÿßŸÑÿ±ÿßŸÖŸä', 'ÿßŸÑÿ±ŸÖŸëÿßÿ≠', 'ÿßŸÑÿπÿßŸÖŸÑ'];
        const charKeys = ['warrior', 'archer', 'lancer', 'pawn'];
        
        // Avatar
        const avatar = this.assets.get('avatar_' + (this.selectedChar * 2 + 1));
        if (avatar) {
            this.ctx.drawImage(avatar, cx - 50, cy - 130, 100, 100);
        }
        
        // Character name
        this.ctx.fillStyle = '#ffd700';
        this.ctx.font = 'bold 24px sans-serif';
        this.ctx.fillText(chars[this.selectedChar], cx, cy + 5);
        
        // Character sprite preview
        const charSprite = this.assets.get(charKeys[this.selectedChar] + '_idle');
        if (charSprite) {
            this.ctx.drawImage(charSprite, 0, 0, 192, 192, cx - 48, cy + 15, 96, 96);
        }
        
        // Arrow buttons
        const arrowSize = 50;
        
        // Left arrow
        this.ctx.fillStyle = '#4a6a4a';
        this.ctx.fillRect(cx - 150, cy - 80, arrowSize, arrowSize);
        this.ctx.fillStyle = '#fff';
        this.ctx.font = '30px sans-serif';
        this.ctx.fillText('‚óÄ', cx - 125, cy - 45);
        this.menuButtons.push({
            x: cx - 150, y: cy - 80, w: arrowSize, h: arrowSize,
            action: () => { this.selectedChar = (this.selectedChar - 1 + 4) % 4; }
        });
        
        // Right arrow
        this.ctx.fillStyle = '#4a6a4a';
        this.ctx.fillRect(cx + 100, cy - 80, arrowSize, arrowSize);
        this.ctx.fillStyle = '#fff';
        this.ctx.fillText('‚ñ∂', cx + 125, cy - 45);
        this.menuButtons.push({
            x: cx + 100, y: cy - 80, w: arrowSize, h: arrowSize,
            action: () => { this.selectedChar = (this.selectedChar + 1) % 4; }
        });
        
        // Start button
        const btnW = 200, btnH = 60;
        const btnX = cx - btnW/2, btnY = cy + 130;
        const btn = this.assets.get('ui_btn_blue');
        if (btn) {
            this.ctx.drawImage(btn, btnX, btnY, btnW, btnH);
        } else {
            this.ctx.fillStyle = '#4488ff';
            this.ctx.fillRect(btnX, btnY, btnW, btnH);
        }
        this.ctx.fillStyle = '#fff';
        this.ctx.font = 'bold 22px sans-serif';
        this.ctx.fillText('‚öîÔ∏è ÿßÿ®ÿØÿ£ ÿßŸÑŸÑÿπÿ® ‚öîÔ∏è', cx, btnY + 40);
        this.menuButtons.push({
            x: btnX, y: btnY, w: btnW, h: btnH,
            action: () => this.startGame()
        });
    }
    
    renderGame() {
        this.ctx.save();
        this.ctx.translate(-this.camera.x, -this.camera.y);
        
        // Terrain
        this.renderTerrain(this.camera.x, this.camera.y);
        
        // Decorations (behind player)
        for (const d of this.decorations) {
            if (d.y < this.player.y) this.renderDecoration(d);
        }
        
        // Pickups
        for (const p of this.pickups) {
            this.renderPickup(p);
        }
        
        // Enemies
        for (const e of this.enemies) {
            this.renderEnemy(e);
        }
        
        // Boss
        if (this.boss) this.renderBoss();
        
        // Player
        this.renderPlayer();
        
        // Decorations (in front of player)
        for (const d of this.decorations) {
            if (d.y >= this.player.y) this.renderDecoration(d);
        }
        
        // Projectiles
        for (const p of this.projectiles) {
            this.renderProjectile(p);
        }
        
        // Effects
        for (const e of this.effects) {
            this.renderEffect(e);
        }
        
        // Damage numbers
        for (const d of this.damageNumbers) {
            this.ctx.globalAlpha = d.life;
            this.ctx.fillStyle = d.color;
            this.ctx.font = 'bold 18px sans-serif';
            this.ctx.textAlign = 'center';
            this.ctx.fillText(d.text, d.x, d.y);
            this.ctx.globalAlpha = 1;
        }
        
        this.ctx.restore();
    }
    
    renderTerrain(camX, camY) {
        const tilemap = this.assets.get('tilemap');
        if (!tilemap) return;
        
        const tileSize = 64;
        const tilesX = 9, tilesY = 6;
        
        // Draw grass tiles
        const startX = Math.floor(camX / tileSize) * tileSize - tileSize;
        const startY = Math.floor(camY / tileSize) * tileSize - tileSize;
        
        for (let x = startX; x < camX + this.canvas.width + tileSize; x += tileSize) {
            for (let y = startY; y < camY + this.canvas.height + tileSize; y += tileSize) {
                // Use grass tile (row 0, varying columns)
                const tileX = Math.abs((x / tileSize) % 3) * tileSize;
                const tileY = 0;
                this.ctx.drawImage(tilemap, tileX, tileY, tileSize, tileSize, x, y, tileSize, tileSize);
            }
        }
    }
    
    renderDecoration(d) {
        if (d.type === 'tree') {
            const sprite = this.assets.get('tree' + d.variant);
            if (sprite) {
                // Tree sprites are 256x256 per frame, 6 frames
                const frameSize = 256;
                const frame = d.frame % 4;
                this.ctx.drawImage(sprite, frame * frameSize, 0, frameSize, frameSize,
                    d.x - 64, d.y - 100, 128, 128);
            }
        } else if (d.type === 'bush') {
            const sprite = this.assets.get('bush' + d.variant);
            if (sprite) {
                // Bush sprites are 128x128 per frame
                const frameSize = 128;
                const frame = d.frame % 8;
                this.ctx.drawImage(sprite, frame * frameSize, 0, frameSize, frameSize,
                    d.x - 24, d.y - 24, 48, 48);
            }
        } else if (d.type === 'rock') {
            const sprite = this.assets.get('rock' + d.variant);
            if (sprite) {
                this.ctx.drawImage(sprite, d.x - 16, d.y - 16, 32, 32);
            }
        }
    }
    
    renderPickup(p) {
        const sprite = this.assets.get(p.type);
        if (sprite) {
            const frameSize = 64;
            const frame = p.frame % 7;
            this.ctx.drawImage(sprite, frame * frameSize, 0, frameSize, frameSize,
                p.x - 16, p.y - 16, 32, 32);
        } else {
            this.ctx.fillStyle = p.type === 'gold' ? '#ffd700' : '#ff6666';
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, 10, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }
    
    renderPlayer() {
        const p = this.player;
        const state = p.isMoving ? 'run' : 'idle';
        const sprite = this.assets.get(p.key + '_' + state);
        
        if (!sprite) {
            this.ctx.fillStyle = '#4488ff';
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, 24, 0, Math.PI * 2);
            this.ctx.fill();
            return;
        }
        
        const frameSize = 192;
        const frameCount = state === 'run' ? 6 : 8;
        const frame = p.frame % frameCount;
        
        this.ctx.save();
        this.ctx.translate(p.x, p.y);
        if (!p.facingRight) this.ctx.scale(-1, 1);
        
        this.ctx.drawImage(sprite, frame * frameSize, 0, frameSize, frameSize,
            -48, -48, 96, 96);
        
        this.ctx.restore();
    }
    
    renderEnemy(e) {
        let sprite = this.assets.get(e.type.key + '_run') || 
                     this.assets.get(e.type.key + '_walk') ||
                     this.assets.get(e.type.key + '_idle');
        
        if (!sprite) {
            this.ctx.fillStyle = '#ff4444';
            this.ctx.beginPath();
            this.ctx.arc(e.x, e.y, e.size / 2, 0, Math.PI * 2);
            this.ctx.fill();
        } else {
            const frameSize = e.type.key === 'bear' ? 256 : 192;
            const frame = e.frame % 6;
            const size = e.size;
            
            this.ctx.save();
            this.ctx.translate(e.x, e.y);
            if (!e.facingRight) this.ctx.scale(-1, 1);
            
            this.ctx.drawImage(sprite, frame * frameSize, 0, frameSize, frameSize,
                -size/2, -size/2, size, size);
            
            this.ctx.restore();
        }
        
        // Health bar
        const hpPct = e.hp / e.maxHp;
        const barW = e.size * 0.8;
        this.ctx.fillStyle = '#000';
        this.ctx.fillRect(e.x - barW/2 - 1, e.y - e.size/2 - 10, barW + 2, 8);
        this.ctx.fillStyle = '#ff4444';
        this.ctx.fillRect(e.x - barW/2, e.y - e.size/2 - 9, barW * hpPct, 6);
    }
    
    renderBoss() {
        const b = this.boss;
        const sprite = this.assets.get('minotaur_idle') || this.assets.get('minotaur_walk');
        
        if (sprite) {
            const frameSize = 192;
            const frame = b.frame % 6;
            
            this.ctx.save();
            this.ctx.translate(b.x, b.y);
            if (!b.facingRight) this.ctx.scale(-1, 1);
            
            this.ctx.drawImage(sprite, frame * frameSize, 0, frameSize, frameSize,
                -b.size/2, -b.size/2, b.size, b.size);
            
            this.ctx.restore();
        } else {
            this.ctx.fillStyle = '#8b0000';
            this.ctx.beginPath();
            this.ctx.arc(b.x, b.y, b.size/2, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }
    
    renderProjectile(p) {
        const arrow = this.assets.get('arrow');
        if (arrow && p.isArrow) {
            this.ctx.save();
            this.ctx.translate(p.x, p.y);
            this.ctx.rotate(p.angle);
            this.ctx.drawImage(arrow, -20, -5, 40, 10);
            this.ctx.restore();
        } else {
            this.ctx.fillStyle = '#ffff00';
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }
    
    renderEffect(e) {
        if (e.type === 'explosion') {
            const sprite = this.assets.get('fx_explosion1');
            if (sprite) {
                const frame = Math.min(e.frame, 7);
                this.ctx.drawImage(sprite, frame * 192, 0, 192, 192,
                    e.x - 48, e.y - 48, 96, 96);
            }
        }
    }
    
    renderHUD() {
        // Top left panel
        const barBase = this.assets.get('ui_bar_base');
        const barFill = this.assets.get('ui_bar_fill');
        
        // Health bar
        const hpX = 10, hpY = 10;
        if (barBase) {
            this.ctx.drawImage(barBase, hpX, hpY, 200, 40);
        }
        if (barFill) {
            const hpPct = this.player.hp / this.player.maxHp;
            // Red fill for health
            this.ctx.save();
            this.ctx.beginPath();
            this.ctx.rect(hpX + 10, hpY + 8, 180 * hpPct, 24);
            this.ctx.clip();
            for (let i = 0; i < 180 * hpPct; i += 40) {
                this.ctx.drawImage(barFill, hpX + 10 + i, hpY + 4, 40, 32);
            }
            this.ctx.restore();
            // Tint red
            this.ctx.fillStyle = 'rgba(255,0,0,0.3)';
            this.ctx.fillRect(hpX + 10, hpY + 8, 180 * hpPct, 24);
        }
        this.ctx.fillStyle = '#fff';
        this.ctx.font = 'bold 14px sans-serif';
        this.ctx.textAlign = 'center';
        this.ctx.fillText(`${Math.floor(this.player.hp)}/${this.player.maxHp}`, hpX + 100, hpY + 27);
        
        // XP bar
        const xpY = hpY + 45;
        if (barBase) {
            this.ctx.drawImage(barBase, hpX, xpY, 200, 40);
        }
        if (barFill) {
            const xpPct = this.xp / this.xpToNext;
            this.ctx.save();
            this.ctx.beginPath();
            this.ctx.rect(hpX + 10, xpY + 8, 180 * xpPct, 24);
            this.ctx.clip();
            for (let i = 0; i < 180 * xpPct; i += 40) {
                this.ctx.drawImage(barFill, hpX + 10 + i, xpY + 4, 40, 32);
            }
            this.ctx.restore();
            // Tint green
            this.ctx.fillStyle = 'rgba(0,255,0,0.3)';
            this.ctx.fillRect(hpX + 10, xpY + 8, 180 * xpPct, 24);
        }
        this.ctx.fillStyle = '#fff';
        this.ctx.fillText(`${this.xp}/${this.xpToNext}`, hpX + 100, xpY + 27);
        
        // Avatar
        const avatar = this.assets.get('avatar_' + this.player.avatar);
        if (avatar) {
            this.ctx.drawImage(avatar, hpX + 205, hpY, 80, 80);
        }
        
        // Gold
        const goldIcon = this.assets.get('icon_1');
        this.ctx.fillStyle = 'rgba(0,0,0,0.6)';
        this.ctx.fillRect(hpX, xpY + 50, 100, 30);
        if (goldIcon) {
            this.ctx.drawImage(goldIcon, hpX + 5, xpY + 53, 24, 24);
        }
        this.ctx.fillStyle = '#ffd700';
        this.ctx.font = 'bold 16px sans-serif';
        this.ctx.textAlign = 'left';
        this.ctx.fillText(this.gold, hpX + 35, xpY + 72);
        
        // Right side stats
        const rightX = this.canvas.width - 120;
        this.ctx.fillStyle = 'rgba(0,0,0,0.6)';
        this.ctx.fillRect(rightX, 10, 110, 100);
        
        this.ctx.fillStyle = '#88ff88';
        this.ctx.textAlign = 'right';
        this.ctx.fillText(`Lv.${this.level}`, rightX + 100, 35);
        
        this.ctx.fillStyle = '#ff8888';
        this.ctx.fillText(`üíÄ ${this.kills}`, rightX + 100, 60);
        
        const remaining = Math.max(0, 600 - this.gameTime);
        const mins = Math.floor(remaining / 60);
        const secs = Math.floor(remaining % 60);
        this.ctx.fillStyle = '#88ccff';
        this.ctx.fillText(`${mins}:${secs.toString().padStart(2, '0')}`, rightX + 100, 85);
        
        // Boss health bar
        if (this.boss) {
            const bossBarW = 400;
            const bossBarX = (this.canvas.width - bossBarW) / 2;
            this.ctx.fillStyle = '#000';
            this.ctx.fillRect(bossBarX - 2, 8, bossBarW + 4, 34);
            this.ctx.fillStyle = '#8b0000';
            this.ctx.fillRect(bossBarX, 10, bossBarW * (this.boss.hp / this.boss.maxHp), 30);
            this.ctx.fillStyle = '#fff';
            this.ctx.textAlign = 'center';
            this.ctx.font = 'bold 16px sans-serif';
            this.ctx.fillText(`ÿßŸÑŸÖŸäŸÜŸàÿ™Ÿàÿ± ÿßŸÑÿπÿ∏ŸäŸÖ - ${Math.floor(this.boss.hp)}/${this.boss.maxHp}`, this.canvas.width / 2, 32);
        }
        
        // Virtual joystick indicator
        if (this.touch.active && this.state === 'playing') {
            this.ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            this.ctx.lineWidth = 3;
            this.ctx.beginPath();
            this.ctx.arc(this.touch.startX, this.touch.startY, 60, 0, Math.PI * 2);
            this.ctx.stroke();
            
            this.ctx.fillStyle = 'rgba(255,255,255,0.5)';
            this.ctx.beginPath();
            this.ctx.arc(
                this.touch.startX + this.joystick.x * 40,
                this.touch.startY + this.joystick.y * 40,
                25, 0, Math.PI * 2
            );
            this.ctx.fill();
        }
    }
    
    renderLevelUp() {
        // Overlay
        this.ctx.fillStyle = 'rgba(0,0,0,0.8)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        const cx = this.canvas.width / 2;
        const cy = this.canvas.height / 2;
        
        // Banner
        const banner = this.assets.get('ui_banner');
        if (banner) {
            this.ctx.drawImage(banner, cx - 250, cy - 200, 500, 400);
        }
        
        // Title
        this.ctx.fillStyle = '#ffd700';
        this.ctx.font = 'bold 32px sans-serif';
        this.ctx.textAlign = 'center';
        this.ctx.fillText('üéâ ŸÖÿ≥ÿ™ŸàŸâ ÿ¨ÿØŸäÿØ! üéâ', cx, cy - 130);
        this.ctx.fillText(`ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ ${this.level}`, cx, cy - 90);
        
        // Upgrade cards
        this.upgradeCards = [];
        const cardW = 140, cardH = 160;
        const startX = cx - (cardW * 1.5 + 20);
        
        for (let i = 0; i < 3; i++) {
            const upgrade = this.currentUpgrades[i];
            const x = startX + i * (cardW + 20);
            const y = cy - 40;
            
            // Card background
            const woodTable = this.assets.get('ui_wood_table');
            if (woodTable) {
                this.ctx.drawImage(woodTable, x, y, cardW, cardH);
            } else {
                this.ctx.fillStyle = '#5a4a3a';
                this.ctx.fillRect(x, y, cardW, cardH);
            }
            
            // Icon
            const icon = this.assets.get('icon_' + upgrade.icon);
            if (icon) {
                this.ctx.drawImage(icon, x + cardW/2 - 24, y + 15, 48, 48);
            }
            
            // Text
            this.ctx.fillStyle = '#ffd700';
            this.ctx.font = 'bold 14px sans-serif';
            this.ctx.fillText(upgrade.name, x + cardW/2, y + 85);
            
            this.ctx.fillStyle = '#fff';
            this.ctx.font = '12px sans-serif';
            this.ctx.fillText(upgrade.desc, x + cardW/2, y + 110);
            
            this.upgradeCards.push({
                x, y, w: cardW, h: cardH, upgrade
            });
        }
    }
    
    renderGameOver() {
        this.ctx.fillStyle = 'rgba(0,0,0,0.85)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        const cx = this.canvas.width / 2;
        const cy = this.canvas.height / 2;
        
        // Title
        this.ctx.font = 'bold 48px sans-serif';
        this.ctx.textAlign = 'center';
        if (this.victory) {
            this.ctx.fillStyle = '#ffd700';
            this.ctx.fillText('üéâ ÿßŸÜÿ™ÿµÿßÿ±! üéâ', cx, cy - 100);
        } else {
            this.ctx.fillStyle = '#ff4444';
            this.ctx.fillText('üíÄ Ÿáÿ≤ŸäŸÖÿ© üíÄ', cx, cy - 100);
        }
        
        // Stats
        this.ctx.fillStyle = '#fff';
        this.ctx.font = '24px sans-serif';
        const mins = Math.floor(this.gameTime / 60);
        const secs = Math.floor(this.gameTime % 60);
        this.ctx.fillText(`‚è±Ô∏è ÿßŸÑŸàŸÇÿ™: ${mins}:${secs.toString().padStart(2, '0')}`, cx, cy - 30);
        this.ctx.fillText(`üíÄ ÿßŸÑŸÇÿ™ŸÑŸâ: ${this.kills}`, cx, cy + 10);
        this.ctx.fillText(`ü™ô ÿßŸÑÿ∞Ÿáÿ®: ${this.gold}`, cx, cy + 50);
        this.ctx.fillText(`üìä ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ: ${this.level}`, cx, cy + 90);
        
        // Restart button
        const btnW = 200, btnH = 60;
        const btnX = cx - btnW/2, btnY = cy + 130;
        
        const btn = this.assets.get('ui_btn_blue');
        if (btn) {
            this.ctx.drawImage(btn, btnX, btnY, btnW, btnH);
        } else {
            this.ctx.fillStyle = '#4488ff';
            this.ctx.fillRect(btnX, btnY, btnW, btnH);
        }
        
        this.ctx.fillStyle = '#fff';
        this.ctx.font = 'bold 20px sans-serif';
        this.ctx.fillText('üîÑ ÿßŸÑÿπÿ® ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ', cx, btnY + 38);
        
        this.restartButton = { x: btnX, y: btnY, w: btnW, h: btnH };
    }
}

// Start game
const game = new Game();
game.init();
</script>
</body>
</html>
